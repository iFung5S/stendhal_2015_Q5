<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WordList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.common.parser</a> &gt; <span class="el_source">WordList.java</span></div><h1>WordList.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.common.parser;

import games.stendhal.common.grammar.Grammar;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.AbstractList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeMap;

import marauroa.common.Log4J;
import marauroa.common.io.UnicodeSupportingInputStreamReader;

import org.apache.log4j.Logger;

/**
 * WordList stores a list of words recognized by the ConversationParser. Words
 * are categorised by type (noun, verb, adjective, preposition) and optionally
 * sub-types (animals, food, fluids, ...).
 * 
 * @author Martin Fuchs
 */

<span class="fc" id="L43">final public class WordList {</span>

<span class="fc" id="L45">	private static final Logger logger = Logger.getLogger(WordList.class);</span>

	// ExpressionTypes for dynamic registration
	public static final String SUBJECT_NAME_DYNAMIC = ExpressionType.SUBJECT_NAME
			+ ExpressionType.SUFFIX_DYNAMIC;

	public static final String VERB_DYNAMIC = ExpressionType.VERB
			+ ExpressionType.SUFFIX_DYNAMIC;

	public static final String WORDS_FILENAME = &quot;words.txt&quot;;

<span class="fc" id="L56">	private Map&lt;String, WordEntry&gt; words = new TreeMap&lt;String, WordEntry&gt;();</span>

<span class="fc" id="L58">	private Map&lt;String, Set&lt;CompoundName&gt;&gt; compoundNames = new HashMap&lt;String, Set&lt;CompoundName&gt;&gt;();</span>

	// We keep house holding the usage of registered subject names (see registerSubjectName).
<span class="fc" id="L61">	private Map&lt;String, Integer&gt; subjectRefCount = new HashMap&lt;String, Integer&gt;();</span>

	/** instance variable with package protection because of FindBugs hint */
	static private WordList instance;

	// Initialise the word list by reading from the
	// input file &quot;words.txt&quot; in the class path.
	static {
<span class="fc" id="L69">		Log4J.init();</span>

<span class="fc" id="L71">		initInstance();</span>
<span class="fc" id="L72">	}</span>

	/**
	 * Initialises the WordList instance.
	 */
	private static void initInstance() {
		// read word list from &quot;words.txt&quot;
<span class="fc" id="L79">		instance = new WordList();</span>

<span class="fc" id="L81">		instance.readFromResources();</span>
<span class="fc" id="L82">	}</span>

	/**
	 * Reads the word list from the resource file &quot;words.txt&quot;.
	 */
	private void readFromResources() {

<span class="fc" id="L89">		final InputStream str = WordList.class.getResourceAsStream(WORDS_FILENAME);</span>

<span class="pc bpc" id="L91" title="2 of 4 branches missed.">        if (str != null) {</span>
    		try {
<span class="fc" id="L93">    			final BufferedReader reader = new BufferedReader(new UnicodeSupportingInputStreamReader(str, &quot;UTF-8&quot;));</span>

    			try {
<span class="fc" id="L96">    				read(reader, null);</span>
<span class="nc" id="L97">    			} catch (final IOException e) {</span>
<span class="nc" id="L98">    				logger.error(&quot;error while reading resource file '&quot;+WORDS_FILENAME+&quot;'&quot;, e);</span>
    			} finally {
<span class="nc" id="L100">    				try {</span>
<span class="pc" id="L101">    					reader.close();</span>
<span class="nc" id="L102">    				} catch (IOException e) {</span>
<span class="nc" id="L103">    					logger.error(&quot;error while closing reader stream for '&quot;+WORDS_FILENAME+&quot;'&quot;, e);</span>
<span class="pc" id="L104">    				}</span>
<span class="nc" id="L105">    			}</span>
			} finally {
<span class="nc" id="L107">    			try {</span>
<span class="pc" id="L108">    				str.close();</span>
<span class="nc" id="L109">    			} catch (IOException e) {</span>
<span class="nc" id="L110">    				logger.warn(&quot;exception on closing resource stream&quot;, e);</span>
<span class="pc" id="L111">    			}</span>
<span class="nc" id="L112">    		}</span>
        } else {
<span class="nc" id="L114">            logger.error(&quot;unable to locate resource file '&quot;+WORDS_FILENAME+&quot;'&quot;);            </span>
        }
<span class="fc" id="L116">	}</span>

	/**
	 * Returns a reference to the global word list instance.
	 * 
	 * @return WordList
	 */
	public static WordList getInstance() {
<span class="fc" id="L124">		return instance;</span>
	}

	/**
	 * Reads word list from reader object.
	 * 
	 * @param reader
	 * @param comments
	 * @throws IOException
	 */
	public void read(final BufferedReader reader, final List&lt;String&gt; comments) throws IOException {
		while (true) {
<span class="fc" id="L136">			final String line = reader.readLine();</span>
<span class="fc bfc" id="L137" title="All 4 branches covered.">			if (line == null) {</span>
<span class="fc" id="L138">				break;</span>
			}

<span class="fc bfc" id="L141" title="All 4 branches covered.">			if (line.startsWith(&quot;#&quot;)) {</span>
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">				if (comments != null) {</span>
<span class="nc" id="L143">					comments.add(line);</span>
				}
			} else {
<span class="fc" id="L146">				final StringTokenizer tk = new StringTokenizer(line);</span>

<span class="fc bfc" id="L148" title="All 4 branches covered.">				if (!tk.hasMoreTokens()) {</span>
<span class="fc" id="L149">					continue;</span>
				}

<span class="fc" id="L152">				String key = tk.nextToken();</span>

<span class="fc" id="L154">				key = trimWord(key);</span>
<span class="fc" id="L155">				final WordEntry entry = new WordEntry();</span>
<span class="fc" id="L156">				entry.setNormalized(key);</span>

<span class="fc" id="L158">				readEntryLine(key, tk, entry);</span>
<span class="fc" id="L159">				addEntry(key, entry);</span>
			}
<span class="fc" id="L161">		}</span>

		// calculate the hash value from all word entries
//		calculateHash();
<span class="fc" id="L165">	}</span>

	/**
	 * Reads one line of the word list and adds the new entry.
	 * 
	 * @param key
	 * 
	 * @param tk
	 * @param entry
	 */
	private void readEntryLine(final String key, final StringTokenizer tk,
			final WordEntry entry) {
<span class="pc bpc" id="L177" title="2 of 4 branches missed.">		if (tk.hasMoreTokens()) {</span>
<span class="fc" id="L178">			entry.setType(new ExpressionType(tk.nextToken()));</span>

<span class="fc bfc" id="L180" title="All 4 branches covered.">			if (tk.hasMoreTokens()) {</span>
<span class="fc" id="L181">				String s = tk.nextToken();</span>

<span class="fc bfc" id="L183" title="All 4 branches covered.">				if (s.charAt(0) == '=') {</span>
<span class="fc" id="L184">					entry.setNormalized(trimWord(s.substring(1)));</span>
<span class="fc bfc" id="L185" title="All 4 branches covered.">					if (tk.hasMoreTokens()) {</span>
<span class="fc" id="L186">						s = tk.nextToken();</span>
					} else {
<span class="fc" id="L188">						s = null;</span>
					}
				}

<span class="fc bfc" id="L192" title="All 4 branches covered.">				if (s != null) {</span>
<span class="fc bfc" id="L193" title="All 4 branches covered.">					if (entry.isNumeral()) {</span>
<span class="fc" id="L194">						entry.setValue(Integer.valueOf(s));</span>
					} else {
<span class="fc" id="L196">						entry.setPlurSing(s);</span>
					}
				}
			}

<span class="fc" id="L201">			final String normalized = entry.getNormalized();</span>

<span class="fc bfc" id="L203" title="All 4 branches covered.">			if (Character.isLowerCase(entry.getTypeString().charAt(0))) {</span>
				// Type identifiers are always upper case, so a word in
				// lower case must be a plural.
<span class="fc" id="L206">				entry.setType(new ExpressionType(ExpressionType.OBJECT));</span>
<span class="fc" id="L207">				entry.setPlurSing(trimWord(entry.getTypeString()));</span>
<span class="fc bfc" id="L208" title="All 8 branches covered.">			} else if ((entry.getPlurSing() == null)</span>
					&amp;&amp; entry.isObject()) {
				// complete missing plural expressions using the
				// Grammar.plural() function
<span class="fc" id="L212">				final String plural = Grammar.plural(normalized);</span>

				// only store single word plurals
<span class="fc bfc" id="L215" title="All 4 branches covered.">				if (plural.indexOf(' ') == -1) {</span>
<span class="fc" id="L216">					entry.setPlurSing(plural);</span>
				}
<span class="fc bfc" id="L218" title="All 4 branches covered.">			} else if (entry.getPlurSing() != null) {</span>
				// check plural strings using the Grammar.plural() function
<span class="fc bfc" id="L220" title="All 12 branches covered.">				if (!entry.isPronoun() &amp;&amp; !entry.isObsessional() &amp;&amp;</span>
					!normalized.equals(&quot;is&quot;)) {
<span class="fc" id="L222">					String plural = Grammar.plural(key);</span>

<span class="fc bfc" id="L224" title="All 8 branches covered.">					if ((plural.indexOf(' ') == -1)</span>
							&amp;&amp; !plural.equals(entry.getPlurSing())) {
						// retry with normalized in case it differs from key
<span class="fc" id="L227">						plural = Grammar.plural(normalized);</span>

<span class="pc bpc" id="L229" title="2 of 8 branches missed.">						if ((plural.indexOf(' ') == -1)</span>
								&amp;&amp; !plural.equals(entry.getPlurSing())) {
<span class="fc" id="L231">							logger.warn(String.format(</span>
									&quot;suspicious plural: %s -&gt; %s (%s?)&quot;, key,
									entry.getPlurSing(), plural));
						}
					}
				}
			}

<span class="pc bpc" id="L239" title="2 of 4 branches missed.">			while (tk.hasMoreTokens()) {</span>
<span class="nc" id="L240">				logger.warn(&quot;superfluous trailing word in words.txt: &quot;</span>
						+ tk.nextToken());
			}
		}
<span class="fc" id="L244">	}</span>

	/**
	 * Add an entry to the word list.
	 * 
	 * @param key
	 * @param entry
	 */
	private void addEntry(final String key, final WordEntry entry) {
<span class="fc" id="L253">		words.put(trimWord(key), entry);</span>

		// store plural and associate with singular form
<span class="fc bfc" id="L256" title="All 8 branches covered.">		if ((entry.getPlurSing() != null)</span>
				&amp;&amp; !entry.getPlurSing().equals(entry.getNormalized())) {
<span class="fc" id="L258">			final WordEntry pluralEntry = new WordEntry();</span>

<span class="fc" id="L260">			pluralEntry.setNormalized(entry.getPlurSing());</span>
<span class="fc" id="L261">			pluralEntry.setType(new ExpressionType(entry.getTypeString()</span>
					+ ExpressionType.SUFFIX_PLURAL));
<span class="fc" id="L263">			pluralEntry.setPlurSing(entry.getNormalized());</span>
<span class="fc" id="L264">			pluralEntry.setValue(entry.getValue());</span>

<span class="fc" id="L266">			final WordEntry prev = words.put(entry.getPlurSing(), pluralEntry);</span>

<span class="fc bfc" id="L268" title="All 4 branches covered.">			if (prev != null) {</span>
<span class="fc" id="L269">				logger.debug(String.format(&quot;ambiguous plural: %s/%s -&gt; %s&quot;,</span>
						pluralEntry.getPlurSing(), prev.getPlurSing(),
						entry.getPlurSing()));

<span class="fc" id="L273">				pluralEntry.setPlurSing(null);</span>
<span class="fc" id="L274">				prev.setPlurSing(null);</span>
			}
		}
<span class="fc" id="L277">	}</span>

	/**
	 * Print all words of a given (main-)type.
	 * 
	 * @param writer
	 * @param type
	 */
	public void printWordType(final PrintWriter writer, final String type) {
<span class="nc bnc" id="L286" title="All 4 branches missed.">		for (Map.Entry&lt;String, WordEntry&gt; it : words.entrySet()) {</span>
<span class="nc" id="L287">			final WordEntry entry = it.getValue();</span>
			boolean matches;

<span class="nc bnc" id="L290" title="All 4 branches missed.">			if (type == null) {</span>
				// match all entries with empty type specifier
<span class="nc bnc" id="L292" title="All 4 branches missed.">				matches = entry.getType() == null;</span>
			} else {
				// all real (no plural) entries with matching type string
<span class="nc bnc" id="L295" title="All 8 branches missed.">				matches = entry.getTypeString().startsWith(type)</span>
						&amp;&amp; !entry.isPlural();
			}

<span class="nc bnc" id="L299" title="All 4 branches missed.">			if (matches) {</span>
<span class="nc" id="L300">				entry.print(writer, it.getKey());</span>

<span class="nc" id="L302">				writer.println();</span>
			}
<span class="nc" id="L304">		}</span>
<span class="nc" id="L305">	}</span>

	/**
	 * Transform the given word to lower case and trim special characters at
	 * beginning and end to use this normalized form as key in the word list.
	 * 
	 * @param word
	 * @return the trimmed word
	 */
	public static String trimWord(final String word) {
<span class="fc" id="L315">		String tempword = word.toLowerCase();</span>

		// Currently we only need to trim &quot;'&quot; characters.
<span class="fc bfc" id="L318" title="All 4 branches covered.">		while (tempword.length() &gt; 0) {</span>
<span class="fc" id="L319">			final char c = tempword.charAt(0);</span>

<span class="fc bfc" id="L321" title="All 4 branches covered.">			if (c == '\'') {</span>
<span class="fc" id="L322">				tempword = tempword.substring(1);</span>
			} else {
				break;
			}
<span class="fc" id="L326">		}</span>

<span class="fc bfc" id="L328" title="All 4 branches covered.">		while (tempword.length() &gt; 0) {</span>
<span class="fc" id="L329">			final char c = tempword.charAt(tempword.length() - 1);</span>

<span class="fc bfc" id="L331" title="All 4 branches covered.">			if (c == '\'') {</span>
<span class="fc" id="L332">				tempword = tempword.substring(0, tempword.length() - 1);</span>
			} else {
				break;
			}
<span class="fc" id="L336">		}</span>

<span class="fc" id="L338">		return tempword;</span>
	}

	/**
	 * Find an entry for a given word.
	 * 
	 * @param str
	 * @return WordEntry
	 */
	public WordEntry find(final String str) {
<span class="fc" id="L348">		final WordEntry entry = words.get(trimWord(str));</span>

<span class="fc" id="L350">		return entry;</span>
	}

	/**
	 * Lookup the plural form of the given word from the word list.
	 * 
	 * @param word
	 * @return plural string
	 */
	public String plural(final String word) {
<span class="fc" id="L360">		final WordEntry entry = words.get(trimWord(word));</span>

<span class="fc bfc" id="L362" title="All 4 branches covered.">		if (entry != null) {</span>
<span class="pc bpc" id="L363" title="4 of 8 branches missed.">			if ((entry.getType() != null) &amp;&amp; !entry.getType().isPlural()) {</span>
				// return the associated singular from the word list
<span class="fc" id="L365">				return entry.getPlurSing();</span>
			} else {
				// The word is already in singular form.
<span class="nc" id="L368">				return entry.getNormalized();</span>
			}
		} else {
			// fall back: call Grammar.plural()
<span class="fc" id="L372">			return Grammar.plural(word);</span>
		}
	}

	/**
	 * Lookup the singular form of the given word from the word list.
	 * 
	 * @param word
	 * @return singular string
	 */
	public String singular(final String word) {
<span class="fc" id="L383">		final WordEntry entry = words.get(trimWord(word));</span>

<span class="pc bpc" id="L385" title="2 of 4 branches missed.">		if (entry != null) {</span>
<span class="pc bpc" id="L386" title="2 of 4 branches missed.">			if (entry.isPlural()) {</span>
				// return the associated singular from the word list
<span class="fc" id="L388">				return entry.getPlurSing();</span>
			} else {
				// The word is already in singular form.
<span class="nc" id="L391">				return entry.getNormalized();</span>
			}
		} else {
			// fall back: call Grammar.singular()
<span class="nc" id="L395">			return Grammar.singular(word);</span>
		}
	}

	/**
	 * Return type for normalizeVerb().
	 */
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">	static class Verb extends Grammar.Verb {</span>
		public Verb(Grammar.Verb verb, WordEntry entry) {
<span class="fc" id="L404">			super(verb);</span>

<span class="pc bpc" id="L406" title="6 of 8 branches missed.">			assert entry != null;</span>
<span class="fc" id="L407">			this.entry = entry;</span>
<span class="fc" id="L408">		}</span>

		public WordEntry entry; // is never null
	}

	/**
	 * Try to normalise the given word as verb.
	 * 
	 * @param word
	 * 
	 * @return Verb object with additional information
	 */
	Verb normalizeVerb(final String word) {
<span class="fc" id="L421">		final String trimmedWord = trimWord(word);</span>

<span class="fc" id="L423">		final Grammar.Verb verb = Grammar.normalizeRegularVerb(trimmedWord);</span>

<span class="fc bfc" id="L425" title="All 4 branches covered.">		if (verb != null) {</span>
<span class="fc" id="L426">			WordEntry entry = words.get(verb.word);</span>

			// try and re-append &quot;e&quot; if it was removed by
			// normalizeRegularVerb()
<span class="pc bpc" id="L430" title="6 of 12 branches missed.">			if ((entry == null) &amp;&amp; trimmedWord.endsWith(&quot;e&quot;)</span>
					&amp;&amp; !verb.word.endsWith(&quot;e&quot;)) {
<span class="nc" id="L432">				entry = words.get(verb.word + &quot;e&quot;);</span>
			}

<span class="fc bfc" id="L435" title="All 4 branches covered.">			if (entry != null) {</span>
<span class="fc" id="L436">				return new Verb(verb, entry);</span>
			}
		}

<span class="fc" id="L440">		return null;</span>
	}

	/**
	 * Try to find a matching word for a derived adjective.
	 * 
	 * @param word
	 * @return WordEntry
	 */
	WordEntry normalizeAdjective(final String word) {
<span class="fc" id="L450">		final String trimmedWord = trimWord(word);</span>

<span class="fc" id="L452">		final String normalized = Grammar.normalizeDerivedAdjective(trimmedWord);</span>

<span class="fc bfc" id="L454" title="All 4 branches covered.">		if (normalized != null) {</span>
<span class="fc" id="L455">			final WordEntry entry = words.get(normalized);</span>

<span class="fc" id="L457">			return entry;</span>
		} else {
<span class="fc" id="L459">			return null;</span>
		}
	}

	/**
	 * Register a subject name to be recognized by the conversation parser.
	 * 
	 * @param name
	 */
	public void registerSubjectName(final String name) {
<span class="fc" id="L469">		registerSubjectName(name, ExpressionType.SUBJECT_NAME);</span>
<span class="fc" id="L470">	}</span>

	/**
	 * Register a subject name to be recognized by the conversation parser.
	 * 
	 * @param name
	 * @param typeString
	 */
	public void registerSubjectName(final String name, final String typeString) {
<span class="fc" id="L479">		final String key = trimWord(name);</span>

<span class="fc" id="L481">		Integer usageCount = subjectRefCount.get(key);</span>
<span class="pc bpc" id="L482" title="2 of 8 branches missed.">		if ((usageCount != null) &amp;&amp; (usageCount &gt; 0)) {</span>
			// For already known names, we only have to increment the
			// usage counter.
<span class="fc" id="L485">			subjectRefCount.put(key, ++usageCount);</span>
<span class="fc" id="L486">			return;</span>
		}

		// register the new subject name
<span class="pc bpc" id="L490" title="2 of 4 branches missed.">		if (usageCount == null) {</span>
<span class="fc" id="L491">			registerName(name, typeString);</span>
<span class="fc" id="L492">			subjectRefCount.put(key, 1);</span>
		}
<span class="fc" id="L494">	}</span>

	/**
	 * De-register a subject name.
	 * 
	 * @param name
	 */
	public void unregisterSubjectName(final String name) {
<span class="fc" id="L502">		final String key = trimWord(name);</span>
<span class="fc" id="L503">		final WordEntry entry = words.get(key);</span>

<span class="fc bfc" id="L505" title="All 12 branches covered.">		if (entry != null &amp;&amp; entry.isName() &amp;&amp; entry.isDynamic()) {</span>
<span class="fc" id="L506">			Integer usageCount = subjectRefCount.get(key);</span>

<span class="pc bpc" id="L508" title="2 of 4 branches missed.">			if (usageCount != null) {</span>
				// decrement the usage counter
<span class="fc" id="L510">				subjectRefCount.put(key, --usageCount);</span>

<span class="fc bfc" id="L512" title="All 4 branches covered.">				if (usageCount == 0) {</span>
<span class="fc" id="L513">					subjectRefCount.remove(key);</span>
<span class="fc" id="L514">					unregisterName(name);</span>
				}
			}
		}
<span class="fc" id="L518">	}</span>

	/**
	 * Register an item or creature name to be recognized by the conversation
	 * parser.
	 * 
	 * @param name
	 * @param typeString
	 */
	public void registerName(final String name, final String typeString) {
		// parse item name without merging Expression entries
<span class="fc" id="L529">		final ConversationContext ctx = new ConversationContext();</span>
<span class="fc" id="L530">		ctx.setMergeExpressions(false);</span>
<span class="fc" id="L531">		final Sentence parsed = ConversationParser.parse(name, ctx);</span>

<span class="fc" id="L533">		Expression lastExpr = null;</span>
<span class="fc" id="L534">		boolean prepositionSeen = false;</span>

<span class="fc bfc" id="L536" title="All 4 branches covered.">		for (final Expression expr : parsed) {</span>
<span class="pc bpc" id="L537" title="2 of 8 branches missed.">			if ((expr.getType() == null) || expr.getType().isEmpty()) {</span>
				// register the unknown word as new entry
<span class="fc" id="L539">				final WordEntry entry = words.get(expr.getNormalized());</span>

				// set the type to the given one with added &quot;DYN&quot; suffix
<span class="fc" id="L542">				final ExpressionType type = new ExpressionType(typeString</span>
						+ ExpressionType.SUFFIX_DYNAMIC);
<span class="fc" id="L544">				entry.setType(type);</span>
<span class="fc" id="L545">				expr.setType(type);</span>
<span class="pc bpc" id="L546" title="2 of 4 branches missed.">			} else if (expr.isQuestion()) {</span>
<span class="nc" id="L547">				logger.warn(&quot;name already registered with incompatible expression type while registering name '&quot;</span>
						+ name + &quot;': &quot; + expr.getNormalizedWithTypeString()
						+ &quot; expected type: &quot; + typeString);
			}

<span class="fc bfc" id="L552" title="All 4 branches covered.">			if (expr.isPreposition()) {</span>
<span class="fc" id="L553">				prepositionSeen = true;</span>
<span class="fc bfc" id="L554" title="All 4 branches covered.">			} else if (!prepositionSeen) {</span>
<span class="fc" id="L555">				lastExpr = expr;</span>
			}
<span class="fc" id="L557">		}</span>

<span class="pc bpc" id="L559" title="2 of 4 branches missed.">		if (lastExpr != null) {</span>
<span class="fc bfc" id="L560" title="All 4 branches covered.">			if (!isNameCompatibleLastType(lastExpr, typeString)) {</span>
<span class="pc bpc" id="L561" title="2 of 4 branches missed.">				if (typeString.startsWith(ExpressionType.SUBJECT)) {</span>
					// ignore suspicious NPC names for now
				} else {
<span class="nc" id="L564">					logger.warn(&quot;last word of name '&quot; + name</span>
						+ &quot;' has an unexpected type: &quot;
						+ lastExpr.getNormalizedWithTypeString()
						+ &quot; expected type: &quot; + typeString);
				}
			}
		}

		// register compound item and subject names to use them when merging expressions
<span class="fc bfc" id="L573" title="All 4 branches covered.">		if (parsed.getExpressions().size() &gt; 1) {</span>
<span class="fc" id="L574">			Expression firstExpr = parsed.expressions.get(0);</span>
<span class="fc" id="L575">			String firstWord = firstExpr.getOriginal().toLowerCase();</span>

<span class="fc" id="L577">			Set&lt;CompoundName&gt; nameSet = compoundNames.get(firstWord);</span>

<span class="fc bfc" id="L579" title="All 4 branches covered.">			if (nameSet == null) {</span>
<span class="fc" id="L580">				nameSet = new HashSet&lt;CompoundName&gt;();</span>
<span class="fc" id="L581">				compoundNames.put(firstWord, nameSet);</span>
			}

<span class="fc" id="L584">			nameSet.add(new CompoundName(parsed, typeString));</span>
		}
<span class="fc" id="L586">	}</span>

	/**
	 * Search for compound names.
	 * @param expressions list of expressions
	 * @param idx start index of the expression list
	 * @return compound name or null
	 */
	public CompoundName searchCompoundName(AbstractList&lt;Expression&gt; expressions, int idx) {
<span class="fc" id="L595">        Expression first = expressions.get(idx);</span>

<span class="fc" id="L597">    	Set&lt;CompoundName&gt; candidates = compoundNames.get(first.getOriginal().toLowerCase());</span>

<span class="fc bfc" id="L599" title="All 4 branches covered.">		if (candidates != null) {</span>
<span class="fc bfc" id="L600" title="All 4 branches covered.">    		for(CompoundName compName : candidates) {</span>
<span class="fc bfc" id="L601" title="All 4 branches covered.">    			if (compName.matches(expressions, idx)) {</span>
<span class="fc" id="L602">    				return compName;</span>
    			}
<span class="fc" id="L604">    		}</span>
		}

<span class="fc" id="L607">		return null;</span>
	}

	/**
	 * De-register a name after all references have been removed.
	 * @param name
	 */
	private void unregisterName(final String name) {
		// parse item name without merging Expression entries
<span class="fc" id="L616">		final ConversationContext ctx = new ConversationContext();</span>
<span class="fc" id="L617">		ctx.setMergeExpressions(false);</span>
<span class="fc" id="L618">		final Sentence parsed = ConversationParser.parse(name, ctx);</span>

		// remove compound names
<span class="pc bpc" id="L621" title="2 of 4 branches missed.">		if (parsed.expressions.size() &gt; 1) {</span>
<span class="nc" id="L622">			Expression firstExpr = parsed.expressions.get(0);</span>
<span class="nc" id="L623">			String firstWord = firstExpr.getOriginal().toLowerCase();</span>

<span class="nc" id="L625">			Set&lt;CompoundName&gt; nameSet = compoundNames.get(firstWord);</span>

<span class="nc bnc" id="L627" title="All 4 branches missed.">			if (nameSet != null) {</span>
<span class="nc bnc" id="L628" title="All 4 branches missed.">				for(CompoundName compName : nameSet) {</span>
<span class="nc bnc" id="L629" title="All 4 branches missed.">					if (compName.matches(parsed.expressions, 0)) {</span>
<span class="nc" id="L630">						nameSet.remove(compName);</span>

<span class="nc bnc" id="L632" title="All 4 branches missed.">						if (nameSet.isEmpty()) {</span>
<span class="nc" id="L633">							compoundNames.remove(firstWord);</span>
						}

						break;
					}
<span class="nc" id="L638">				}</span>
			}
		}

<span class="fc bfc" id="L642" title="All 4 branches covered.">		for(Expression expr : parsed.expressions) {</span>
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">			if (expr.isDynamic()) {</span>
<span class="fc" id="L644">				words.remove(expr.getNormalized());</span>
			}
<span class="fc" id="L646">		}</span>
<span class="fc" id="L647">	}</span>

	/**
	 * Check for compatible types.
	 * 
	 * @param lastExpr last word in an expression
	 * @param typeString expected type string
	 * @return &lt;code&gt;true&lt;/code&gt; if the expression is of compatible type,
	 * 	otherwise &lt;code&gt;false&lt;/code&gt;
	 */
	private static boolean isNameCompatibleLastType(
			final Expression lastExpr, final String typeString) {
<span class="fc" id="L659">		final ExpressionType lastType = lastExpr.getType();</span>

<span class="fc bfc" id="L661" title="All 4 branches covered.">		if (lastType.getTypeString().startsWith(typeString)) {</span>
<span class="fc" id="L662">			return true;</span>
		}

<span class="fc bfc" id="L665" title="All 4 branches covered.">		if (typeString.startsWith(lastType.getTypeString())) {</span>
<span class="fc" id="L666">			return true;</span>
		}

<span class="pc bpc" id="L669" title="2 of 4 branches missed.">		if (lastType.isNumeral()) {</span>
<span class="nc" id="L670">			return true;</span>
		}

<span class="fc bfc" id="L673" title="All 4 branches covered.">		if (lastType.isDynamic()) {</span>
<span class="fc" id="L674">			return true;</span>
		}

		// Ignore words like &quot;chicken&quot;, &quot;cat&quot; and &quot;incorporeal armor&quot;, which are
		// registered as objects, but also used as subjects.
<span class="pc bpc" id="L679" title="2 of 8 branches missed.">		if (lastType.isObject() &amp;&amp; typeString.startsWith(ExpressionType.SUBJECT)) {</span>
<span class="fc" id="L680">			return true;</span>
		}
<span class="fc bfc" id="L682" title="All 8 branches covered.">		if (lastType.isSubject() &amp;&amp; typeString.startsWith(ExpressionType.OBJECT)) {</span>
<span class="fc" id="L683">			return true;</span>
		}

		// handle ambiguous cases like &quot;mill&quot;
<span class="fc bfc" id="L687" title="All 4 branches covered.">		if (Grammar.isAmbiguousNounVerb(lastExpr.getNormalized())) {</span>
<span class="pc bpc" id="L688" title="4 of 8 branches missed.">			if (lastType.isVerb() &amp;&amp; typeString.equals(ExpressionType.OBJECT)) {</span>
<span class="fc" id="L689">				return true;</span>
			}
<span class="nc bnc" id="L691" title="All 8 branches missed.">			if (lastType.isObject() &amp;&amp; typeString.equals(ExpressionType.VERB)) {</span>
<span class="nc" id="L692">				return true;</span>
			}
		}

<span class="fc" id="L696">		return false;</span>
	}

	/**
	 * Register a verb to be recognized by the conversation parser.
	 * 
	 * @param verb
	 */
	public void registerVerb(final String verb) {
<span class="fc" id="L705">		final String key = trimWord(verb);</span>
<span class="fc" id="L706">		final WordEntry entry = words.get(key);</span>

<span class="pc bpc" id="L708" title="6 of 12 branches missed.">		if ((entry == null) || (entry.getType() == null)</span>
				|| entry.getType().isEmpty()) {
<span class="nc" id="L710">			final WordEntry newEntry = new WordEntry();</span>

<span class="nc" id="L712">			newEntry.setNormalized(key);</span>
<span class="nc" id="L713">			newEntry.setType(new ExpressionType(VERB_DYNAMIC));</span>

<span class="nc" id="L715">			words.put(key, newEntry);</span>
//		} else if (!checkNameCompatibleLastType(entry, ExpressionType.VERB)) {
//	 		logger.warn(&quot;verb name already registered with incompatible expression type: &quot; +
//			entry.getNormalizedWithTypeString());
		}
<span class="fc" id="L720">	}</span>

	/**
	 * Add a new word to the list in order to remember it later.
	 * 
	 * @param str
	 * @return the added entry
	 */
	public WordEntry addNewWord(final String str) {
<span class="fc" id="L729">		final String key = trimWord(str);</span>
<span class="fc" id="L730">		WordEntry entry = words.get(key);</span>

<span class="pc bpc" id="L732" title="2 of 4 branches missed.">		if (entry == null) {</span>
<span class="fc" id="L733">			entry = new WordEntry();</span>
<span class="fc" id="L734">			entry.setType(new ExpressionType(&quot;&quot;));</span>

			// add the new entry
<span class="fc" id="L737">			entry.setNormalized(key);</span>
<span class="fc" id="L738">			words.put(key, entry);</span>
		} else {
<span class="nc" id="L740">			logger.warn(&quot;word already known: &quot; + str + &quot; -&gt; &quot;</span>
					+ entry.getNormalized());
		}

<span class="fc" id="L744">		return entry;</span>
	}

	/**
	 * Return number of word entries.
	 * @return number of entries
	 */
	public int getWordCount() {
<span class="nc" id="L752">		return words.size();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>