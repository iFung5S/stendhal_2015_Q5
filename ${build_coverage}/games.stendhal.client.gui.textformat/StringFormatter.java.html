<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StringFormatter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui.textformat</a> &gt; <span class="el_source">StringFormatter.java</span></div><h1>StringFormatter.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                   (C) Copyright 2003-2013 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui.textformat;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * A class for creating attributed strings from strings using the stendhal
 * style markup. The rules are:&lt;ol&gt;
 * 
 * 	&lt;li&gt;Text starts in a defined font and color mode.&lt;/li&gt;
 * 
 * 	&lt;li&gt;A special character changes to a mode specific to that character.&lt;/li&gt;
 * 
 *  &lt;li&gt;If a new special mode is started while the previous is in effect, their
 * 	effects are combined, the definitions of the newer mode overriding the other
 * 	where they would be in conflict.&lt;/li&gt;
 * 
 * 	&lt;li&gt;If the markup character is followed by a single quote &quot; ' &quot;, the mode
 * 	ends at the next single quote. Otherwise the mode ends at the next white
 * 	space or punctuation character. Only the last active mode is terminated.&lt;/li&gt;
 * 
 * 	&lt;li&gt;If a markup character would start a new mode that is the same as the
 * 	current effective, the markup character is treated as if it was a normal
 * 	character.&lt;/li&gt;
 * 
 * 	&lt;li&gt;The backslash character '\' can be used to prevent the normal effect
 * 	of the special characters to allow printing them. Backslash can be printed
 * 	by escaping it with itself '\\'.&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * @param &lt;K&gt; type of the TextFormatSet internal data
 * @param &lt;T&gt; type holding the text attributes 
 */
public class StringFormatter&lt;K, T extends FormatSet&lt;K, T&gt;&gt; {
	/** Punctuation characters. */
<span class="fc" id="L49">	private static final Collection&lt;Character&gt; endMarkers = Arrays.asList(' ', '\n', ',', '.', '!', '?');</span>
	
	private final Map&lt;Character, T&gt; coloringModes;
	
<span class="fc" id="L53">	public StringFormatter() {</span>
<span class="fc" id="L54">		coloringModes = new HashMap&lt;Character, T&gt;();</span>
<span class="fc" id="L55">	}</span>
	
	/**
	 * Add a formatting style.
	 *  
	 * @param c character for turning on the style
	 * @param attributes attributes to be used for the text in the style
	 */
	public void addStyle(Character c, T attributes) {
<span class="fc" id="L64">		coloringModes.put(c, attributes);</span>
<span class="fc" id="L65">	}</span>
	
	/**
	 * Format a string.
	 * 
	 * @param s string which may contain formatting markup
	 * @param normalAttributes attributes for the normal text
	 * @param dest destination to write parsed and attributed output
	 */
	public void format(String s, T normalAttributes, AttributedTextSink&lt;T&gt; dest) {	
<span class="fc" id="L75">		BaseState state = new BaseState(dest, normalAttributes, s, 0);</span>
		
<span class="fc" id="L77">		state.parse();</span>
<span class="fc" id="L78">	}</span>
	
	/**
	 * Base class for the parser states.
	 */
	private abstract class AbstractParserState {
		/** Attributes to be used for the printable characters. */
		final T attrs;
		/** Beginning of the current parses scan. */ 
		int beginIndex;
		/** Index of the character currently examined. */
		int index;
		/** Output destination. */
		final AttributedTextSink&lt;T&gt; dest;
		/** Formatted input string. */
		final String string;
		
		/**
		 * Create a new AbstractParserState.
		 *  
		 * @param builder AttributedTextSink for the use of adding
		 * 	processed output
		 * @param attributes text attributes for the state
		 * @param s raw format string
		 * @param index starting index for this parser instance
		 */
<span class="fc" id="L104">		AbstractParserState(AttributedTextSink&lt;T&gt; builder, T attributes, String s, int index) {</span>
<span class="fc" id="L105">			attrs = attributes;</span>
<span class="fc" id="L106">			beginIndex = index;</span>
<span class="fc" id="L107">			this.index = index;</span>
<span class="fc" id="L108">			this.dest = builder;</span>
<span class="fc" id="L109">			this.string = s;</span>
<span class="fc" id="L110">		}</span>
		
		/**
		 * Insert scanned elements to the output string.
		 */
		void push() {
<span class="fc" id="L116">			int endIndex = Math.min(index, string.length());</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">			if (endIndex &gt; beginIndex) {</span>
<span class="fc" id="L118">				dest.append(string.substring(beginIndex, endIndex), attrs);</span>
<span class="fc" id="L119">				beginIndex = index;</span>
			}
<span class="fc" id="L121">		}</span>
		
		/**
		 * Parse starting from the beginning index until the parser instance
		 * has finished its part.
		 * 
		 * @return index where the parser stopped
		 */
		abstract int parse();
	}
	
	/**
	 * The normal, starting state of the parser.
	 */
	private class BaseState extends AbstractParserState {
		/**
		 * Character that should not be treated as a special markup character.
		 * Used by child classes to detect transitions to the same state.
		 */
<span class="fc" id="L140">		private char ignoreChar = '\0';</span>
		/**
		 * A flag for detecting if the the state should terminate parsing at the
		 * next encountered single quote.
		 */
<span class="fc" id="L145">		boolean endAtQuote = false;</span>
		
		/**
		 * Create a new BaseState.
		 *  
		 * @param dest AttributedTextSink for the use of adding
		 * 	processed output
		 * @param attributes attributes for the state
		 * @param s raw format string
		 * @param index starting index for this parser instance
		 */
<span class="fc" id="L156">		BaseState(AttributedTextSink&lt;T&gt; dest, T attributes, String s, int index) {</span>
<span class="fc" id="L157">			super(dest, attributes, s, index);</span>
<span class="fc" id="L158">		}</span>

		/**
		 * Read the next character. Shifts to another parser state if special
		 * characters are met.
		 * 
		 * @return &lt;code&gt;true&lt;/code&gt; if the parser should stay in current mode,
		 * 	&lt;code&gt;false&lt;/code&gt; if a character that marks the end of this state
		 * 	was encountered
		 */
		boolean readNext() {
<span class="fc" id="L169">			char current = string.charAt(index);</span>
<span class="fc" id="L170">			T newAttrs = coloringModes.get(current);</span>
			
<span class="fc" id="L172">			AbstractParserState newState = null;</span>
			// Avoid switching to copy of current state. Required for ## to work
			// as expected
<span class="fc bfc" id="L175" title="All 4 branches covered.">			if ((newAttrs != null) &amp;&amp; (ignoreChar != current)) {</span>
<span class="fc" id="L176">				ColoringState s = new ColoringState(dest, attrs.union(newAttrs), string, index + 1);</span>
				// Add the current attributes first, so that we get a nice
				// combined effect
<span class="fc" id="L179">				s.ignore(current);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">				if (endAtQuote) {</span>
<span class="fc" id="L181">					s.setForceEndAtQuote();</span>
				}
<span class="fc" id="L183">				newState = s;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">			} else if (current == '\\') {</span>
<span class="fc" id="L185">				AbstractParserState s = new QuoteState(dest, attrs, string, index + 1);</span>
<span class="fc" id="L186">				newState = s;</span>
			}
			
<span class="fc bfc" id="L189" title="All 2 branches covered.">			if (newState != null) {</span>
<span class="fc" id="L190">				push();</span>
<span class="fc" id="L191">				index = newState.parse();</span>
<span class="fc" id="L192">				beginIndex = index;</span>
			} else {
<span class="fc" id="L194">				index++;</span>
			}
			
			// Nothing counts as the end character
<span class="fc" id="L198">			return true;</span>
		}
		
		/**
		 * Tell the parser to ignore a certain character. Used by child classes
		 * to prevent transitions to identical state.
		 * 
		 * @param ignoreChar character to be ignored. This is the markup
		 * 	character used to transition to this state
		 */
		void ignore(char ignoreChar) {
<span class="fc" id="L209">			this.ignoreChar = ignoreChar;</span>
<span class="fc" id="L210">		}</span>
		
		@Override
		int parse() {
<span class="fc bfc" id="L214" title="All 2 branches covered.">			while (index &lt; string.length()) {</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">				if (!readNext()) {</span>
<span class="fc" id="L216">					return index;</span>
				}
			}
<span class="fc" id="L219">			push();</span>
			
<span class="fc" id="L221">			return index;</span>
		}
	}
	
	/**
	 * A special parser state for the effects. This will terminate at either
	 * at the next punctuation character followed by white space, or at
	 * encountering a single quote if the initiating state transition character
	 * was followed by a single quote.
	 */
	private class ColoringState extends BaseState {
		/**
		 * Leave the state at an encountered single quote, even if this state
		 * was not started with a quoted marker. This is needed for situations
		 * where this is an inner state where the &lt;em&gt;outer&lt;/em&gt; was quoted, and
		 * thus quote should end both the states.
		 */
		private boolean forceEndAtQuote;
		
		/**
		 * Create a new ColoringState.
		 *
 		 * @param sink AttributedTextSink for the use of adding
		 * 	processed output
		 * @param attributes text attributes for the state
		 * @param s raw format string
		 * @param index starting index for this parser instance
		 */
<span class="fc" id="L249">		ColoringState(AttributedTextSink&lt;T&gt; sink, T attributes, String s, int index) {</span>
<span class="fc" id="L250">			super(sink, attributes, s, index);</span>
<span class="fc" id="L251">			checkFirst();</span>
<span class="fc" id="L252">		}</span>

		/**
		 * Read the first following character to verify if the state should be
		 * ended at a quote, or at the next whitespace or punctuation.
		 */
		private void checkFirst() {
<span class="fc bfc" id="L259" title="All 2 branches covered.">			if (index &lt; string.length()) {</span>
<span class="fc" id="L260">				char current = string.charAt(index);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">				if (current == '\'') {</span>
<span class="fc" id="L262">					endAtQuote = true;</span>
					// eat quote
<span class="fc" id="L264">					index++;</span>
<span class="fc" id="L265">					beginIndex = index;</span>
				}
			}
<span class="fc" id="L268">		}</span>
		
		@Override
		boolean readNext() {
<span class="fc" id="L272">			char current = string.charAt(index);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">			if (current == '\'') {</span>
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">				if (endAtQuote || forceEndAtQuote) {</span>
<span class="fc" id="L275">					push();</span>
					// eat end char
<span class="fc bfc" id="L277" title="All 2 branches covered.">					if (endAtQuote) {</span>
<span class="fc" id="L278">						index++;</span>
					}
<span class="fc" id="L280">					return false;</span>
				}
<span class="fc bfc" id="L282" title="All 4 branches covered.">			} else if (!endAtQuote &amp;&amp; endMarkers.contains(current)) {</span>
				// Punctuation ends the colouring only if the next character is
				// whitespace
<span class="pc bpc" id="L285" title="3 of 4 branches missed.">				if (Character.isWhitespace(current) || Character.isWhitespace(peekNext())) {</span>
<span class="fc" id="L286">					push();</span>
<span class="fc" id="L287">					return false;</span>
				}
			}
			
			// The normal mode transitions are after the rest to keep handling
			// the quoting last; that is needed to make \' working like it
			// should.
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">			if (index &gt;= string.length()) {</span>
<span class="nc" id="L295">				return false;</span>
			}
<span class="fc" id="L297">			super.readNext();</span>
				
<span class="fc" id="L299">			return true;</span>
		}
		
		/**
		 * Flag the state to end at the first encountered single quote. Used by
		 * outer states that need to end at the quoting.
		 */
		void setForceEndAtQuote() {
<span class="fc" id="L307">			forceEndAtQuote = true;</span>
<span class="fc" id="L308">		}</span>
	
		/**
		 * Get the value of the next character, if there is one.
		 * 
		 * @return the next character, or space ' ' if there is no next
		 * 	character
		 */
		private char peekNext() {
<span class="nc" id="L317">			int nextIndex = index + 1;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (nextIndex &lt; string.length()) {</span>
<span class="nc" id="L319">				return string.charAt(nextIndex);</span>
			}
<span class="nc" id="L321">			return ' ';</span>
		}
	}
	
	/**
	 * A state for preventing the other states seeing special characters.
	 * {@link #parse()} simply inserts the next character to the output string
	 * using the current attributes and returns.
	 */
	private class QuoteState extends AbstractParserState {
		/**
		 * Create a new QuoteState.
		 * 
		 * @param sink AttributedTextSink for the use of adding
		 * 	processed output
		 * @param attributes text attributes for the state
		 * @param s raw format string
		 * @param index starting index for this parser instance
		 */
<span class="fc" id="L340">		QuoteState(AttributedTextSink&lt;T&gt; sink, T attributes, String s, int index) {</span>
<span class="fc" id="L341">			super(sink, attributes, s, index);</span>
<span class="fc" id="L342">		}</span>

		@Override
		int parse() {
			// Just pass through one character
<span class="fc" id="L347">			index++;</span>
<span class="fc" id="L348">			push();</span>
<span class="fc" id="L349">			return index;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>