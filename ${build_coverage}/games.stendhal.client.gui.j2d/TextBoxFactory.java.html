<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TextBoxFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui.j2d</a> &gt; <span class="el_source">TextBoxFactory.java</span></div><h1>TextBoxFactory.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui.j2d;

import games.stendhal.client.gui.TransparencyMode;
import games.stendhal.client.gui.textformat.AttributedStringBuilder;
import games.stendhal.client.gui.textformat.StringFormatter;
import games.stendhal.client.gui.textformat.TextAttributeSet;
import games.stendhal.client.sprite.ImageSprite;
import games.stendhal.client.sprite.Sprite;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import java.text.BreakIterator;
import java.text.CharacterIterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

/**
 * A helper class for painting speech bubbles and other
 * messages used on the screen.
 */
public class TextBoxFactory {
	/** Used for calculating the line metrics. */
<span class="fc" id="L48">	private static final Graphics graphics = (new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB)).getGraphics();</span>
	
	/** space to be left at the beginning and end of line in pixels. */
	private static final int MARGIN_WIDTH = 3;
	/** height of text lines in pixels. */
<span class="fc" id="L53">	private static final int LINE_HEIGHT = graphics.getFontMetrics().getHeight();</span>
	/** Font ascent. */
<span class="fc" id="L55">	private static final int LINE_ASCENT = graphics.getFontMetrics().getAscent();</span>
	/** space needed for the bubble &quot;handle&quot; in pixels. */
	private static final int BUBBLE_OFFSET = 10;
	/** the diameter of the arc of the rounded bubble corners. */
	private static final int ARC_DIAMETER = 2 * MARGIN_WIDTH + 2;
	/**
	 * The maximum number of lines to try to fit in a text box. It is not a
	 * hard limit, but can be exceeded by one in some situations.
	 */
	private static final int MAX_LINES = 6;
	private final StringFormatter&lt;Map&lt;TextAttribute, Object&gt;, TextAttributeSet&gt; formatter;
	
	/**
	 * Create a new TextBoxFactory.
	 */
<span class="fc" id="L70">	public TextBoxFactory() {</span>
<span class="fc" id="L71">		formatter = new StringFormatter&lt;Map&lt;TextAttribute, Object&gt;, TextAttributeSet&gt;();</span>

		// ** Formatting characters and their effects **
<span class="fc" id="L74">		TextAttributeSet set = new TextAttributeSet();</span>
<span class="fc" id="L75">		set.setAttribute(TextAttribute.FOREGROUND, Color.blue);</span>
<span class="fc" id="L76">		set.setAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);</span>
<span class="fc" id="L77">		formatter.addStyle('#', set);</span>
		
<span class="fc" id="L79">		set = new TextAttributeSet();</span>
<span class="fc" id="L80">		set.setAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);</span>
<span class="fc" id="L81">		formatter.addStyle('ยง', set);</span>
<span class="fc" id="L82">	}</span>
	
	/**
	 * Creates a text box sprite.
	 * 
	 * @param text the text inside the box
	 * @param width maximum width of the text in the box in pixels
	 * @param textColor color of the text
	 * @param fillColor background color
	 * @param isTalking true if the box should look like a chat bubble
	 * 
	 * @return sprite of the text box
	 */
	public Sprite createTextBox(final String text, final int width, final Color textColor,
			final Color fillColor, final boolean isTalking) {
<span class="fc" id="L97">		List&lt;AttributedCharacterIterator&gt; lines = createFormattedLines(text, textColor, width);</span>
		// Find the actual width of the text
<span class="fc" id="L99">		final int lineLengthPixels = getMaxPixelWidth(lines);</span>
<span class="fc" id="L100">		final int numLines = lines.size();</span>

<span class="fc" id="L102">		final GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();</span>
		final int imageWidth;
<span class="fc bfc" id="L104" title="All 2 branches covered.">		if (lineLengthPixels + BUBBLE_OFFSET &lt; width) {</span>
<span class="fc" id="L105">			imageWidth = (lineLengthPixels + BUBBLE_OFFSET) + ARC_DIAMETER;</span>
		} else {
<span class="fc" id="L107">			imageWidth = width + BUBBLE_OFFSET + ARC_DIAMETER;</span>
		}
		
<span class="fc" id="L110">		final int imageHeight = LINE_HEIGHT * numLines + 2 * MARGIN_WIDTH;</span>

<span class="fc" id="L112">		final BufferedImage image = gc.createCompatibleImage(imageWidth, imageHeight, TransparencyMode.TRANSPARENCY);</span>

<span class="fc" id="L114">		final Graphics2D g2d = image.createGraphics();</span>
<span class="fc" id="L115">		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
		// Background image
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">		if (fillColor != null) {</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">			if (isTalking) {</span>
<span class="nc" id="L119">				drawBubble(g2d, fillColor, textColor, imageWidth - BUBBLE_OFFSET, imageHeight);</span>
			} else {
<span class="fc" id="L121">				drawRectangle(g2d, fillColor, textColor, imageWidth - BUBBLE_OFFSET, imageHeight);</span>
			}
		}

		// Text
<span class="fc" id="L126">		drawTextLines(g2d, lines, textColor, MARGIN_WIDTH + BUBBLE_OFFSET, MARGIN_WIDTH);</span>
<span class="fc" id="L127">		g2d.dispose();</span>

<span class="fc" id="L129">		return new ImageSprite(image);</span>
	}

	/**
	 * Create a text box with an image background.
	 * 
	 * @param text the text inside the box
	 * @param textColor base color of the text
	 * @param width maximum width of the text in the box in pixels
	 * @param leftMargin margin from the left side of the background image to
	 * 	the drawn text 
	 * @param rightMargin margin from the right side of the background image to
	 * 	the drawn text
	 * @param topMargin margin from the top of the background image to the drawn
	 * 	text
	 * @param bottomMargin margin from the bottom of the background image to the
	 * 	drawn text
	 * @param background painter for the background
	 * 
	 * @return text box sprite
	 */
	public Sprite createFancyTextBox(final String text, final Color textColor, 
			final int width, final int leftMargin, final int rightMargin,
			final int topMargin, final int bottomMargin, 
			final BackgroundPainter background) {
<span class="nc" id="L154">		List&lt;AttributedCharacterIterator&gt; lines = createFormattedLines(text, textColor, width);</span>
		
<span class="nc" id="L156">		int imageWidth = getMaxPixelWidth(lines) + leftMargin + rightMargin;</span>
<span class="nc" id="L157">		final int imageHeight = LINE_HEIGHT * lines.size() + topMargin + bottomMargin;</span>

<span class="nc" id="L159">		final GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();</span>
<span class="nc" id="L160">		final BufferedImage image = gc.createCompatibleImage(imageWidth, imageHeight, TransparencyMode.TRANSPARENCY);</span>

<span class="nc" id="L162">		final Graphics2D g2d = image.createGraphics();</span>
<span class="nc" id="L163">		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>

		// Background image
<span class="nc" id="L166">		g2d.setComposite(AlphaComposite.Src);</span>
<span class="nc" id="L167">		background.paint(g2d, imageWidth, imageHeight);</span>
<span class="nc" id="L168">		g2d.setComposite(AlphaComposite.SrcOver);</span>

		// Text
<span class="nc" id="L171">		drawTextLines(g2d, lines, textColor, leftMargin, topMargin);</span>
<span class="nc" id="L172">		g2d.dispose();</span>

<span class="nc" id="L174">		return new ImageSprite(image);</span>
	}
	
	/**
	 * Create formatted lines from a text.
	 * 
	 * @param text text to be formatted and grouped to lines
	 * @param textColor base text color
	 * @param width maximum width of the text in pixels
	 * 
	 * @return formatted lines
	 */
	private List&lt;AttributedCharacterIterator&gt; createFormattedLines(String text,
			Color textColor, int width) {
		// Format before splitting to get the coloring right
<span class="fc" id="L189">		AttributedString formattedString = formatLine(text.trim(), textColor);</span>
		// split it to max width long pieces
<span class="fc" id="L191">		return splitFormatted(formattedString, width);</span>
	}
	
	 /**
	  * Draw a chat bubble.  
	  *
	  * @param g2d 
	  * @param fillColor the bacground color of the bubble 
	  * @param outLineColor the color of the bubble outline
	  * @param width width of the bubble body
	  * @param height height of the bubble
	  */
	private void drawBubble(final Graphics2D g2d, final Color fillColor, 
			final Color outLineColor, final int width, final int height) {
		/*
		 * There's an one pixel difference in how sun java and openjdk
		 * do drawRoundRect, so we use fillRoundRect for both the
		 * outline and the fill to have pretty bubbles on both
		 */
<span class="nc" id="L210">		g2d.setColor(outLineColor);</span>
<span class="nc" id="L211">		g2d.fillRoundRect(BUBBLE_OFFSET, 0, width, height, ARC_DIAMETER, ARC_DIAMETER);</span>
<span class="nc" id="L212">		g2d.setColor(fillColor);</span>
<span class="nc" id="L213">		g2d.fillRoundRect(BUBBLE_OFFSET + 1, 1, width - 2, height - 2, ARC_DIAMETER, ARC_DIAMETER);</span>
		
		// The bubble handle
<span class="nc" id="L216">		final Polygon p = new Polygon();</span>
<span class="nc" id="L217">		p.addPoint(BUBBLE_OFFSET + 1, MARGIN_WIDTH + 1);</span>
<span class="nc" id="L218">		p.addPoint(0, LINE_HEIGHT);</span>
<span class="nc" id="L219">		p.addPoint(BUBBLE_OFFSET + 1, LINE_HEIGHT / 2 + MARGIN_WIDTH);</span>
<span class="nc" id="L220">		g2d.fillPolygon(p);</span>
		
<span class="nc" id="L222">		g2d.setColor(outLineColor);</span>
<span class="nc" id="L223">		g2d.drawLine(0, LINE_HEIGHT, BUBBLE_OFFSET, MARGIN_WIDTH + 1);</span>
<span class="nc" id="L224">		g2d.drawLine(0, LINE_HEIGHT, BUBBLE_OFFSET, LINE_HEIGHT / 2 + MARGIN_WIDTH);</span>
<span class="nc" id="L225">	}</span>
	
	/**
	 * Draw an outlined rectangle.
	 * 
	 * @param g2d graphics
	 * @param fillColor The background color of the rectangle 
	 * @param outLineColor Color of the outline
	 * @param width Pixel width of the drawn rectangle
	 * @param height Pixel height of the drawn rectangle
	 */
	private void drawRectangle(final Graphics2D g2d, final Color fillColor, 
			final Color outLineColor, final int width, final int height) {
		// Using filled rectangles to work around a rendering 
		// incompatibility in openjdk.
<span class="fc" id="L240">		g2d.setColor(outLineColor);</span>
<span class="fc" id="L241">		g2d.fillRect(BUBBLE_OFFSET, 0, width, height);</span>
<span class="fc" id="L242">		g2d.setColor(fillColor);</span>
<span class="fc" id="L243">		g2d.fillRect(BUBBLE_OFFSET + 1, 1, width - 2, height - 2);</span>
<span class="fc" id="L244">	}</span>

	/**
	 * Color a string according to the formatting characters in it.
	 * 
	 * @param line string to be formatted
	 * @param normalColor base color used for the text
	 * @return colored sting
	 */
	private AttributedString formatLine(final String line, 
			final Color normalColor) {
		try {
<span class="fc" id="L256">			TextAttributeSet normal = new TextAttributeSet();</span>
<span class="fc" id="L257">			normal.setAttribute(TextAttribute.FOREGROUND, normalColor);</span>
			
<span class="fc" id="L259">			AttributedStringBuilder builder = new AttributedStringBuilder();</span>
<span class="fc" id="L260">			formatter.format(line, normal, builder);</span>
			
<span class="fc" id="L262">			return builder.toAttributedString();</span>
<span class="nc" id="L263">		} catch (final Exception e) {</span>
<span class="nc" id="L264">			Logger.getLogger(TextBoxFactory.class).error(e, e);</span>
<span class="nc" id="L265">			return null;</span>
		}
	}
	
	/**
	 * Splits a text to lines with specified maximum width, preserving the line breaks in the original.
	 * 
	 * @param text the text to be split
	 * @param width maximum line length in pixels
	 * 
	 * @return list of lines
	 */
	private List&lt;AttributedCharacterIterator&gt; splitFormatted(final AttributedString text, final int width) {
<span class="fc" id="L278">		final List&lt;AttributedCharacterIterator&gt; lines = new LinkedList&lt;AttributedCharacterIterator&gt;();</span>

<span class="fc" id="L280">		final BreakIterator iter = BreakIterator.getLineInstance();</span>
<span class="fc" id="L281">		iter.setText(text.getIterator());</span>
		
<span class="fc" id="L283">		int previous = iter.first();</span>
		
<span class="fc" id="L285">		AttributedCharacterIterator best = null;</span>
		
<span class="fc bfc" id="L287" title="All 2 branches covered.">		while (iter.next() != BreakIterator.DONE) {</span>
<span class="fc" id="L288">			final AttributedCharacterIterator candidate = text.getIterator(null, previous, iter.current());</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">			if (getPixelWidth(candidate) &lt;= width) {</span>
				// check for line breaks within the provided text
				// unfortunately, the BreakIterators are too dumb to tell *why* they consider the 
				// location a break, so the check needs to be implemented here
<span class="fc" id="L294">				final CharacterIterator cit = iter.getText();</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">				if (isHardLineBreak(cit)) {</span>
<span class="nc" id="L296">					lines.add(candidate);</span>
<span class="nc" id="L297">					previous = iter.current();</span>
<span class="nc" id="L298">					best = null;</span>
				} else {
<span class="fc" id="L300">					best = candidate;</span>
				}
<span class="fc" id="L302">			} else {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">				if (best == null) {</span>
					// could not break the line - the word's simply too long. Use more force to
					// to fit it to the width
<span class="fc" id="L306">					best = splitAggressively(candidate, width);</span>
					// splitAggressively returns an iterator with its own indexing,
					// so instead of using it directly we need to adjust the old one
<span class="fc" id="L309">					previous += best.getEndIndex() - best.getBeginIndex();</span>
				} else {
<span class="fc" id="L311">					previous = best.getEndIndex();</span>
					// Trim the trailing white space
<span class="fc" id="L313">					char endChar = best.last();</span>

<span class="fc" id="L315">					int endIndex = previous;</span>
<span class="pc bpc" id="L316" title="1 of 4 branches missed.">					while (Character.isWhitespace(endChar) &amp;&amp; endChar != CharacterIterator.DONE) {</span>
<span class="fc" id="L317">						endIndex = best.getIndex();</span>
<span class="fc" id="L318">						endChar = best.previous();</span>
					}

<span class="fc" id="L321">					best = text.getIterator(null, best.getBeginIndex(), endIndex);</span>
				}

<span class="fc" id="L324">				lines.add(best);</span>

				// a special check for a hard line break just after the word 
				// that got moved to the next line
<span class="fc" id="L328">				final CharacterIterator cit = iter.getText();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">				if (isHardLineBreak(cit)) {</span>
<span class="fc" id="L330">					lines.add(text.getIterator(null, previous, iter.current()));</span>
<span class="fc" id="L331">					previous = iter.current();</span>
				}
				
				// Pick the shortest candidate possible (backtrack a bit, if needed)
<span class="fc bfc" id="L335" title="All 2 branches covered.">				if (iter.current() &gt; previous + 1) {</span>
<span class="fc" id="L336">					iter.previous();</span>
				}

<span class="fc" id="L339">				best = null;</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">				if (lines.size() &gt; MAX_LINES) {</span>
					/*
					 * Limit the height of the text boxes. Append ellipsis
					 * to tell the user to take a look at the chat log.
					 * The last line is removed twice to avoid the situation
					 * where the last text line would fit on the space the
					 * ellipsis occupies.
					 */
<span class="fc" id="L349">					lines.remove(lines.size() - 1);</span>
<span class="fc" id="L350">					lines.remove(lines.size() - 1);</span>
<span class="fc" id="L351">					lines.add(new AttributedString(&quot;...&quot;).getIterator());</span>
<span class="fc" id="L352">					return lines;</span>
				}
			}
<span class="fc" id="L355">		}</span>

		// add the rest of the text, if there's any
<span class="fc bfc" id="L358" title="All 2 branches covered.">		if (previous &lt; iter.last()) {</span>
<span class="fc" id="L359">			lines.add(text.getIterator(null, previous, iter.last()));</span>
		}

<span class="fc" id="L362">		return lines;</span>
	}
	
	/**
	 * Try splitting a line considering anything that looks like a word break a
	 * valid line break point.
	 * (should we break just anywhere if even that fails? now we just return 
	 * the whole line)
	 *  
	 * @param text iterator to the line that should be split
	 * @param width the maximum allowed pixel width
	 * 
	 * @return iterator to the part of the line that fits in width
	 */
	private AttributedCharacterIterator splitAggressively(final AttributedCharacterIterator text, final int width) {
<span class="fc" id="L377">		final int offset = text.getBeginIndex();</span>
<span class="fc" id="L378">		final BreakIterator wordIterator = BreakIterator.getWordInstance();</span>
		
<span class="fc" id="L380">		final AttributedString tmpText = new AttributedString(text);</span>
		// return the original iterator if there are no suitable break points
<span class="fc" id="L382">		AttributedCharacterIterator best = text;</span>
<span class="fc" id="L383">		wordIterator.setText(text);</span>
		
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">		while (wordIterator.next() != BreakIterator.DONE) {</span>
<span class="fc" id="L386">			final AttributedCharacterIterator candidate = tmpText.getIterator(null, tmpText.getIterator().getBeginIndex(), wordIterator.current() - offset);</span>
			
<span class="fc bfc" id="L388" title="All 2 branches covered.">			if (getPixelWidth(candidate) &lt;= width) {</span>
<span class="fc" id="L389">				best = candidate;</span>
			} else {
<span class="fc" id="L391">				return best;</span>
			}
<span class="fc" id="L393">		}</span>
		
		// should never be reached, but java is trying to be too smart and does
		// not allow throwing exceptions here
<span class="nc" id="L397">		return best;</span>
	}

	/**
	 * Get the longest pixel width of a list of lines.
	 * 
	 * @param lines lines to be checked
	 * @return the longest pixel width of the checked lines
	 */
	private int getMaxPixelWidth(final List&lt;AttributedCharacterIterator&gt; lines) {
<span class="fc" id="L407">		int pixelWidth = 0;</span>

<span class="fc bfc" id="L409" title="All 2 branches covered.">		for (final AttributedCharacterIterator line : lines) {</span>
<span class="fc" id="L410">			final int width = getPixelWidth(line);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">			if (width &gt; pixelWidth) {</span>
<span class="fc" id="L412">				pixelWidth = width;</span>
			}
<span class="fc" id="L414">		}</span>
		
<span class="fc" id="L416">		return pixelWidth;</span>
	}
	
	/**
	 * Get the pixel width of a text line.
	 * 
	 * @param iter iterator representing the text line
	 * @return pixel width of the line
	 */
	private int getPixelWidth(final AttributedCharacterIterator iter) {
<span class="fc" id="L426">		return (int) graphics.getFontMetrics().getStringBounds(iter, iter.getBeginIndex(), iter.getEndIndex(), graphics).getWidth();</span>
	}
	
	/**
	 * Draw a list of text lines.
	 * 
	 * @param g2d graphics where the text should be drawn
	 * @param lines the text lines to be drawn
	 * @param textColor the base color of the text
	 * @param leftMargin left side margin
	 * @param topMargin top margin
	 */
	private void drawTextLines(final Graphics2D g2d, 
			final List&lt;AttributedCharacterIterator&gt; lines, final Color textColor, 
			int leftMargin, int topMargin) {
<span class="fc" id="L441">		int y = topMargin + LINE_ASCENT;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">		for (final AttributedCharacterIterator line : lines) {</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">			if (textColor == null) {</span>
<span class="nc" id="L444">				g2d.setColor(Color.black);</span>
			}
<span class="fc" id="L446">			g2d.setColor(textColor);</span>

<span class="fc" id="L448">			g2d.drawString(line, leftMargin, y);</span>
<span class="fc" id="L449">			y += LINE_HEIGHT;</span>
<span class="fc" id="L450">		}</span>
<span class="fc" id="L451">	}</span>
	
	/**
	 * Check if a location is at a hard line break.
	 * 
	 * @param cit iterator
	 * @return &lt;code&gt;true&lt;/code&gt; if there is a hard line break
	 */
	private boolean isHardLineBreak(final CharacterIterator cit) {
		// save the location while we are checking the preceding characters
<span class="fc" id="L461">		final int currentIndex = cit.getIndex();</span>
		
<span class="fc" id="L463">		char currentChar = cit.previous();</span>
<span class="pc bpc" id="L464" title="1 of 4 branches missed.">		while (currentChar != CharacterIterator.DONE &amp;&amp; !Character.isLetterOrDigit(currentChar)) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			if (currentChar == '\n') {</span>
<span class="fc" id="L466">				cit.setIndex(currentIndex);</span>
<span class="fc" id="L467">				return true;</span>
			}
<span class="fc" id="L469">			currentChar = cit.previous();</span>
		}
<span class="fc" id="L471">		cit.setIndex(currentIndex);</span>
		
<span class="fc" id="L473">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>