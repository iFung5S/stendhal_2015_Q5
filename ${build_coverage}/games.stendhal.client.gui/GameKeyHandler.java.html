<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GameKeyHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui</a> &gt; <span class="el_source">GameKeyHandler.java</span></div><h1>GameKeyHandler.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                   (C) Copyright 2003-2012 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui;

import static games.stendhal.common.constants.Actions.AUTOWALK;
import static games.stendhal.common.constants.Actions.DIR;
import static games.stendhal.common.constants.Actions.FACE;
import static games.stendhal.common.constants.Actions.MODE;
import static games.stendhal.common.constants.Actions.TYPE;
import static games.stendhal.common.constants.Actions.WALK;
import games.stendhal.client.GameScreen;
import games.stendhal.client.StendhalClient;
import games.stendhal.client.entity.IEntity;
import games.stendhal.client.entity.User;
import games.stendhal.client.gui.j2d.entity.EntityView;
import games.stendhal.common.Direction;
import games.stendhal.common.constants.Testing;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import marauroa.common.game.RPAction;

/**
 * Main window keyboard handling.
 */
class GameKeyHandler implements KeyListener {
	private final StendhalClient client;
	private final GameScreen screen;
<span class="nc" id="L39">	private long lastAction = 0;</span>

	/**
	 * Delayed direction release holder.
	 */
	private DelayedDirectionRelease directionRelease;

	/**
	 * Create a new GameKeyHandler.
	 * 
	 * @param client client to send direction commands
	 * @param screen screen where to direct game screen related commands
	 */
<span class="nc" id="L52">	GameKeyHandler(StendhalClient client, GameScreen screen) {</span>
<span class="nc" id="L53">		this.client = client;</span>
<span class="nc" id="L54">		this.screen = screen;</span>
<span class="nc" id="L55">	}</span>

	@Override
	public void keyPressed(final KeyEvent e) {
<span class="nc" id="L59">		final int keyCode = e.getKeyCode();</span>

		/* Ignore if the key is already pressed down. */
<span class="nc bnc" id="L62" title="All 2 branches missed.">		if (!client.keyIsPressed(keyCode)) {</span>
			/* Add keyCode to pressedStateKeys list. */
<span class="nc" id="L64">			client.onKeyPressed(keyCode);</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">			if (e.isShiftDown()) {</span>
				/*
				 * We are going to use shift to move to previous/next line of text
				 * with arrows so we just ignore the keys if shift is pressed.
				 */
<span class="nc" id="L71">				return;</span>
			}

<span class="nc bnc" id="L74" title="All 4 branches missed.">			switch (keyCode) {</span>
			case KeyEvent.VK_R:
<span class="nc bnc" id="L76" title="All 2 branches missed.">				if (e.isControlDown()) {</span>
					/*
					 * Ctrl+R Remove text bubbles
					 */
<span class="nc" id="L80">					screen.clearTexts();</span>
				}
				break;

			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
				/*
				 * Ctrl means face, otherwise move. Alt turns on auto-walk.
				 */
<span class="nc" id="L91">				final Direction direction = keyCodeToDirection(e.getKeyCode());</span>

				/* TODO: Remove MOTION condition when auto-walk testing is
				 * finished.
				 * 
				 * Check if the player is currently using auto-walk or the Alt
				 * key is pressed.
				 */
<span class="nc" id="L99">				User user = User.get();</span>
<span class="nc bnc" id="L100" title="All 6 branches missed.">				if ((user.getRPObject().has(AUTOWALK) || e.isAltDown())</span>
						&amp;&amp; Testing.MOVEMENT) {
					/* Face direction pressed and toggle auto-walk. */
<span class="nc" id="L103">					this.processAutoWalk(direction, user);</span>
				} else {
<span class="nc bnc" id="L105" title="All 2 branches missed.">					if (e.isAltGraphDown()) {</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">						if (System.currentTimeMillis() - lastAction &gt; 1000) {</span>
<span class="nc" id="L107">							final EntityView&lt;?&gt; view = screen.getEntityViewAt(</span>
									user.getX()
											+ direction.getdx(), user.getY()
											+ direction.getdy());

<span class="nc bnc" id="L112" title="All 2 branches missed.">							if (view != null) {</span>
<span class="nc" id="L113">								final IEntity entity = view.getEntity();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">								if (!entity.equals(user)) {</span>
<span class="nc" id="L115">									view.onAction();</span>
<span class="nc" id="L116">									lastAction = System.currentTimeMillis();</span>
								}
							}
						}
					}

<span class="nc" id="L122">					this.processDirectionPress(direction, e.isControlDown());</span>
				}
<span class="nc" id="L124">				break;</span>
			case KeyEvent.VK_0:
			case KeyEvent.VK_1:
			case KeyEvent.VK_2:
			case KeyEvent.VK_3:
			case KeyEvent.VK_4:
			case KeyEvent.VK_5:
			case KeyEvent.VK_6:
			case KeyEvent.VK_7:
			case KeyEvent.VK_8:
			case KeyEvent.VK_9:
<span class="nc" id="L135">				switchToSpellCastingState(e);</span>
				break;
			}
		}
<span class="nc" id="L139">	}</span>

	@Override
	public void keyReleased(final KeyEvent e) {
<span class="nc" id="L143">		final int keyCode = e.getKeyCode();</span>

		/* Ignore if the key is not found in the pressedStateKeys list. */
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (client.keyIsPressed(keyCode)) {</span>
			/* Remove keyCode from pressedStateKeys list. */
<span class="nc" id="L148">			client.onKeyReleased(keyCode);</span>

<span class="nc bnc" id="L150" title="All 2 branches missed.">			switch (keyCode) {</span>
			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
				/*
				 * Ctrl means face, otherwise move
				 */
<span class="nc" id="L158">				processDirectionRelease(keyCodeToDirection(e.getKeyCode()),</span>
						e.isControlDown());
			}
		}
<span class="nc" id="L162">	}</span>

	@Override
	public void keyTyped(final KeyEvent e) {
		// Ignore. All the work is done in keyPressed and keyReleased methods.
<span class="nc" id="L167">	}</span>

	/**
	 * Process delayed direction release.
	 */
	synchronized void processDelayedDirectionRelease() {
<span class="nc bnc" id="L173" title="All 4 branches missed.">		if ((directionRelease != null) &amp;&amp; directionRelease.hasExpired()) {</span>
<span class="nc" id="L174">			client.removeDirection(directionRelease.getDirection(),</span>
					directionRelease.isFacing());

<span class="nc" id="L177">			directionRelease = null;</span>
		}
<span class="nc" id="L179">	}</span>

	/**
	 * Convert a keycode to the corresponding direction.
	 * 
	 * @param keyCode The keycode.
	 * 
	 * @return The direction, or &lt;code&gt;null&lt;/code&gt;.
	 */
	private Direction keyCodeToDirection(final int keyCode) {
<span class="nc bnc" id="L189" title="All 5 branches missed.">		switch (keyCode) {</span>
		case KeyEvent.VK_LEFT:
<span class="nc" id="L191">			return Direction.LEFT;</span>

		case KeyEvent.VK_RIGHT:
<span class="nc" id="L194">			return Direction.RIGHT;</span>

		case KeyEvent.VK_UP:
<span class="nc" id="L197">			return Direction.UP;</span>

		case KeyEvent.VK_DOWN:
<span class="nc" id="L200">			return Direction.DOWN;</span>

		default:
<span class="nc" id="L203">			return null;</span>
		}
	}

	/**
	 * Handle direction press actions.
	 * 
	 * @param direction The direction.
	 * @param facing If facing only.
	 */
	private synchronized void processDirectionPress(final Direction direction,
			final boolean facing) {
<span class="nc bnc" id="L215" title="All 2 branches missed.">		if (directionRelease != null) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">			if (directionRelease.check(direction, facing)) {</span>
<span class="nc" id="L217">				directionRelease = null;</span>
<span class="nc" id="L218">				return;</span>
			} else {
				/*
				 * Flush pending release
				 */
<span class="nc" id="L223">				client.removeDirection(directionRelease.getDirection(),</span>
						directionRelease.isFacing());

<span class="nc" id="L226">				directionRelease = null;</span>
			}
		}

<span class="nc bnc" id="L230" title="All 2 branches missed.">		if (client.addDirection(direction, facing)) {</span>
    		// Movement prediction.
<span class="nc" id="L232">    		User user = User.get();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">    		if (user != null) {</span>
<span class="nc" id="L234">    			user.predictMovement(direction, facing);</span>
    		}
		}
<span class="nc" id="L237">	}</span>

	/**
	 * Handle direction press to invoke or disable auto-walk.
	 * 
	 * @param direction
	 *        The direction to move/face
	 * @param user
	 *        The entity to set/check
	 */
	private synchronized void processAutoWalk(final Direction direction,
			final User user) {
<span class="nc" id="L249">		RPAction walkAction = new RPAction();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">		final boolean facing = direction == user.getDirection();</span>

		/* Correct facing direction if necessary. */
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (!facing) {</span>
<span class="nc" id="L254">			RPAction faceAction = new RPAction();</span>
<span class="nc" id="L255">			faceAction.put(TYPE, FACE);</span>
<span class="nc" id="L256">			faceAction.put(DIR, direction.get());</span>
<span class="nc" id="L257">			this.client.send(faceAction);</span>
		}

		/* Check if player is already using auto-walk. */
<span class="nc bnc" id="L261" title="All 2 branches missed.">		if (!user.getRPObject().has(AUTOWALK)) {</span>
<span class="nc" id="L262">			walkAction.put(TYPE, WALK);</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">		} else if (facing) {</span>
			/* Player can press key of current walking direction to toggle
			 * auto-walk off.
			 */
<span class="nc" id="L268">			walkAction.put(TYPE, WALK);</span>
<span class="nc" id="L269">			walkAction.put(MODE, &quot;stop&quot;);</span>
		}

		/* Send auto-walk action to the server. */
<span class="nc bnc" id="L273" title="All 2 branches missed.">		if (walkAction.has(TYPE)) {</span>
			/* Toggle auto-walk. */
<span class="nc" id="L275">			this.client.send(walkAction);</span>
		}
<span class="nc" id="L277">	}</span>

	/**
	 * Handle direction release actions.
	 * 
	 * @param direction The direction.
	 * @param facing If facing only.
	 */
	private synchronized void processDirectionRelease(final Direction direction,
			final boolean facing) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">		if (directionRelease != null) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">			if (directionRelease.check(direction, facing)) {</span>
				/*
				 * Ignore repeats
				 */
<span class="nc" id="L292">				return;</span>
			} else {
				/*
				 * Flush previous release
				 */
<span class="nc" id="L297">				client.removeDirection(directionRelease.getDirection(),</span>
						directionRelease.isFacing());
			}
		}

<span class="nc" id="L302">		directionRelease = new DelayedDirectionRelease(direction, facing);</span>
<span class="nc" id="L303">	}</span>

	/**
	 * Switch the screen to spell casting state.
	 * 
	 * @param e
	 */
	private void switchToSpellCastingState(KeyEvent e) {
<span class="nc" id="L311">		screen.switchToSpellCasting(e);</span>
<span class="nc" id="L312">	}</span>
	
	private static class DelayedDirectionRelease {
		/**
		 * The maximum delay between auto-repeat release-press.
		 */
		protected static final long DELAY = 50L;

		protected long expiration;

		protected Direction dir;

		protected boolean facing;

<span class="nc" id="L326">		public DelayedDirectionRelease(final Direction dir, final boolean facing) {</span>
<span class="nc" id="L327">			this.dir = dir;</span>
<span class="nc" id="L328">			this.facing = facing;</span>

<span class="nc" id="L330">			expiration = System.currentTimeMillis() + DELAY;</span>
<span class="nc" id="L331">		}</span>

		/**
		 * Check if a new direction matches the existing one, and if so, reset
		 * the expiration point.
		 * 
		 * @param dir The direction.
		 * @param facing The facing flag.
		 * 
		 * @return &lt;code&gt;true&lt;/code&gt; if this is a repeat.
		 */
		public boolean check(final Direction dir, final boolean facing) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">			if (this.dir != dir) {</span>
<span class="nc" id="L344">				return false;</span>
			}

<span class="nc bnc" id="L347" title="All 2 branches missed.">			if (this.facing != facing) {</span>
<span class="nc" id="L348">				return false;</span>
			}

<span class="nc" id="L351">			final long now = System.currentTimeMillis();</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">			if (now &gt;= expiration) {</span>
<span class="nc" id="L354">				return false;</span>
			}

<span class="nc" id="L357">			expiration = now + DELAY;</span>

<span class="nc" id="L359">			return true;</span>
		}

		/**
		 * Get the direction.
		 * 
		 * @return The direction.
		 */
		public Direction getDirection() {
<span class="nc" id="L368">			return dir;</span>
		}

		/**
		 * Determine if the delay point has been reached.
		 * 
		 * @return &lt;code&gt;true&lt;/code&gt; if the delay time has been reached.
		 */
		public boolean hasExpired() {
<span class="nc bnc" id="L377" title="All 2 branches missed.">			return System.currentTimeMillis() &gt;= expiration;</span>
		}

		/**
		 * Determine if the facing only option was used.
		 * 
		 * @return &lt;code&gt;true&lt;/code&gt; if facing only.
		 */
		public boolean isFacing() {
<span class="nc" id="L386">			return facing;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>