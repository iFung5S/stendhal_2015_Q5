<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InternalManagedWindow.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui</a> &gt; <span class="el_source">InternalManagedWindow.java</span></div><h1>InternalManagedWindow.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui;

import games.stendhal.client.gui.styled.cursor.CursorRepository;
import games.stendhal.client.gui.styled.cursor.StendhalCursor;
import games.stendhal.client.gui.wt.core.WtWindowManager;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JLayeredPane;
import javax.swing.SwingUtilities;

/**
 * An InternalWindow that implements ManagedWindow. Intended for the various
 * on screen windows.
 */
public class InternalManagedWindow extends InternalWindow implements ManagedWindow {
	/**
	 * serial version uid
	 */
	private static final long serialVersionUID = -3389618500246332016L;

<span class="nc" id="L43">	private static CursorRepository cursorRepository = new CursorRepository();</span>
	/** Window draw listeners. */
<span class="nc" id="L45">	private final List&lt;WindowDragListener&gt; dragListeners = new ArrayList&lt;WindowDragListener&gt;(1);</span>
	
	private Point dragStart; 
<span class="nc" id="L48">	private boolean movable = true;</span>

	/**
	 * Create an InternalManagedWindow.
	 * 
	 * @param handle identifier for the window manager
	 * @param title window title
	 */
	public InternalManagedWindow(String handle, String title) {
<span class="nc" id="L57">		super(title);</span>
		/*
		 * Abusing AWT methods to pass information to WtWindowManager. The
		 * method is practically undocumented and seems to exist for storing
		 * identifiers to the components (ie. exactly what we need the name
		 * for). Anyway, it does not seem to break anything and doing this
		 * otherwise would require breaking WtWindowManager interface. 
		 */
<span class="nc" id="L65">		setName(handle);</span>
		/*
		 * Do not steal the keyboard focus. Users may be confused how
		 * to get it back. 
		 */
<span class="nc" id="L70">		setFocusable(false);</span>
		
		// Listeners for moving the window
<span class="nc" id="L73">		ClickListener clickListener = new ClickListener();</span>
<span class="nc" id="L74">		DragListener dragListener = new DragListener();</span>
		
<span class="nc" id="L76">		getTitlebar().addMouseListener(clickListener);</span>
<span class="nc" id="L77">		getTitlebar().addMouseMotionListener(dragListener);</span>
		/*
		 * Add the movement start listener to the whole window as well. This
		 * provides a convenience access for moving or raising the window. Note
		 * that even if it's decided that the behavior is annoying, it's
		 * necessary to add some MouseListener (a dummy one, if so wanted)
		 * to the window itself. Otherwise the click is passed to the game area
		 * below, which is almost certainly not what the player wants. 
		 */
<span class="nc" id="L86">		addMouseListener(clickListener);</span>
<span class="nc" id="L87">		addMouseMotionListener(dragListener);</span>
		
<span class="nc" id="L89">		setCursor(cursorRepository.get(StendhalCursor.NORMAL));</span>
<span class="nc" id="L90">	}</span>

	@Override
	public boolean moveTo(int x, int y) {
<span class="nc" id="L94">		setLocation(x, y);</span>
<span class="nc" id="L95">		return true;</span>
	}
	
	@Override
	public void setMinimized(boolean minimized) {
<span class="nc" id="L100">		super.setMinimized(minimized);</span>
		/*
		 * We are handling our own size management, so so we need to take care
		 * of the new bounds. 
		 */
<span class="nc" id="L105">		setSize(getPreferredSize());</span>
<span class="nc" id="L106">		relocate(getLocation());</span>
<span class="nc" id="L107">		WtWindowManager.getInstance().setMinimized(this, minimized);</span>
<span class="nc" id="L108">	}</span>
	
	@Override
	public void addNotify() {
<span class="nc" id="L112">		super.addNotify();</span>
		/*
		 * Getting the remembered window formatting is not safe until all the
		 * components are in place. Also the window needs to be capable of
		 * setting its location (if on GameScreen)
		 */
<span class="nc" id="L118">		WtWindowManager.getInstance().formatWindow(this);</span>
<span class="nc" id="L119">	}</span>
	
	/**
	 * Raise the window if possible-
	 */
	void raise() {
<span class="nc" id="L125">		final Container parent = getParent();</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (parent instanceof JLayeredPane) {</span>
<span class="nc" id="L128">			((JLayeredPane) parent).moveToFront(InternalManagedWindow.this);</span>
		}
<span class="nc" id="L130">	}</span>
	
	/**
	 * Make the window movable or unmovable by the user. Even unmovable users
	 * obey window locations from the window manager.
	 * 
	 * @param movable
	 */
	public void setMovable(boolean movable) {
<span class="nc" id="L139">		this.movable = movable;</span>
<span class="nc" id="L140">	}</span>
	
	/**
	 * Center the window within the parent component.
	 */
	protected void center() {
<span class="nc" id="L146">		Container parent = getParent();</span>
<span class="nc" id="L147">		final Dimension size = getPreferredSize();</span>
		
<span class="nc" id="L149">		setBounds((parent.getWidth() - size.width) / 2,</span>
				(parent.getHeight() - size.height) / 2, size.width, size.height);
<span class="nc" id="L151">	}</span>
	
	
	/**
	 * Set the location of the window so that it keeps itself within the bounds
	 * of the parent.
	 * 
	 * @param point suggested location. The actual location can differ if the
	 * 	window would not fit fully within the parent
	 */
	private void relocate(Point point) {
<span class="nc" id="L162">		Container parent = getParent();</span>
		
		// Defensive copy to avoid modifying the raw coordinates. They're needed
		// by the caller.
<span class="nc" id="L166">		point = new Point(point);</span>
<span class="nc" id="L167">		Insets insets = parent.getInsets();</span>
		// Keep inside parent component
<span class="nc" id="L169">		point.x = Math.min(point.x, parent.getWidth() - getWidth() - insets.right);</span>
<span class="nc" id="L170">		point.x = Math.max(point.x, insets.left);</span>

<span class="nc" id="L172">		point.y = Math.min(point.y, parent.getHeight() - getHeight() - insets.bottom);</span>
<span class="nc" id="L173">		point.y = Math.max(point.y, insets.top);</span>

<span class="nc" id="L175">		setLocation(point);</span>
		// Store the window location
<span class="nc" id="L177">		WtWindowManager.getInstance().moveTo(this, getX(), getY());</span>
<span class="nc" id="L178">	}</span>
	
	/**
	 * Start dragging the window.
	 * 
	 * @param point starting point
	 */
	private void startDrag(Point point) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">		if (movable) {</span>
<span class="nc" id="L187">			dragStart = point;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			for (WindowDragListener listener : dragListeners) {</span>
<span class="nc" id="L189">				listener.startDrag(this);</span>
<span class="nc" id="L190">			}</span>
		}
<span class="nc" id="L192">	}</span>
	
	/**
	 * End dragging the window.
	 */
	private void endDrag() {
<span class="nc" id="L198">		dragStart = null;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">		for (WindowDragListener listener : dragListeners) {</span>
<span class="nc" id="L200">			listener.endDrag(this);</span>
<span class="nc" id="L201">		}</span>
<span class="nc" id="L202">	}</span>
	
	/**
	 * Drag the window.
	 * 
	 * @param point mouse location
	 */
	private void drag(Point point) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (dragStart != null) {</span>
<span class="nc" id="L211">			Component parent = getParent();</span>

			// calculate the total moved distance
<span class="nc" id="L214">			point = SwingUtilities.convertPoint(this, point, parent);</span>
<span class="nc" id="L215">			point.x -= dragStart.x;</span>
<span class="nc" id="L216">			point.y -= dragStart.y;</span>

<span class="nc" id="L218">			relocate(point);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">			for (WindowDragListener listener : dragListeners) {</span>
<span class="nc" id="L220">				listener.windowDragged(this, point);</span>
<span class="nc" id="L221">			}</span>
		}
<span class="nc" id="L223">	}</span>
	
	/**
	 * Listener for the title bar clicks.
	 */
<span class="nc" id="L228">	private class ClickListener extends MouseAdapter {</span>
		@Override
		public void mousePressed(final MouseEvent ev) {
<span class="nc bnc" id="L231" title="All 2 branches missed.">			if (ev.getButton() == MouseEvent.BUTTON1) {</span>
<span class="nc" id="L232">				startDrag(ev.getPoint());</span>
			}	
<span class="nc" id="L234">		}</span>
		
		@Override
		public void mouseReleased(final MouseEvent ev) {
			// Only call endDrag() if there was actually an active drag
<span class="nc bnc" id="L239" title="All 4 branches missed.">			if ((ev.getButton() == MouseEvent.BUTTON1) &amp;&amp; (dragStart != null)) {</span>
<span class="nc" id="L240">				endDrag();</span>
			}
<span class="nc" id="L242">		}</span>
		
		@Override
		public void mouseClicked(final MouseEvent ev) {
<span class="nc bnc" id="L246" title="All 2 branches missed.">			if (ev.getButton() == MouseEvent.BUTTON1) {</span>
				/*
				 * Raise the window if possible.
				 */
<span class="nc" id="L250">				raise();</span>
			}
<span class="nc" id="L252">		}</span>
	}
	
	/**
	 * Listened for title bar dragging.
	 */
<span class="nc" id="L258">	private class DragListener extends MouseMotionAdapter {</span>
		@Override
		public void mouseDragged(final MouseEvent ev) {
<span class="nc" id="L261">			drag(ev.getPoint());</span>
<span class="nc" id="L262">		}</span>
	}

	/**
	 * Add a window drag listener. Added listeners will be notified if this
	 * window is dragged by the user.
	 * 
	 * @param listener added listener
	 */
	public void addWindowDragListener(WindowDragListener listener) {
<span class="nc" id="L272">		dragListeners.add(listener);</span>
<span class="nc" id="L273">	}</span>
	
	/**
	 * Interface for listening to dragging the window by mouse.
	 */
	public interface WindowDragListener {
		/**
		 * Called when the user initiates a window drag.
		 * 
		 * @param component dragged component
		 */
		void startDrag(Component component);
		/**
		 * Called when the user ends a window drag.
		 * 
		 * @param component dragged component
		 */
		void endDrag(Component component);
		/**
		 * Called when the user drags a window.
		 * 
		 * @param component dragged component
		 * @param point the location of the drag. This is not necessarily the
		 * 	new coordinates of the window.
		 */
		void windowDragged(Component component, Point point);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>