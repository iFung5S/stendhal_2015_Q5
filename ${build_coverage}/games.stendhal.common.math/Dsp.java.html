<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Dsp.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.common.math</a> &gt; <span class="el_source">Dsp.java</span></div><h1>Dsp.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.common.math;

import games.stendhal.common.memory.Field;

/**
 * Signal processing algorithms.
 * 
 * @author silvio
 */
<span class="pc bpc" id="L22" title="2 of 4 branches missed.">public class Dsp {</span>
	public static byte[] convertUniformPCM(byte[] pcmBuffer, float[] samples, int numSamples, int numBytesPerSample) {
<span class="fc" id="L24">		int numBitsPerSample = numBytesPerSample * 8;</span>
<span class="fc" id="L25">		long maxValue = (long) ((Math.pow(2, numBitsPerSample) - 1.0) / 2.0);</span>

<span class="fc" id="L27">		pcmBuffer = Field.expand(pcmBuffer, (numBytesPerSample * numSamples),</span>
				false);

<span class="fc bfc" id="L30" title="All 4 branches covered.">		for (int i = 0; i &lt; numSamples; ++i) {</span>
<span class="fc" id="L31">			long value = (long) (samples[i] * maxValue);</span>
<span class="fc" id="L32">			int index = i * numBytesPerSample;</span>

<span class="pc bpc" id="L34" title="2 of 4 branches missed.">			value = (value &gt; maxValue) ? (maxValue) : (value);</span>
<span class="pc bpc" id="L35" title="2 of 4 branches missed.">			value = (value &lt; -maxValue) ? (-maxValue) : (value);</span>

<span class="fc bfc" id="L37" title="All 4 branches covered.">			for (int n = 0; n &lt; numBytesPerSample; ++n)</span>
<span class="fc" id="L38">				pcmBuffer[index + n] = (byte) (value &gt;&gt;&gt; (n * 8));</span>
		}

<span class="fc" id="L41">		return pcmBuffer;</span>
	}

	public static void mixAudioData(float[] result, int rOffset, float[] samples, int sOffset, int numSamples, float intensity) {
<span class="nc" id="L45">		int rEnd = rOffset + numSamples;</span>

<span class="nc bnc" id="L47" title="All 4 branches missed.">		while (rOffset &lt; rEnd) {</span>
<span class="nc" id="L48">			float A = result[rOffset];</span>
<span class="nc" id="L49">			float B = samples[sOffset] * intensity;</span>

<span class="nc" id="L51">			result[rOffset] = A + B - A * B;</span>

<span class="nc" id="L53">			++rOffset;</span>
<span class="nc" id="L54">			++sOffset;</span>
<span class="nc" id="L55">		}</span>
		/*
        for(int i=0; i&lt;numSamples; ++i)
        {
            float A = result[rOffset + i];
            float B = samples[sOffset + i];

            result[rOffset + i] = A + B - A * B;
        }//*/
<span class="nc" id="L64">	}</span>

	public static void blendAudioData(float[] result, int rOffset,
			float[] samples, int sOffset, int numSamples, float intensity) {
<span class="nc" id="L68">		int rEnd = rOffset + numSamples;</span>

<span class="nc bnc" id="L70" title="All 4 branches missed.">		while (rOffset &lt; rEnd) {</span>
<span class="nc" id="L71">			float A = result[rOffset];</span>
<span class="nc" id="L72">			float B = samples[sOffset];</span>

<span class="nc" id="L74">			result[rOffset] = A + (B - A) * intensity;</span>

<span class="nc" id="L76">			++rOffset;</span>
<span class="nc" id="L77">			++sOffset;</span>
<span class="nc" id="L78">		}</span>
<span class="nc" id="L79">	}</span>

	public static float[] convertChannels(float[] samples, int numFrames,
			int numChannels, int numRequiredChannels) {
        /* Assignments for audio channels
         * channel 0: Front left
         * channel 1: Front right
         * channel 2: Center
         * channel 3: Low frequency (subwoofer)
         * channel 4: Surround left       - ## NEEDS CONFIRMATION ##
         * channel 5: Surround right      - ## NEEDS CONFIRMATION ##
         * channel 6: Surround back left  - ## NEEDS CONFIRMATION ##
         * channel 7: Surround back right - ## NEEDS CONFIRMATION ##
         */

<span class="nc bnc" id="L94" title="All 4 branches missed.">		if (numChannels == numRequiredChannels)</span>
<span class="nc" id="L95">			return samples;</span>

		// we have to reduce the number of channels
<span class="nc bnc" id="L98" title="All 4 branches missed.">		if (numChannels &gt; numRequiredChannels) {</span>
			// stereo/multichannel to mono - maybe this won't work properly for
			// more than 2 channels
			// - ## NEEDS CONFIRMATION ##
<span class="nc bnc" id="L102" title="All 4 branches missed.">			if (numRequiredChannels == 1) {</span>
<span class="nc bnc" id="L103" title="All 4 branches missed.">				for (int i = 0; i &lt; numFrames; ++i) {</span>
<span class="nc" id="L104">					int index = i * numChannels;</span>
<span class="nc" id="L105">					float value = 0.0f;</span>

<span class="nc bnc" id="L107" title="All 4 branches missed.">					for (int c = 0; c &lt; numChannels; ++c)</span>
<span class="nc" id="L108">						value += samples[index + c];</span>

<span class="nc" id="L110">					samples[i] = value / numChannels;</span>
				}
			} else {
				// not implemented yet
<span class="nc" id="L114">				samples = null;</span>
			}
		} else // we have to increase the number of channels
		{
			// mono to stereo/multichannel
<span class="nc bnc" id="L119" title="All 4 branches missed.">			if (numChannels == 1) {</span>
<span class="nc" id="L120">				float[] newUniformPCM = new float[numFrames</span>
						* numRequiredChannels];

<span class="nc bnc" id="L123" title="All 4 branches missed.">				for (int i = 0; i &lt; numFrames; ++i) {</span>
<span class="nc" id="L124">					int index = i * numRequiredChannels;</span>

<span class="nc bnc" id="L126" title="All 4 branches missed.">					for (int c = 0; c &lt; numRequiredChannels; ++c)</span>
<span class="nc" id="L127">						newUniformPCM[index + c] = samples[i];</span>
				}

<span class="nc" id="L130">				samples = newUniformPCM;</span>
<span class="nc" id="L131">			} else { // stereo/multichannel to multichannel</span>
                /* Stereo widening (from Wikipedia):
                 * Widening of the stereo image can be achieved by manipulating the
                 * relationship of the side signal S and the center signal C
                 * C = (L + R) / 2; S = (L - R) / 2
                 * A positive part of the side signal S is now fed into the left channel
                 * and a part with its phase inverted to the right channel.
                 */

				// not yet implemented
<span class="nc" id="L141">				samples = null;</span>
			}
		}

<span class="nc" id="L145">		return samples;</span>
	}

	/**
	 * Convert the sample rate of a multi channel PCM signal.
	 * 
	 * @param samples
	 * @param numFrames
	 * @param numChannels
	 * @param sampleRate
	 * @param targetSampleRate
	 * @return converted sample rate
	 */
	public static float[] convertSampleRate(float[] samples, int numFrames,
			int numChannels, int sampleRate, int targetSampleRate) {
<span class="pc bpc" id="L160" title="6 of 8 branches missed.">		assert samples.length &gt;= numFrames * numChannels;</span>
<span class="pc bpc" id="L161" title="6 of 8 branches missed.">		assert numChannels &gt; 0;</span>
<span class="pc bpc" id="L162" title="6 of 8 branches missed.">		assert sampleRate &gt; 0;</span>
<span class="pc bpc" id="L163" title="6 of 8 branches missed.">		assert targetSampleRate &gt; 0;</span>

		float[] buffer;

<span class="fc bfc" id="L167" title="All 4 branches covered.">		if (sampleRate == targetSampleRate) {</span>
<span class="fc" id="L168">			buffer = samples;</span>
		} else {
<span class="fc" id="L170">			double conversion = (double) sampleRate / targetSampleRate;</span>
<span class="fc" id="L171">			int newFrames = (int) (numFrames / conversion);</span>
<span class="fc" id="L172">			int newNumSamples = newFrames * numChannels;</span>

<span class="fc" id="L174">			buffer = new float[newNumSamples];</span>

<span class="fc" id="L176">			int idx = 0;</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">			for (int f = 0; f &lt; newFrames; ++f) {</span>
<span class="fc" id="L178">				int sourceFrame = (int) (f * conversion);</span>

<span class="fc bfc" id="L180" title="All 4 branches covered.">				for (int c = 0; c &lt; numChannels; ++c) {</span>
<span class="fc" id="L181">					buffer[idx++] = samples[sourceFrame * numChannels + c];</span>
				}
			}
<span class="pc bpc" id="L184" title="6 of 8 branches missed.">			assert idx == newNumSamples;</span>
		}

<span class="fc" id="L187">		return buffer;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>