<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GameObjects.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client</a> &gt; <span class="el_source">GameObjects.java</span></div><h1>GameObjects.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                      (C) Copyright 2003 - Marauroa                      *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client;

import games.stendhal.client.entity.Entity;
import games.stendhal.client.entity.IEntity;
import games.stendhal.client.entity.NPC;
import games.stendhal.client.entity.Player;
import games.stendhal.client.entity.factory.EntityFactory;
import games.stendhal.client.events.EventDispatcher;
import games.stendhal.client.listener.RPObjectChangeListener;

import java.awt.geom.Rectangle2D;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;

import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;

import org.apache.log4j.Logger;

/**
 * stores the objects that exists on the World right now.
 * 
 */
public class GameObjects implements RPObjectChangeListener, Iterable&lt;IEntity&gt; {

	/** the logger instance. */
<span class="fc" id="L44">	private static final Logger logger = Logger.getLogger(GameObjects.class);</span>

	private final Map&lt;FQID, IEntity&gt; objects;

	private final StaticGameLayers collisionMap;

	/**
	 * holds the reference to the singleton instance.
	 */
	private static GameObjects instance;
	
	/**
	 * Objects to be notified about added and removed top level entities. The
	 * list is modified rarely, so it uses copy-on-write for thread safety.
	 */
<span class="fc" id="L59">	private final List&lt;GameObjectListener&gt; gameObjectListeners = new CopyOnWriteArrayList&lt;GameObjectListener&gt;(); </span>

	/**
	 * @param collisionMap
	 *            =layers that make floor and building
	 * @return singleton instance of GameOjects
	 */
	public static GameObjects createInstance(final StaticGameLayers collisionMap) {
<span class="fc" id="L67">		synchronized(GameObjects.class) {</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">			if (instance == null) {</span>
<span class="fc" id="L69">				instance = new GameObjects(collisionMap);</span>
			}
<span class="pc" id="L71">		}</span>
<span class="fc" id="L72">		return instance;</span>
	}

	/**
	 * @return existing instance of GameObjects
	 */
	public static GameObjects getInstance() {
<span class="nc bnc" id="L79" title="All 2 branches missed.">		if (instance == null) {</span>
<span class="nc" id="L80">			throw new IllegalStateException(</span>
					&quot;GameObject has not been initialized&quot;);
		}

<span class="nc" id="L84">		return instance;</span>
	}
	
	/**
	 * Add a new game GameObjectListener.
	 * 
	 * @param listener
	 */
	public void addGameObjectListener(GameObjectListener listener) {
<span class="nc" id="L93">		gameObjectListeners.add(listener);</span>
<span class="nc" id="L94">	}</span>
	
	/**
	 * Remove a GameObjectListener.
	 * 
	 * @param listener
	 */
	public void removeGameObjectListener(GameObjectListener listener) {
<span class="nc" id="L102">		gameObjectListeners.remove(listener);</span>
<span class="nc" id="L103">	}</span>

	/**
	 * constructor.
	 * 
	 * @param collisionMap
	 *            =layers that make floor and building
	 */
<span class="fc" id="L111">	private GameObjects(final StaticGameLayers collisionMap) {</span>
<span class="fc" id="L112">		objects = new HashMap&lt;FQID, IEntity&gt;();</span>

<span class="fc" id="L114">		this.collisionMap = collisionMap;</span>
<span class="fc" id="L115">	}</span>

	@Override
	public Iterator&lt;IEntity&gt; iterator() {
<span class="nc" id="L119">		return objects.values().iterator();</span>
	}

	public IEntity get(final RPObject object) {
<span class="nc" id="L123">		return objects.get(FQID.create(object));</span>
	}

	public IEntity get(final RPObject.ID id) {
<span class="nc" id="L127">		return objects.get(new FQID(id));</span>
	}

	/**
	 * Removes all the object entities.
	 */
	void clear() {
<span class="nc bnc" id="L134" title="All 2 branches missed.">		if (!objects.isEmpty()) {</span>
<span class="nc" id="L135">			logger.debug(&quot;Game objects not empty!&quot;);</span>

			// invalidate all entity objects
<span class="nc" id="L138">			final Iterator&lt;IEntity&gt; it = iterator();</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L141">				final IEntity entity = it.next();</span>
<span class="nc" id="L142">				logger.debug(&quot;Residual entity: &quot; + entity);</span>
<span class="nc" id="L143">				entity.release();</span>
<span class="nc" id="L144">			}</span>

<span class="nc" id="L146">			objects.clear();</span>
		}
<span class="nc" id="L148">	}</span>

	public boolean collides(final IEntity entity) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">		if (entity instanceof Player) {</span>
<span class="nc" id="L152">			final Player player = (Player) entity;</span>

<span class="nc bnc" id="L154" title="All 4 branches missed.">			if (player.isGhostMode() || player.ignoresCollision()) {</span>
<span class="nc" id="L155">				return false;</span>
			}
		}
		
<span class="nc bnc" id="L159" title="All 2 branches missed.">		if (entity instanceof NPC) {</span>
<span class="nc" id="L160">			final NPC npc = (NPC) entity;</span>
			
<span class="nc bnc" id="L162" title="All 2 branches missed.">			if (npc.ignoresCollision()) {</span>
<span class="nc" id="L163">				return false;</span>
			}
		}

<span class="nc" id="L167">		final Rectangle2D area = entity.getArea();</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (collisionMap.collides(area)) {</span>
<span class="nc" id="L170">			return true;</span>
		}

<span class="nc bnc" id="L173" title="All 2 branches missed.">		for (final IEntity other : objects.values()) {</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">			if (other.isObstacle(entity) &amp;&amp; area.intersects(other.getArea())) {</span>
<span class="nc" id="L175">				return true;</span>
			}
<span class="nc" id="L177">		}</span>

<span class="nc" id="L179">		return false;</span>
	}

	/**
	 * Update objects based on the lapsus of time ellapsed since the last call.
	 * 
	 * @param delta
	 *            The time since last update (in ms).
	 */
	public void update(final int delta) {
<span class="nc bnc" id="L189" title="All 2 branches missed.">		for (final IEntity entity : objects.values()) {</span>
<span class="nc" id="L190">			entity.update(delta);</span>
<span class="nc" id="L191">		}</span>
<span class="nc" id="L192">	}</span>

	/**
	 * Create an add an Entity. This does not add to the screen list.
	 * 
	 * @param object
	 *            The object.
	 * 
	 * @return An entity.
	 */
	private IEntity add(final RPObject object) {
<span class="nc" id="L203">		final IEntity entity = EntityFactory.createEntity(object);</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (entity != null) {</span>
<span class="nc" id="L206">			objects.put(FQID.create(object), entity);</span>
		}

<span class="nc" id="L209">		return entity;</span>
	}

	//
	// RPObjectChangeListener
	//

	/**
	 * An object was added.
	 * 
	 * @param object
	 *            The object.
	 */
	@Override
	public void onAdded(final RPObject object) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (!object.getRPClass().subclassOf(&quot;entity&quot;)) {</span>
<span class="nc" id="L225">			logger.debug(&quot;Skipping non-entity object: &quot; + object);</span>
<span class="nc" id="L226">			return;</span>
		}

<span class="nc" id="L229">		final IEntity entity = add(object);</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (entity == null) {</span>
<span class="nc" id="L232">			logger.error(&quot;No entity for: &quot; + object);</span>
		} else {
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if (entity.isOnGround()) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">				for (GameObjectListener listener : gameObjectListeners) {</span>
<span class="nc" id="L236">					listener.addEntity(entity);</span>
<span class="nc" id="L237">				}</span>
			}

<span class="nc" id="L240">			logger.debug(&quot;added &quot; + entity);</span>
		}
<span class="nc" id="L242">	}</span>

	/**
	 * The object added/changed attribute(s).
	 * 
	 * @param object
	 *            The base object.
	 * @param changes
	 *            The changes.
	 */
	@Override
	public void onChangedAdded(final RPObject object, final RPObject changes) {
<span class="nc" id="L254">		final IEntity iEntity = objects.get(FQID.create(object));</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">		if (iEntity instanceof Entity) {</span>
<span class="nc" id="L257">			final Entity entity = (Entity) iEntity;</span>

<span class="nc" id="L259">			entity.onChangedAdded(object, changes);</span>

<span class="nc" id="L261">			EventDispatcher.dispatchEvents(changes, entity);</span>
		}
<span class="nc" id="L263">	}</span>


	/**
	 * An object removed attribute(s).
	 * 
	 * @param object
	 *            The base object.
	 * @param changes
	 *            The changes.
	 */
	@Override
	public void onChangedRemoved(final RPObject object, final RPObject changes) {
<span class="nc" id="L276">		final IEntity entity = objects.get(FQID.create(object));</span>

<span class="nc bnc" id="L278" title="All 2 branches missed.">		if (entity instanceof Entity) {</span>
<span class="nc" id="L279">			((Entity) entity).onChangedRemoved(object, changes);</span>
		}
<span class="nc" id="L281">	}</span>

	/**
	 * An object was removed.
	 * 
	 * @param object
	 *            The object.
	 */
	@Override
	public void onRemoved(final RPObject object) {
<span class="nc" id="L291">		final RPObject.ID id = object.getID();</span>

<span class="nc" id="L293">		logger.debug(&quot;removed &quot; + id);</span>

<span class="nc" id="L295">		final IEntity entity = objects.remove(FQID.create(object));</span>

<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (entity != null) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">			for (GameObjectListener listener : gameObjectListeners) {</span>
<span class="nc" id="L299">				listener.removeEntity(entity);</span>
<span class="nc" id="L300">			}</span>
<span class="nc" id="L301">			entity.release();</span>
		}
<span class="nc" id="L303">	}</span>

	/**
	 * A slot object was added.
	 * 
	 * @param object
	 *            The container object.
	 * @param slotName
	 *            The slot name.
	 * @param sobject
	 *            The slot object.
	 */
	@Override
	public void onSlotAdded(final RPObject object, final String slotName,
			final RPObject sobject) {
<span class="nc" id="L318">	}</span>

	/**
	 * A slot object added/changed attribute(s).
	 * 
	 * @param object
	 *            The base container object.
	 * @param slotName
	 *            The container's slot name.
	 * @param sobject
	 *            The slot object.
	 * @param schanges
	 *            The slot object changes.
	 */
	@Override
	public void onSlotChangedAdded(final RPObject object,
			final String slotName, final RPObject sobject,
			final RPObject schanges) {
<span class="nc" id="L336">		final IEntity entity = objects.get(FQID.create(object));</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">		if (entity instanceof Entity) {</span>
<span class="nc" id="L339">			((Entity) entity).onSlotChangedAdded(object, slotName, sobject, schanges);</span>
		}
<span class="nc" id="L341">	}</span>

	/**
	 * A slot object removed attribute(s).
	 * 
	 * @param object
	 *            The base container object.
	 * @param slotName
	 *            The container's slot name.
	 * @param sobject
	 *            The slot object.
	 * @param schanges
	 *            The slot object changes.
	 */
	@Override
	public void onSlotChangedRemoved(final RPObject object,
			final String slotName, final RPObject sobject,
			final RPObject schanges) {
<span class="nc" id="L359">		final IEntity entity = objects.get(FQID.create(object));</span>

<span class="nc bnc" id="L361" title="All 2 branches missed.">		if (entity instanceof Entity) {</span>
<span class="nc" id="L362">			((Entity) entity).onSlotChangedRemoved(object, slotName, sobject, schanges);</span>
		}
<span class="nc" id="L364">	}</span>

	/**
	 * A slot object was removed.
	 * 
	 * @param object
	 *            The container object.
	 * @param slotName
	 *            The slot name.
	 * @param sobject
	 *            The slot object.
	 */
	@Override
	public void onSlotRemoved(final RPObject object, final String slotName,
			final RPObject sobject) {
<span class="nc" id="L379">	}</span>

	//
	//

	/**
	 * A fully qualified ID. This will make an nested ID unique, even when in a
	 * slot tree.
	 */
	private static class FQID {
		/**
		 * The object identification path.
		 */
		private Object[] path;

		/**
		 * Create a fully qualified ID.
		 * 
		 * @param id
		 *            And object ID.
		 */
		private FQID(final RPObject.ID id) {
<span class="nc" id="L401">			this(new Object[] { Integer.valueOf(id.getObjectID()) });</span>
<span class="nc" id="L402">		}</span>

		/**
		 * Create a fully qualified ID.
		 * marked as private because of security reasons to avoid
		 * storing an array of externally mutable objects
		 * 
		 * @param path
		 *            An identification path.
		 */
<span class="nc" id="L412">		private FQID(final Object[] path) { // NOPMD by martin on 24.11.10</span>
<span class="nc" id="L413">			this.path = path;</span>
<span class="nc" id="L414">		}</span>

		//
		// FQID
		//

		/**
		 * Create a FQID from an object tree.
		 * 
		 * @param object
		 *            An object.
		 * 
		 * @return A FQID.
		 */
		private static FQID create(final RPObject object) {
<span class="nc" id="L429">			final LinkedList&lt;Object&gt; path = new LinkedList&lt;Object&gt;();</span>
<span class="nc" id="L430">			RPObject node = object;</span>

			while (true) {
<span class="nc" id="L433">				path.addFirst(Integer.valueOf(node.getID().getObjectID()));</span>

<span class="nc" id="L435">				final RPSlot slot = node.getContainerSlot();</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">				if (slot == null) {</span>
<span class="nc" id="L438">					break;</span>
				}

<span class="nc" id="L441">				path.addFirst(slot.getName());</span>
<span class="nc" id="L442">				node = node.getContainer();</span>
<span class="nc" id="L443">			}</span>

<span class="nc" id="L445">			return new FQID(path.toArray());</span>
		}

		/**
		 * Get the tree path of object identifiers.
		 * marked as private because of security reasons to avoid
		 * exposing an array of mutable objects
		 * 
		 * @return The identifier path.
		 */
		private Object[] getPath() {
<span class="nc" id="L456">			return path; // NOPMD by martin on 24.11.10</span>
		}

		//
		// Object
		//

		/**
		 * Check if this equals another object.
		 * 
		 * @param obj
		 *            The object to compare to.
		 */
		@Override
		public boolean equals(final Object obj) {
			boolean ret;

<span class="nc bnc" id="L473" title="All 2 branches missed.">			if (obj instanceof FQID) {</span>
<span class="nc" id="L474">				ret = Arrays.equals(getPath(), ((FQID) obj).getPath());</span>
			} else {
<span class="nc" id="L476">				ret = false;</span>
			}

<span class="nc" id="L479">			return ret;</span>
		}

		/**
		 * Get the hash code.
		 * 
		 * @return The hash code.
		 */
		@Override
		public int hashCode() {
<span class="nc" id="L489">			int value = 0;</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">			for (final Object obj : getPath()) {</span>
<span class="nc" id="L492">				value ^= obj.hashCode();</span>
			}

<span class="nc" id="L495">			return value;</span>
		}

		/**
		 * Get the string representation.
		 * 
		 * @return The string representation.
		 */
		@Override
		public String toString() {
<span class="nc" id="L505">			final StringBuilder sbuf = new StringBuilder();</span>

<span class="nc" id="L507">			sbuf.append('[');</span>
<span class="nc" id="L508">			sbuf.append(path[0]);</span>

<span class="nc bnc" id="L510" title="All 2 branches missed.">			for (int i = 1; i &lt; path.length; i++) {</span>
<span class="nc" id="L511">				sbuf.append(':');</span>
<span class="nc" id="L512">				sbuf.append(path[i]);</span>
			}

<span class="nc" id="L515">			sbuf.append(']');</span>

<span class="nc" id="L517">			return sbuf.toString();</span>
		}
	}
	
	/**
	 * Interface for objects that need to follow new top level entities being
	 * added to, or removed from the current zone.
	 */
	public interface GameObjectListener {
		/**
		 * Called when a top level entity is added to the user's zone.
		 * 
		 * @param entity
		 */
		void addEntity(IEntity entity);
		
		/**
		 * Called when a top level entity is removed from the user's zone.
		 * 
		 * @param entity
		 */
		void removeEntity(IEntity entity);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>