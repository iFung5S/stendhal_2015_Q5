<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ActiveEntity.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity</a> &gt; <span class="el_source">ActiveEntity.java</span></div><h1>ActiveEntity.java</h1><pre class="source lang-java linenums">/*
 * @(#) src/games/stendhal/server/entity/ActiveEntity.java
 *
 * $Id$
 */

package games.stendhal.server.entity;

//
//

import games.stendhal.common.Direction;
import games.stendhal.common.constants.Testing;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.core.rp.StendhalRPAction;
import games.stendhal.server.entity.mapstuff.portal.Portal;

import java.awt.geom.Rectangle2D;

import marauroa.common.game.Definition;
import marauroa.common.game.Definition.Type;
import marauroa.common.game.RPClass;
import marauroa.common.game.RPObject;

import org.apache.log4j.Logger;

/**
 * An entity that has speed and direction.
 */
public abstract class ActiveEntity extends Entity {
	/**
	 * The logger.
	 */
<span class="fc" id="L34">	private static final Logger logger = Logger.getLogger(ActiveEntity.class);</span>

	/*
	 * The facing direction
	 */
	private Direction direction;

	/**
	 * The current speed.
	 */
	private double speed;
	
	/**
	 * The amount of uncommitted tile movement.
	 */
	private double movementOffset;
	
	private int stepsTaken;

	/** Allows entity to walk through collision areas */
	private boolean ignoreCollision;

	/**
	 * Create an active entity.
	 */
<span class="fc" id="L59">	public ActiveEntity() {</span>
<span class="fc" id="L60">		direction = Direction.STOP;</span>
<span class="fc" id="L61">		speed = 0.0;</span>
<span class="fc" id="L62">		movementOffset = 0.0;</span>
<span class="fc" id="L63">		stepsTaken = 0;</span>
<span class="fc" id="L64">	}</span>

	/**
	 * Create an active entity.
	 * 
	 * @param object
	 *            The source object.
	 */
	public ActiveEntity(final RPObject object) {
<span class="fc" id="L73">		super(object);</span>

<span class="fc" id="L75">		direction = Direction.STOP;</span>
<span class="fc" id="L76">		speed = 0.0;</span>
<span class="fc" id="L77">		stepsTaken = 0;</span>
		
<span class="fc" id="L79">		update();</span>
<span class="fc" id="L80">	}</span>

	protected void move(final int x, final int y, final int nx, final int ny) {
<span class="fc" id="L83">		setPosition(nx, ny);</span>
<span class="fc" id="L84">		notifyWorldAboutChanges();</span>
<span class="fc" id="L85">	}</span>

	protected boolean handlePortal(final Portal portal) {
		
<span class="nc" id="L89">		return false;</span>
	}

	protected void handleLeaveZone(final int nx, final int ny) {
<span class="nc" id="L93">		logger.debug(&quot;Leaving zone from (&quot; + getX() + &quot;,&quot; + getY() + &quot;) to (&quot;</span>
				+ nx + &quot;,&quot; + ny + &quot;)&quot;);
<span class="nc" id="L95">		StendhalRPAction.decideChangeZone(this, nx, ny);</span>

		/* TODO: Remove after zone-change testing is finished.
		 * 
		 * It is uncommon in games to have to release the direction key and
		 * press it again after a zone change.
		 */
<span class="nc bnc" id="L102" title="All 2 branches missed.">		if (!Testing.MOVEMENT) {</span>
<span class="nc" id="L103">			stop();</span>
		}

<span class="nc" id="L106">		notifyWorldAboutChanges();</span>
<span class="nc" id="L107">	}</span>

	/**
	 * Define the RPClass.
	 * 
	 * @return The configured RPClass.
	 */
	private static RPClass createRPClass() {
<span class="fc" id="L115">		final RPClass rpclass = new RPClass(&quot;active_entity&quot;);</span>

<span class="fc" id="L117">		rpclass.isA(&quot;entity&quot;);</span>
<span class="fc" id="L118">		rpclass.addAttribute(&quot;dir&quot;, Type.BYTE, Definition.VOLATILE);</span>
<span class="fc" id="L119">		rpclass.addAttribute(&quot;speed&quot;, Type.FLOAT, Definition.VOLATILE);</span>

<span class="fc" id="L121">		return rpclass;</span>
	}

	/**
	 * Generate the RPClass (compatible with manual init/order).
	 * 
	 * NOTE: This MUST be called during environment initialization.
	 */
	public static void generateRPClass() {
<span class="fc" id="L130">		createRPClass();</span>
<span class="fc" id="L131">	}</span>

	/**
	 * Determine if zone changes are currently allowed via normal means
	 * (non-portal teleportation doesn't count).
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the entity can change zones.
	 */
	protected boolean isZoneChangeAllowed() {
<span class="fc" id="L140">		return false;</span>
	}

	//
	// Entity
	//

	/**
	 * Called when this object is added to a zone.
	 * 
	 * @param zone
	 *            The zone this was added to.
	 */
	@Override
	public void onAdded(final StendhalRPZone zone) {
<span class="fc" id="L155">		super.onAdded(zone);</span>

<span class="fc" id="L157">		zone.notifyEntered(this, getX(), getY());</span>
<span class="fc" id="L158">	}</span>

	/**
	 * Called when this object is removed from a zone.
	 * 
	 * @param zone
	 *            The zone this was removed from.
	 */
	@Override
	public void onRemoved(final StendhalRPZone zone) {
<span class="fc" id="L168">		zone.notifyExited(this, getX(), getY());</span>

<span class="fc" id="L170">		super.onRemoved(zone);</span>
<span class="fc" id="L171">	}</span>

	@Override
	public void update() {
<span class="fc" id="L175">		super.update();</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">		if (has(&quot;dir&quot;)) {</span>
<span class="nc" id="L178">			direction = Direction.build(getInt(&quot;dir&quot;));</span>
		}

<span class="pc bpc" id="L181" title="1 of 2 branches missed.">		if (has(&quot;speed&quot;)) {</span>
<span class="nc" id="L182">			speed = getDouble(&quot;speed&quot;);</span>
		}
<span class="fc" id="L184">	}</span>

	/**
	 * Checks whether an entity is a ghost (non physically interactive).
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if in ghost mode.
	 */
	public boolean isGhost() {
		// 'ghostmode' attribute is at player level
<span class="fc" id="L193">		return false;</span>
	}

	/**
	 * Get the resistance this has on other entities (0-100).
	 * 
	 * @return The amount of resistance, or 0 if in ghostmode.
	 */
	@Override
	public int getResistance() {
<span class="fc bfc" id="L203" title="All 2 branches covered.">		if (isGhost()) {</span>
<span class="fc" id="L204">			return 0;</span>
		}
<span class="fc" id="L206">		return super.getResistance();</span>
	}
	
	
/* XXX --- DIRECTION --- XXX */
	
	
	/**
	 * Face toward a specified point on the map.
	 * 
	 * @param x
	 * 		Horizontal coordinate of position
	 * @param y
	 * 		Vertical coordinate of position
	 */
	public final void faceto(final int x, final int y) {
<span class="fc" id="L222">		final int rndx = x - getX();</span>
<span class="fc" id="L223">		final int rndy = y - getY();</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">		if (Math.abs(rndx) &gt; Math.abs(rndy)) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">			if (rndx &lt; 0.0) {</span>
<span class="fc" id="L227">				setDirection(Direction.LEFT);</span>
			} else {
<span class="fc" id="L229">				setDirection(Direction.RIGHT);</span>
			}
		} else {
<span class="fc bfc" id="L232" title="All 2 branches covered.">			if (rndy &lt; 0.0) {</span>
<span class="fc" id="L233">				setDirection(Direction.UP);</span>
			} else {
<span class="fc" id="L235">				setDirection(Direction.DOWN);</span>
			}
		}
<span class="fc" id="L238">	}</span>
	
	/**
	 * Face toward an entity.
	 * 
	 * @param entity
	 * 		The entity to face toward
	 */
	public final void faceToward(final Entity entity) {
<span class="fc" id="L247">		setDirection(getDirectionToward(entity));</span>
<span class="fc" id="L248">	}</span>
	
	/**
	 * Get the current facing direction.
	 * 
	 * @return
	 * 		The facing direction
	 */
	public Direction getDirection() {
<span class="fc" id="L257">		return direction;</span>
	}

	/**
	 * Get the direction toward an entity.
	 * 
	 * @param entity
	 * 		The target entity
	 * 
	 * @return
	 * 		A facing direction
	 */
	public final Direction getDirectionToward(final Entity entity) {
<span class="fc" id="L270">		return getDirectionToward(entity.getArea());</span>
	}

	final Direction getDirectionToward(final Rectangle2D area) {
<span class="fc" id="L274">		return Direction.getAreaDirectionTowardsArea(getArea(), area);</span>
	}
	
	/**
	 * Determine if this entity is facing toward another entity.
	 * 
	 * @param entity
	 * 		The target entity
	 * 
	 * @return
	 * 		&lt;code&gt;true&lt;/code&gt; if facing other entity
	 */
	public boolean isFacingToward(final Entity entity) {
<span class="fc" id="L287">		return direction.equals(getDirectionToward(entity));</span>
	}
	
	/**
	 * Set the facing direction.
	 * 
	 * @param dir
	 * 		Direction to face toward
	 */
	public void setDirection(final Direction dir) {
<span class="fc bfc" id="L297" title="All 2 branches covered.">		if (dir == this.direction) {</span>
<span class="fc" id="L298">			return;</span>
		}

<span class="fc" id="L301">		this.direction = dir;</span>
<span class="fc" id="L302">		put(&quot;dir&quot;, direction.get());</span>
<span class="fc" id="L303">	}</span>
	
	
/* XXX --- MOVEMENT --- XXX */
	
	/**
	 * Apply movement and process it's reactions.
	 */
	public void applyMovement() {
		// even if we could we would not move;
<span class="fc bfc" id="L313" title="All 2 branches covered.">		if (speed == 0) {</span>
<span class="fc" id="L314">			stepsTaken = 0;</span>
<span class="fc" id="L315">			return;</span>
		}
		/* XXX: Can this.stopped() be called here instead and set direction
		 *      to Direction.DOWN at construction? Issue found with WalkAction:
		 *      When player logs in setSpeed() will not cause movement as
		 *      direction is set to STOP. WalkAction bypasses this by setting
		 *      default to DOWN if direction is STOP or null.
		 */
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">		if (direction == Direction.STOP) {</span>
<span class="nc" id="L324">			stepsTaken = 0;</span>
<span class="nc" id="L325">			return;</span>
		}
		

<span class="fc" id="L329">		final int x = getX();</span>
<span class="fc" id="L330">		final int y = getY();</span>
<span class="fc" id="L331">		final int nx = x + direction.getdx();</span>
<span class="fc" id="L332">		final int ny = y + direction.getdy();</span>
		
<span class="fc" id="L334">		final StendhalRPZone zone = getZone();</span>
		
<span class="fc" id="L336">		zone.notifyBeforeMovement(this, x, y, nx, ny);</span>
		
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">		if (!ignoresCollision()) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">			if (zone.simpleCollides(this, nx, ny, this.getWidth(), this.getHeight())) {</span>
<span class="fc" id="L340">				handleSimpleCollision(nx, ny);</span>
<span class="fc" id="L341">				return;</span>
			}
		}
<span class="fc" id="L344">		final Portal p = zone.getPortal(nx, ny);</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">		if (p != null) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">			if (handlePortal(p)) {</span>
<span class="nc" id="L347">				return;</span>
			}
		}

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">		if (isGhost()) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">			if (isMoveCompleted()) {</span>
<span class="nc" id="L353">				move(x, y, nx, ny);</span>
<span class="nc" id="L354">				return;</span>
			}
		}

<span class="fc" id="L358">		final boolean collision = zone.collidesObjects(this, this.getArea(nx, ny));</span>

<span class="fc bfc" id="L360" title="All 2 branches covered.">		if (collision) {</span>
			/* Collision */
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L363">				logger.debug(&quot;Collision at (&quot; + nx + &quot;,&quot; + ny + &quot;)&quot;);</span>
			}
<span class="fc" id="L365">			handleObjectCollision();</span>
		} else {
<span class="fc bfc" id="L367" title="All 2 branches covered.">			if (!isMoveCompleted()) {</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">				if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L369">					logger.debug(get(&quot;type&quot;) + &quot;) move not completed&quot;);</span>
				}
<span class="fc" id="L371">				return;</span>
			}

<span class="pc bpc" id="L374" title="1 of 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L375">				logger.debug(&quot;Moving from (&quot; + x + &quot;,&quot; + y + &quot;) to (&quot; + nx</span>
						+ &quot;,&quot; + ny + &quot;)&quot;);
			}

<span class="fc" id="L379">			move(x, y, nx, ny);</span>
<span class="fc" id="L380">			stepsTaken += 1;</span>
		}
<span class="fc" id="L382">	}</span>
	
	/**
	 * Get the current speed.
	 * 
	 * @return
	 * 		The current speed, or &lt;code&gt;0.0&lt;/code&gt; if stopped.
	 */
	public double getSpeed() {
<span class="fc" id="L391">		return speed;</span>
	}
	
	/**
	 * Retrieves the amount of steps the entity has taken during the current
	 * session.
	 * 
	 * @return
	 * 		Steps taken
	 */
	public int getStepsTaken() {
<span class="nc" id="L402">	    return stepsTaken;</span>
	}
	
	/**
	 * Determine if this entity has move at least a whole tile.
	 * 
	 * @return
	 * 		&lt;code&gt;true&lt;/code&gt; if moved a whole tile
	 */
	protected boolean isMoveCompleted() {
<span class="fc" id="L412">		movementOffset += getSpeed();</span>

<span class="fc bfc" id="L414" title="All 2 branches covered.">		if (movementOffset &gt;= 1.0) {</span>
<span class="fc" id="L415">			movementOffset -= 1.0;</span>
<span class="fc" id="L416">			return true;</span>
		} else {
<span class="fc" id="L418">			return false;</span>
		}
	}
	
	/**
	 * Notification of intra-zone position change.
	 * 
	 * @param oldX
	 * 		The old X coordinate.
	 * @param oldY
	 * 		The old Y coordinate.
	 * @param newX
	 * 		The new X coordinate.
	 * @param newY
	 * 		The new Y coordinate.
	 */
	@Override
	protected void onMoved(final int oldX, final int oldY, final int newX, final int newY) {
<span class="fc" id="L436">		getZone().notifyMovement(this, oldX, oldY, newX, newY);</span>
<span class="fc" id="L437">	}</span>
	
	/**
	 * Set the movement speed.
	 * 
	 * @param speed
	 * 		New speed.
	 */
	public void setSpeed(final double speed) {
<span class="fc bfc" id="L446" title="All 2 branches covered.">		if (speed == this.speed) {</span>
<span class="fc" id="L447">			return;</span>
		}
		
<span class="fc" id="L450">		this.speed = speed;</span>
<span class="fc" id="L451">		put(&quot;speed&quot;, speed);</span>
<span class="fc" id="L452">		notifyWorldAboutChanges();</span>
<span class="fc" id="L453">	}</span>
	
	/**
	 * Stops entity's movement.
	 */
	public void stop() {
<span class="fc" id="L459">		setSpeed(0.0);</span>
<span class="fc" id="L460">		movementOffset = 0.0;</span>
<span class="fc" id="L461">	}</span>
	
	/**
	 * Checks if the entity is not moving.
	 * 
	 * @return
	 * 		&lt;b&gt;true&lt;/b&gt; if stopped, &lt;b&gt;false&lt;/b&gt; if moving
	 */
	@Override
	public boolean stopped() {
<span class="fc bfc" id="L471" title="All 2 branches covered.">		return (speed == 0.0);</span>
	}
	
	
/* XXX --- COLLISION --- XXX */
	
	protected void handleObjectCollision() {
		// implemented by sub classes
<span class="nc" id="L479">	}</span>
	
	/**
	 * a simple collision is from tiled collision layer or the edge of the map.
	 * 
	 * @param ny
	 * @param nx
	 * 
	 */
	protected void handleSimpleCollision(final int nx, final int ny) {
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">		if (isZoneChangeAllowed()) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">			if (getZone().leavesZone(this, nx, ny)) {</span>
<span class="nc" id="L491">				handleLeaveZone(nx, ny);</span>
<span class="nc" id="L492">				return;</span>
			}
		}
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">		if (isGhost()) {</span>
<span class="nc" id="L496">			move(getX(), getY(), nx, ny);</span>
		}
<span class="fc" id="L498">	}</span>
	
	/**
	 * Tells if entity can pass through collision tiles
	 *
	 * @return ignoreCollision
	 */
	public boolean ignoresCollision() {
<span class="fc" id="L506">		return ignoreCollision;</span>
	}
	
	/**
	 * Set entity to ignore collision tiles
	 *
	 * @param ignore
	 */
	public void setIgnoresCollision(boolean ignore) {
<span class="fc" id="L515">		ignoreCollision = ignore;</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">		if (ignore) {</span>
<span class="fc" id="L517">			put(&quot;ignore_collision&quot;, &quot;&quot;);</span>
		} else {
<span class="nc" id="L519">			remove(&quot;ignore_collision&quot;);</span>
		}
<span class="fc" id="L521">	}</span>
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>