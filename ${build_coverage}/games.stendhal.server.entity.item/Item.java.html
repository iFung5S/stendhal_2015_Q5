<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Item.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity.item</a> &gt; <span class="el_source">Item.java</span></div><h1>Item.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                      (C) Copyright 2003 - Marauroa                      *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.entity.item;

import games.stendhal.common.MathHelper;
import games.stendhal.common.Rand;
import games.stendhal.common.constants.Nature;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.server.core.engine.ItemLogger;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.events.EquipListener;
import games.stendhal.server.core.events.TurnListener;
import games.stendhal.server.core.events.UseListener;
import games.stendhal.server.entity.PassiveEntity;
import games.stendhal.server.entity.RPEntity;
import games.stendhal.server.entity.item.behavior.UseBehavior;
import games.stendhal.server.entity.mapstuff.spawner.PassiveEntityRespawnPoint;
import games.stendhal.server.entity.player.Player;
import games.stendhal.server.entity.status.StatusType;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import marauroa.common.game.Definition;
import marauroa.common.game.Definition.Type;
import marauroa.common.game.RPClass;
import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;

import org.apache.log4j.Logger;

/**
 * This is an item.
 */
public class Item extends PassiveEntity implements TurnListener, EquipListener,
	UseListener {

	private static final int DEFAULT_ATTACK_RATE = 5;

	/**
	 * max degree of deterioration
	 */
	private static final int MAX_DETERIORATION = 100;

	/**
	 * default value for deterioration implies each item is okay if ne
	 */
	private static final int DEFAULT_DETERIORATION = 0;

	/**
	 * mean time an item is constantly usable in hours
	 */
	private static final long MEAN_LIFETIME = 12 * MathHelper.MILLISECONDS_IN_ONE_HOUR;
	
	// 10 minutes
	public static final int DEGRADATION_TIMEOUT = 10 * MathHelper.SECONDS_IN_ONE_MINUTE;


	/** list of possible slots for this item. */
	private List&lt;String&gt; possibleSlots;

	/**
	 * The plant grower where this item was grown, until it has been picked.
	 * null if it wasn't grown by a plant grower, or if it has already been
	 * picked.
	 */
	private PassiveEntityRespawnPoint plantGrower;

	/** The damage type of weapons */
<span class="fc" id="L83">	private Nature damageType = Nature.CUT;</span>

	private Map&lt;Nature, Double&gt; susceptibilities;
	
<span class="fc" id="L87">	private boolean fromCorpse = false;</span>
	
	/**
	 * Use behavior implementation, or &lt;code&gt;null&lt;/code&gt; if the item does not
	 * have any, or if the behavior is implemented in a subclass.
	 */
	private UseBehavior useBehavior;

	/**
	 *
	 * Creates a new Item.
	 *
	 * @param name
	 *            name of item
	 * @param clazz
	 *            class (or type) of item
	 * @param subclass
	 *            subclass of this item
	 * @param attributes
	 *            attributes (like attack). may be empty or &lt;code&gt;null&lt;/code&gt;
	 */
	public Item(final String name, final String clazz, final String subclass,
			final Map&lt;String, String&gt; attributes) {
<span class="fc" id="L110">		this();</span>

<span class="fc" id="L112">		setEntityClass(clazz);</span>
<span class="fc" id="L113">		setEntitySubclass(subclass);</span>

<span class="fc" id="L115">		put(&quot;name&quot;, name);</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">		if (attributes != null) {</span>
			// store all attributes
<span class="fc bfc" id="L119" title="All 2 branches covered.">			for (final Entry&lt;String, String&gt; entry : attributes.entrySet()) {</span>
<span class="fc" id="L120">				put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L121">			}</span>
		}

<span class="fc" id="L124">		update();</span>
<span class="fc" id="L125">	}</span>

	/** no public 'default' item. */
<span class="fc" id="L128">	private Item() {</span>
<span class="fc" id="L129">		setRPClass(&quot;item&quot;);</span>
<span class="fc" id="L130">		put(&quot;type&quot;, &quot;item&quot;);</span>
<span class="fc" id="L131">		possibleSlots = new LinkedList&lt;String&gt;();</span>
<span class="fc" id="L132">		update();</span>
<span class="fc" id="L133">	}</span>

	/**
	 * copy constructor.
	 *
	 * @param item
	 *            item to copy
	 */
	public Item(final Item item) {
<span class="fc" id="L142">		super(item);</span>
<span class="fc" id="L143">		setRPClass(&quot;item&quot;);</span>
<span class="fc" id="L144">		possibleSlots = new ArrayList&lt;String&gt;(item.possibleSlots);</span>
<span class="fc" id="L145">		damageType = item.damageType;</span>
<span class="fc" id="L146">		susceptibilities = item.susceptibilities;</span>
<span class="fc" id="L147">	}</span>

	public static void generateRPClass() {
<span class="fc" id="L150">		final RPClass entity = new RPClass(&quot;item&quot;);</span>
<span class="fc" id="L151">		entity.isA(&quot;entity&quot;);</span>

		// class, sword/armor/...
<span class="fc" id="L154">		entity.addAttribute(&quot;class&quot;, Type.STRING);</span>

		// subclass, long sword/leather/armor/...
<span class="fc" id="L157">		entity.addAttribute(&quot;subclass&quot;, Type.STRING);</span>

		// name of item (ie 'Kings Sword')
<span class="fc" id="L160">		entity.addAttribute(&quot;name&quot;, Type.STRING);</span>

		// Some items have attack values
<span class="fc" id="L163">		entity.addAttribute(&quot;atk&quot;, Type.SHORT, Definition.HIDDEN);</span>
		
		// Some items have ranged attack values
<span class="fc" id="L166">		entity.addAttribute(&quot;ratk&quot;, Type.SHORT, Definition.HIDDEN);</span>

		// Some items indicate how often you can attack.
<span class="fc" id="L169">		entity.addAttribute(&quot;rate&quot;, Type.SHORT, Definition.HIDDEN);</span>

		// Some items have defense values
<span class="fc" id="L172">		entity.addAttribute(&quot;def&quot;, Type.SHORT, Definition.HIDDEN);</span>

		//Some items can be damaged in combat or during use. This rises the degree of deterioration
<span class="fc" id="L175">		entity.addAttribute(&quot;deterioration&quot;, Type.INT, (byte) (Definition.HIDDEN | Definition.VOLATILE));</span>

		// Some items(food) have amount of something
		// (a bottle, a piece of meat).
<span class="fc" id="L179">		entity.addAttribute(&quot;amount&quot;, Type.INT);</span>

		// Some items (range weapons, ammunition, missiles)
		// have a range.
<span class="fc" id="L183">		entity.addAttribute(&quot;range&quot;, Type.SHORT, Definition.HIDDEN);</span>

		// Some items(food) have regeneration
<span class="fc" id="L186">		entity.addAttribute(&quot;regen&quot;, Type.INT, Definition.HIDDEN);</span>

		// Some items(food) have regeneration speed
<span class="fc" id="L189">		entity.addAttribute(&quot;frequency&quot;, Type.INT, Definition.HIDDEN);</span>

		// Some items(Stackable) have quantity
<span class="fc" id="L192">		entity.addAttribute(&quot;quantity&quot;, Type.INT);</span>

		// Some items (Stackable) have maximum quantity
<span class="fc" id="L195">		entity.addAttribute(&quot;max_quantity&quot;, Type.INT, Definition.HIDDEN);</span>

		// Some items have minimum level to prevent spoiling
		// the fun for new players
<span class="fc" id="L199">		entity.addAttribute(&quot;min_level&quot;, Type.INT, Definition.HIDDEN);</span>

		// To store addAttributeitional info with an item
<span class="fc" id="L202">		entity.addAttribute(&quot;infostring&quot;, Type.STRING, Definition.HIDDEN);</span>

		// Some items have individual values
<span class="fc" id="L205">		entity.addAttribute(&quot;persistent&quot;, Type.SHORT, Definition.HIDDEN);</span>

		// Some items have lifesteal values
<span class="fc" id="L208">		entity.addAttribute(&quot;lifesteal&quot;, Type.FLOAT, Definition.HIDDEN);</span>
		
		// Items that protect against poisoning
<span class="fc" id="L211">		entity.addAttribute(&quot;antipoison&quot;, Type.FLOAT, (byte) (Definition.HIDDEN | Definition.VOLATILE));</span>

		// Some items are quest rewards that other players
		// don't deserve. Not hidden because the client uses it for an anti
		// theft hack
<span class="fc" id="L216">		entity.addAttribute(&quot;bound&quot;, Type.STRING);</span>

		// Some items should not be dropped on death
<span class="fc" id="L219">		entity.addAttribute(&quot;undroppableondeath&quot;, Type.SHORT, Definition.HIDDEN);</span>

		// Offers life support for certain environments (e. g. scuba gear)
<span class="fc" id="L222">		entity.addAttribute(&quot;life_support&quot;, Type.STRING, Definition.HIDDEN);</span>

		// Unique database ID for logging
<span class="fc" id="L225">		entity.addAttribute(&quot;logid&quot;, Type.INT, Definition.HIDDEN);</span>

		// Name of the container slot, if the item has one
<span class="fc" id="L228">		entity.addAttribute(&quot;slot_name&quot;, Type.STRING, (byte) (Definition.HIDDEN | Definition.VOLATILE));</span>
		
		// Size of the container slot, if the item has one, and the size is
		// other than the default
<span class="fc" id="L232">		entity.addAttribute(&quot;slot_size&quot;, Type.STRING, Definition.VOLATILE);</span>

		// Container slot
<span class="fc" id="L235">		entity.addRPSlot(&quot;content&quot;, -1, Definition.PRIVATE);</span>
		
		// True for items that should be bound automatically at loot (or login)
<span class="fc" id="L238">		entity.addAttribute(&quot;autobind&quot;, Type.FLAG, (byte) (Definition.HIDDEN | Definition.VOLATILE));</span>
<span class="fc" id="L239">	}</span>


	/**
	 * on which slots may this item be equipped.
	 *
	 * @param slots
	 *            list of allowed slots
	 */
	public void setEquipableSlots(final List&lt;String&gt; slots) {
		// save slots
<span class="fc" id="L250">		possibleSlots = slots;</span>
<span class="fc" id="L251">	}</span>

	/**
	 * If this item is created by a PlantGrower, the item will notify it when
	 * picked from the ground.
	 *
	 * @param plantGrower
	 *            a plant grower
	 */
	public void setPlantGrower(final PassiveEntityRespawnPoint plantGrower) {
<span class="fc" id="L261">		this.plantGrower = plantGrower;</span>
<span class="fc" id="L262">	}</span>

	/**
	 * returns the PlantGrower which created this item or null if no plantgrower
	 * was involved.
	 *
	 * @return PlantGrower or null
	 */
	public PassiveEntityRespawnPoint getPlantGrower() {
<span class="nc" id="L271">		return plantGrower;</span>
	}

	/**
	 * Returns the attack points of this item. Positive and negative values are
	 * allowed. If this item doesn't modify the attack it should return '0'.
	 *
	 * @return attack points
	 */
	public int getAttack() {
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">		if (has(&quot;atk&quot;) &amp;&amp; getDeterioration() &lt;= MAX_DETERIORATION) {</span>
<span class="fc" id="L282">			return getInt(&quot;atk&quot;);</span>
		}

<span class="fc" id="L285">		return 0;</span>
	}

	/**
	 * Returns the defense points of this item. Positive and negative values are
	 * allowed. If this item doesn't modify the defense it should return '0'.
	 *
	 * @return defense points
	 */
	public int getDefense() {
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">		if (has(&quot;def&quot;) &amp;&amp; getDeterioration() &lt;= MAX_DETERIORATION) {</span>
<span class="fc" id="L296">			return getInt(&quot;def&quot;);</span>
		}

<span class="fc" id="L299">		return 0;</span>
	}

	/**
	 * Returns the ranged attack points of this item. Positive and negative
	 * values are allowed. If this item doesn't modify the ranged attack
	 * it should return '0'.
	 *
	 * @return ranged attack points
	 */
	public int getRangedAttack() {
<span class="nc bnc" id="L310" title="All 4 branches missed.">		if (has(&quot;ratk&quot;) &amp;&amp; getDeterioration() &lt;= MAX_DETERIORATION) {</span>
<span class="nc" id="L311">			return getInt(&quot;ratk&quot;);</span>
		}

<span class="nc" id="L314">		return 0;</span>
	}

	/**
	 * Returns each how many turns this item can attack.
	 *
	 * @return each how many turns this item can attack.
	 */
	public int getAttackRate() {
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if (has(&quot;rate&quot;)) {</span>
<span class="fc" id="L324">			return getInt(&quot;rate&quot;);</span>
		}

<span class="fc" id="L327">		return DEFAULT_ATTACK_RATE;</span>
	}

	/**
	 * Each Item is subject to deterioration that weakens the item
	 *
	 * @return the current degree of deterioration
	 */
	public int getDeterioration() {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">		if(has(&quot;deterioration&quot;)) {</span>
<span class="nc" id="L337">			return getInt(&quot;deterioration&quot;);</span>
		}
<span class="fc" id="L339">		return DEFAULT_DETERIORATION;</span>
	}

	/**
	 * Propose increase the degree of deterioration. If degree increases is decided by random
	 */
	public void deteriorate() {
<span class="nc" id="L346">		double propabilityForMeanExp = Rand.propabilityForMeanExp(MEAN_LIFETIME / 300 * this.getAttackRate());</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">		if(Rand.flipCoin(propabilityForMeanExp) &amp;&amp; getDeterioration() &lt;= MAX_DETERIORATION) {</span>
<span class="nc" id="L348">			Logger.getLogger(getClass()).debug(&quot;The item&quot;+ this.getName() +&quot;deteriorated from &quot;+this.getDeterioration()+&quot;.&quot;);</span>
//			this.add(&quot;deterioration&quot;, 1);
		} else {
<span class="nc" id="L351">			Logger.getLogger(getClass()).debug(&quot;The item&quot;+ this.getName() +&quot;did not deteriorate from &quot;+this.getDeterioration()+&quot;.&quot;);</span>
		}
<span class="nc" id="L353">	}</span>

	/**
	 * repair this item
	 */
	public void repair() {
<span class="nc bnc" id="L359" title="All 2 branches missed.">		if(has(&quot;deterioration&quot;)) {</span>
<span class="nc" id="L360">			put(&quot;deterioration&quot;, DEFAULT_DETERIORATION);</span>
		}
<span class="nc" id="L362">	}</span>

	/**
	 * Returns if the item is persistent. Persistent items do not update their
	 * stats from the item database and thus can have individual stats
	 *
	 * @return true if item is persistent
	 */
	public boolean isPersistent() {
<span class="fc bfc" id="L371" title="All 2 branches covered.">		if (has(&quot;persistent&quot;)) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">			return (getInt(&quot;persistent&quot;) == 1);</span>
		}

<span class="fc" id="L375">		return false;</span>
	}

	/**
	 * Set the item's persistence.
	 *
	 * @param persistent
	 *            If the item's stats are persistent.
	 */
	public void setPersistent(final boolean persistent) {
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">		if (persistent) {</span>
<span class="fc" id="L386">			put(&quot;persistent&quot;, 1);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">		} else if (has(&quot;persistent&quot;)) {</span>
<span class="nc" id="L388">			remove(&quot;persistent&quot;);</span>
		}
<span class="fc" id="L390">	}</span>

	/**
	 * Checks if the item is of type &lt;i&gt;type&lt;/i&gt; .
	 *
	 * @param clazz
	 *            the class to check
	 * @return true if the type matches, else false
	 */
	public boolean isOfClass(final String clazz) {
<span class="fc" id="L400">		return getItemClass().equals(clazz);</span>
	}

	/** @return the type of the item */
	public String getItemClass() {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">		if (has(&quot;class&quot;)) {</span>
<span class="fc" id="L406">			return get(&quot;class&quot;);</span>
		}

<span class="nc" id="L409">		throw new IllegalStateException(&quot;the item does not have a class: &quot;</span>
				+ this);
	}

	/** @return the subclass of the item */
	public String getItemSubclass() {
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">		if (has(&quot;subclass&quot;)) {</span>
<span class="fc" id="L416">			return get(&quot;subclass&quot;);</span>
		}

<span class="nc" id="L419">		throw new IllegalStateException(&quot;the item does not have a subclass: &quot;</span>
				+ this);
	}

	/**
	 * Gets the name of the item.
	 *
	 * @return The programmatic item name.
	 */
	@Override
	public String getName() {
<span class="fc" id="L430">		return get(&quot;name&quot;);</span>
	}

	/**
	 * Get item count.
	 *
	 * @return 1.
	 */
	public int getQuantity() {
<span class="fc" id="L439">		return 1;</span>
	}

	/** @return the list of possible slots for this item */
	public List&lt;String&gt; getPossibleSlots() {
<span class="fc" id="L444">		return possibleSlots;</span>
	}

	/**
	 * Get the player this is bound to. A bound item can only be used by that
	 * player.
	 *
	 * @return The player name, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public String getBoundTo() {
<span class="fc" id="L454">			return get(&quot;bound&quot;);</span>
	}

	/**
	 * Check if the item is bound to a player
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the item is bound, otherwise
	 * 	&lt;code&gt;false&lt;/code&gt; 
	 */
	public boolean isBound() {
<span class="fc" id="L464">		return has(&quot;bound&quot;);</span>
	}
	
	/**
	 * Bind the item to a player, if the item is one that should be
	 * automatically bound, and the item is not already bound.
	 * 
	 * @param player player name
	 */
	public void autobind(String player) {
<span class="fc bfc" id="L474" title="All 4 branches covered.">		if (!isBound() &amp;&amp; has(&quot;autobind&quot;)) {</span>
<span class="fc" id="L475">			setBoundTo(player);</span>
		}
<span class="fc" id="L477">	}</span>

	/**
	 * Get the item's infoString. The infoString contains context specific
	 * information that is used by the implementation.
	 *
	 * @return The infoString.
	 */
	public String getInfoString() {
<span class="fc bfc" id="L486" title="All 2 branches covered.">		if (has(&quot;infostring&quot;)) {</span>
<span class="fc" id="L487">			return get(&quot;infostring&quot;);</span>
		} else {
<span class="fc" id="L489">			return null;</span>
		}
	}

	/**
	 * Bind this item to a player. A bound item can only be used by that player.
	 *
	 * @param name
	 *            The player name, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public void setBoundTo(final String name) {
<span class="fc bfc" id="L500" title="All 2 branches covered.">		if (name != null) {</span>
<span class="fc" id="L501">			put(&quot;bound&quot;, name);</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">		} else if (has(&quot;bound&quot;)) {</span>
<span class="fc" id="L503">			remove(&quot;bound&quot;);</span>
		}
<span class="fc" id="L505">	}</span>

	/**
	 * Is the item undroppable.
	 *
	 * On player death items carried may be dropped into the players corpse.
	 * unless this method returns true.
	 *
	 *
	 * @return true if item may not be dropped on death of players.
	 */
	public boolean isUndroppableOnDeath() {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">		if (has(&quot;undroppableondeath&quot;)) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">			return (getInt(&quot;undroppableondeath&quot;) == 1);</span>
		}

<span class="fc" id="L521">		return false;</span>
	}

	/**
	 * Set is the item undroppable when player dies.
	 *
	 * @param unDroppableOnDeath
	 *            If true, the item won't be dropped if the player dies.
	 */
	public void setUndroppableOnDeath(final boolean unDroppableOnDeath) {
<span class="nc bnc" id="L531" title="All 2 branches missed.">		if (unDroppableOnDeath) {</span>
<span class="nc" id="L532">			put(&quot;undroppableondeath&quot;, 1);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">		} else if (has(&quot;undroppableondeath&quot;)) {</span>
<span class="nc" id="L534">			remove(&quot;undroppableondeath&quot;);</span>
		}
<span class="nc" id="L536">	}</span>
	
	/**
	 * Set behavior to follow when the item is used.
	 * 
	 * @param behavior new behavior
	 */
	public void setUseBehavior(UseBehavior behavior) {
<span class="fc" id="L544">		useBehavior = behavior;</span>
<span class="fc" id="L545">	}</span>

	/**
	 * Set the item's infostring. The infostring contains context specific
	 * information that is used by the implementation.
	 *
	 * @param infostring
	 *            The item's infostring.
	 */
	public void setInfoString(final String infostring) {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">		if (infostring != null) {</span>
<span class="fc" id="L556">			put(&quot;infostring&quot;, infostring);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">		} else if (has(&quot;infostring&quot;)) {</span>
<span class="nc" id="L558">			remove(&quot;infostring&quot;);</span>
		}
<span class="fc" id="L560">	}</span>

	/**
	 * Get the type of damage inflicted by this item.
	 *
	 * @return type of damage
	 */
	public Nature getDamageType() {
<span class="fc" id="L568">		return damageType;</span>
	}

	/**
	 * Set the type of damage inflicted by this item
	 *
	 * @param type type of damage
	 */
	public void setDamageType(Nature type) {
<span class="fc" id="L577">		damageType = type;</span>
<span class="fc" id="L578">	}</span>

	/**
	 * Get this item's contribution to susceptibility to a
	 * type of damage.
	 *
	 * @param type type of damage to be checked
	 * @return susceptibility to damage of type &lt;code&gt;type&lt;/code&gt;
	 */
	public double getSusceptibility(Nature type) {
<span class="fc" id="L588">		double value = 1.0;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">		if (susceptibilities != null) {</span>
<span class="fc" id="L590">			Double sus = susceptibilities.get(type);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">			if (sus != null) {</span>
<span class="fc" id="L592">				value = sus.doubleValue();</span>
			}
		}

<span class="fc" id="L596">		return value;</span>
	}
	
	/**
	 * Set the susceptibility data of this item.
	 *
	 * @param susceptibilities susceptibilities to be used
	 */
	public void setSusceptibilities(Map&lt;Nature, Double&gt; susceptibilities) {
<span class="fc" id="L605">		this.susceptibilities = susceptibilities;</span>
<span class="fc" id="L606">	}</span>
	
	/**
	 * Override in SlotActivatedItem sub-class.
	 */
	public void initializeActiveSlotsList(final List&lt;String&gt; slotList) {
		// Do nothing
<span class="nc" id="L613">	}</span>
	
	/**
	 * Override in StatusResistantItem sub-class.
	 */
	public void initializeStatusResistancesList(Map&lt;StatusType,
			Double&gt; resistanceList) {
		// Do nothing
<span class="nc" id="L621">	}</span>

	/**
	 * Get a weapon type identifier that can be used in attack events, so that
	 * the client can draw an appropriate item image for the attack.
	 * 
	 * @return weapon identifier
	 */
	public String getWeaponType() {
<span class="nc" id="L630">		return getItemClass();</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L635">		return &quot;Item, &quot; + super.toString();</span>
	}

	/**
	 * Is called when the item is moved to the ground.
	 *
	 * @param player the player who drops the Item.
	 *
	 */
	public void onPutOnGround(final Player player) {
<span class="fc" id="L645">		onPutOnGround(true);</span>
<span class="fc" id="L646">	}</span>

	/**
	 * Is called when the item is created.
	 *
	 * @param expire
	 * 		Set true if the item should expire normally, false otherwise.
	 */
	public void onPutOnGround(final boolean expire) {
<span class="fc bfc" id="L655" title="All 2 branches covered.">		if (expire) {</span>
<span class="fc" id="L656">			SingletonRepository.getTurnNotifier().notifyInSeconds(DEGRADATION_TIMEOUT, this);</span>
		}
<span class="fc" id="L658">	}</span>

	public void onRemoveFromGround() {
		// stop the timer so that the item won't degrade anymore
<span class="fc" id="L662">		SingletonRepository.getTurnNotifier().dontNotify(this);</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">		if (plantGrower != null) {</span>
<span class="nc" id="L664">			plantGrower.onFruitPicked(this);</span>
		}
<span class="fc" id="L666">	}</span>

	@Override
	public void onTurnReached(final int currentTurn) {
		// remove this object from the zone where it's lying on the ground
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">		if (getZone() != null) {</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">			if (this.hasSlot(&quot;content&quot;))</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">			for (RPObject obj : getSlot(&quot;content&quot;)) {</span>
<span class="nc" id="L674">				new ItemLogger().timeout((Item) obj);</span>
<span class="nc" id="L675">			}</span>
<span class="fc" id="L676">			getZone().remove(getID());</span>
<span class="fc" id="L677">			new ItemLogger().timeout(this);</span>
		}
<span class="fc" id="L679">	}</span>

	@Override
	public String describe() {
<span class="fc" id="L683">		String text = &quot;You see &quot; + Grammar.a_noun(getTitle()) + &quot;.&quot;;</span>
<span class="fc" id="L684">		StringBuilder stats = new StringBuilder();</span>
<span class="fc" id="L685">		String levelwarning = &quot;&quot;;</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">		if (hasDescription()) {</span>
<span class="fc" id="L687">			text = getDescription();</span>
		}
		// Highlight the item name
<span class="fc" id="L690">		text = text.replace(getTitle(), &quot;ยง'&quot; + getTitle() + &quot;'&quot;);</span>

<span class="fc" id="L692">		final String boundTo = getBoundTo();</span>

<span class="fc bfc" id="L694" title="All 2 branches covered.">		if (boundTo != null) {</span>
<span class="fc" id="L695">			text = text + &quot; It is a special reward for &quot; + boundTo</span>
					+ &quot;, and cannot be used by others.&quot;;
		}

<span class="fc bfc" id="L699" title="All 2 branches covered.">		if (has(&quot;atk&quot;)) {</span>
<span class="fc" id="L700">			stats.append(&quot;ATK: &quot;);</span>
<span class="fc" id="L701">			stats.append(get(&quot;atk&quot;));</span>
			// Show only special types
<span class="fc bfc" id="L703" title="All 2 branches covered.">			if (getDamageType() != Nature.CUT) {</span>
<span class="fc" id="L704">				stats.append(&quot; [&quot;);</span>
<span class="fc" id="L705">				stats.append(getDamageType());</span>
<span class="fc" id="L706">				stats.append(&quot;]&quot;);</span>
			}
		}
<span class="fc bfc" id="L709" title="All 2 branches covered.">		if (has(&quot;def&quot;)) {</span>
<span class="fc" id="L710">			stats.append(&quot; DEF: &quot;);</span>
<span class="fc" id="L711">			stats.append(get(&quot;def&quot;));</span>
		}
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">		if (has(&quot;ratk&quot;)) {</span>
<span class="nc" id="L714">			stats.append(&quot; RATK: &quot;);</span>
<span class="nc" id="L715">			stats.append(get(&quot;ratk&quot;));</span>
		}
<span class="fc bfc" id="L717" title="All 2 branches covered.">		if (has(&quot;rate&quot;)) {</span>
<span class="fc" id="L718">			stats.append(&quot; RATE: &quot;);</span>
<span class="fc" id="L719">			stats.append(get(&quot;rate&quot;));</span>
		}
<span class="fc bfc" id="L721" title="All 2 branches covered.">		if (has(&quot;amount&quot;)) {</span>
<span class="fc" id="L722">			stats.append(&quot; HP: &quot;);</span>
<span class="fc" id="L723">			stats.append(get(&quot;amount&quot;));</span>
		}
<span class="fc bfc" id="L725" title="All 2 branches covered.">		if (has(&quot;range&quot;)) {</span>
<span class="fc" id="L726">			stats.append(&quot; RANGE: &quot;);</span>
<span class="fc" id="L727">			stats.append(get(&quot;range&quot;));</span>
		}
<span class="fc bfc" id="L729" title="All 2 branches covered.">		if (has(&quot;lifesteal&quot;)) {</span>
<span class="fc" id="L730">			stats.append(&quot; LIFESTEAL: &quot;);</span>
<span class="fc" id="L731">			stats.append(get(&quot;lifesteal&quot;));</span>
		}
<span class="pc bpc" id="L733" title="1 of 4 branches missed.">		if ((susceptibilities != null) &amp;&amp; !susceptibilities.isEmpty()) {</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">			for (Entry&lt;Nature, Double&gt; entry : susceptibilities.entrySet()) {</span>
<span class="nc" id="L735">				stats.append(&quot; &quot;);</span>
<span class="nc" id="L736">				stats.append(entry.getKey());</span>
<span class="nc" id="L737">				stats.append(&quot;: &quot;);</span>
<span class="nc" id="L738">				stats.append(Math.round(100/entry.getValue()));</span>
<span class="nc" id="L739">				stats.append(&quot;%&quot;);</span>
<span class="nc" id="L740">			}</span>
		}
		
<span class="fc bfc" id="L743" title="All 2 branches covered.">		if (has(&quot;min_level&quot;)) {</span>
<span class="fc" id="L744">			stats.append(&quot; MIN-LEVEL: &quot;);</span>
<span class="fc" id="L745">			stats.append(get(&quot;min_level&quot;));</span>
		}
<span class="fc" id="L747">		String statString = &quot;&quot;;</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">		if (stats.length() &gt; 0) {</span>
<span class="fc" id="L749">			statString =  &quot; Stats are (&quot; + stats.toString().trim() + &quot;).&quot;;</span>
		}
<span class="fc" id="L751">		return (text + levelwarning + statString);</span>
	}

	/**
	 * Removes the item. In case of StackableItems only one is removed.
	 */
	public void removeOne() {
<span class="fc" id="L758">		removeFromWorld();</span>
<span class="fc" id="L759">	}</span>

	@Override
	public boolean canBeEquippedIn(final String slot) {
<span class="fc bfc" id="L763" title="All 2 branches covered.">		if (slot == null) {</span>
			// ground
<span class="fc" id="L765">			return true;</span>
		}

<span class="fc" id="L768">		return possibleSlots.contains(slot);</span>
	}


	public void removeFromWorld() {
		
<span class="fc" id="L774">		this.onUnequipped();</span>
		
<span class="fc bfc" id="L776" title="All 2 branches covered.">		if (isContained()) {</span>
			// We modify the base container if the object change.
<span class="fc" id="L778">			RPObject base = getContainer();</span>

<span class="pc bpc" id="L780" title="1 of 2 branches missed.">			while (base.isContained()) {</span>
<span class="nc" id="L781">				base = base.getContainer();</span>
			}

<span class="fc" id="L784">			final RPSlot slot = getContainerSlot();</span>
<span class="fc" id="L785">			slot.remove(getID());</span>

<span class="fc" id="L787">			SingletonRepository.getRPWorld().modify(base);</span>
<span class="fc" id="L788">		} else {</span>
<span class="fc" id="L789">			SingletonRepository.getRPWorld().remove(getID());</span>
		}
<span class="fc" id="L791">	}</span>

	//
	// Entity
	//

	/**
	 * Returns the name or something that can be used to identify the entity for
	 * the player.
	 *
	 * @param definite
	 *            &lt;code&gt;true&lt;/code&gt; for &quot;the&quot;, and &lt;code&gt;false&lt;/code&gt; for
	 *            &quot;a/an&quot; in case the entity has no name.
	 *
	 * @return The description name.
	 */
	@Override
	public String getDescriptionName(final boolean definite) {
<span class="nc" id="L809">		final String name = getName();</span>

<span class="nc bnc" id="L811" title="All 2 branches missed.">		if (name != null) {</span>
<span class="nc" id="L812">			return name;</span>
		} else {
<span class="nc" id="L814">			return super.getDescriptionName(definite);</span>
		}
	}

	/**
	 * Get the nicely formatted entity title/name.
	 *
	 * @return The title, or &lt;code&gt;null&lt;/code&gt; if unknown.
	 */
	@Override
	public String getTitle() {
<span class="fc" id="L825">		final String name = getName();</span>

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">		if (name != null) {</span>
<span class="fc" id="L828">			return name;</span>
		} else {
<span class="nc" id="L830">			return super.getTitle();</span>
		}
	}

	public void setFromCorpse(boolean fromCorpse) {
<span class="fc" id="L835">		this.fromCorpse = fromCorpse;</span>
<span class="fc" id="L836">	}</span>

	public boolean isFromCorpse() {
<span class="nc" id="L839">		return fromCorpse;</span>
	}

	/**
	 * gets the min level
	 *
	 * @return minLevel
	 */
	public int getMinLevel() {
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">		if (super.has(&quot;min_level&quot;)) {</span>
<span class="nc" id="L849">			return super.getInt(&quot;min_level&quot;);</span>
		} else {
<span class="fc" id="L851">			return 0;</span>
		}
	}
	
	
	/**
	 * opportunity to affect the player when equipped
	 * 
	 * currently returns boolean, to indicate whether it made any change
	 * 
	 * TODO: should this return some sort of undoable thing (if it can be undone?)
	 * 
	 * @param equipper entity equipping the item 
	 * @param slot slot where the item is equipped
	 * @return unknown, see the note above
	 */
	public boolean onEquipped(RPEntity equipper, String slot) {
		
		// this.prevEntity = equipper;
		// this.prevSlot   = slot;
		
<span class="fc" id="L872">		return false;</span>
	}

	/**
	 * item is about to be removed from owner.
	 * at this time, we are still owned by the original owner.
	 * opportunity to affect the player when equipped
	 * 
	 * note: use this.getContainerOwner(), rather than the equipper param
	 * 
	 * TODO: i don't think the parameters are necessary.  can get
	 *       owner and slot from Item api 
	 * @return needs documenting 
	 */
	public boolean onUnequipped() {
<span class="fc" id="L887">		return false;</span>
	}

	@Override
	public boolean onUsed(RPEntity user) {
<span class="fc bfc" id="L892" title="All 2 branches covered.">		if (useBehavior != null) {</span>
<span class="fc" id="L893">			return useBehavior.use(user, this);</span>
		}
		
<span class="fc" id="L896">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>