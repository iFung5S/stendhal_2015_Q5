<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SoundSystemNG.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.sound.system</a> &gt; <span class="el_source">SoundSystemNG.java</span></div><h1>SoundSystemNG.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.sound.system;

import games.stendhal.client.sound.facade.Time;
import games.stendhal.common.math.Dsp;
import games.stendhal.common.math.Numeric;
import games.stendhal.common.memory.Field;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;

import org.apache.log4j.Logger;

/**
 * Thread to manage sound output.
 * @author silvio
 */
public class SoundSystemNG extends Thread
{
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">	private static class SystemOutput</span>
	{
		final SourceDataLine mLine;                   // the line we will write the PCM data to
		final AudioFormat    mFormat;
<span class="fc" id="L42">        float[]              mAudioBuffer     = null; // the interleaved normalized audio data</span>
<span class="fc" id="L43">		int                  mNumSamples      = 0;    //</span>
<span class="fc" id="L44">        byte[]               mPCMBuffer       = null; // the uniform PCM data converted to the format defined in &quot;mAudioFormat&quot;</span>
<span class="fc" id="L45">		int                  mPCMBufferSize   = 0;    //</span>
<span class="fc" id="L46">		int                  mNumBytesWritten = 0;    // number of bytes from &quot;mPCMBuffer&quot; we have written to &quot;mLine&quot;</span>
<span class="fc" id="L47">		int                  mNumBytesToWrite = 0;</span>

		SystemOutput(SourceDataLine line)
<span class="fc" id="L50">		{</span>
<span class="pc bpc" id="L51" title="3 of 4 branches missed.">			assert line != null;</span>
<span class="fc" id="L52">			mLine   = line;</span>
<span class="fc" id="L53">			mFormat = line.getFormat();</span>
<span class="fc" id="L54">		}</span>

<span class="pc bpc" id="L56" title="1 of 4 branches missed.">		boolean isReady             () { return mLine.isOpen() &amp;&amp; mLine.isRunning();       }</span>
//		int     getNumSamples       () { return mNumSamples;                               }
<span class="fc" id="L58">		int     getNumChannels      () { return mFormat.getChannels();                     }</span>
<span class="fc" id="L59">		int     getSampleRate       () { return (int)mFormat.getSampleRate();              }</span>
<span class="fc" id="L60">		int     getNumBytesPerSample() { return mFormat.getSampleSizeInBits() / 8;         }</span>
<span class="fc" id="L61">		int     available           () { return mLine.available();                         }</span>
<span class="fc" id="L62">		int     getNumBytesToWrite  () { return mNumBytesToWrite;                          }</span>
<span class="fc" id="L63">		int     getFrameSize        () { return getNumBytesPerSample() * getNumChannels(); }</span>

		void close()
		{
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">			if(mLine.isOpen())</span>
<span class="nc" id="L68">				mLine.close();</span>
<span class="fc" id="L69">		}</span>

		boolean start()
		{
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">			if(!mLine.isOpen())</span>
			{
				try
				{
<span class="fc" id="L77">					mLine.open();</span>
				}
<span class="fc" id="L79">				catch(LineUnavailableException e) { return false; }</span>
<span class="pc" id="L80">				catch(SecurityException        e) { return false; }</span>
			}
			
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">			if(!mLine.isRunning())</span>
<span class="fc" id="L84">				mLine.start();</span>

<span class="fc" id="L86">			return true;</span>
		}
		
		void pause()
		{
<span class="nc bnc" id="L91" title="All 6 branches missed.">			if(mLine != null &amp;&amp; mLine.isOpen() &amp;&amp; mLine.isRunning())</span>
			{
<span class="nc" id="L93">				mLine.stop();</span>
<span class="nc" id="L94">				mLine.flush();</span>
			}
<span class="nc" id="L96">		}</span>

		void reset()
		{
<span class="fc" id="L100">			mNumBytesWritten = 0;</span>
<span class="fc" id="L101">			mNumSamples      = 0;</span>
<span class="fc" id="L102">			mPCMBufferSize   = 0;</span>
<span class="fc" id="L103">		}</span>

		void setBuffer(float[] buffer, int numSamples)
		{
<span class="pc bpc" id="L107" title="3 of 4 branches missed.">			assert numSamples &lt;= buffer.length;</span>
<span class="pc bpc" id="L108" title="3 of 4 branches missed.">			assert (numSamples % getNumChannels()) == 0;</span>

<span class="fc" id="L110">			mAudioBuffer = buffer;</span>
<span class="fc" id="L111">			mNumSamples  = numSamples;</span>
<span class="fc" id="L112">		}</span>

		void setNumBytesToWrite(int numBytesToWrite)
		{
<span class="fc" id="L116">			int frameSize = getNumBytesPerSample() * getNumChannels();</span>
			
<span class="fc" id="L118">			mNumBytesToWrite  = Math.min(numBytesToWrite, mLine.getBufferSize());</span>
<span class="fc" id="L119">			mNumBytesToWrite /= frameSize;</span>
<span class="fc" id="L120">			mNumBytesToWrite *= frameSize;</span>
<span class="fc" id="L121">		}</span>

		void convert()
        {
<span class="pc bpc" id="L125" title="3 of 4 branches missed.">            assert (mLine.getFormat().getSampleSizeInBits() % 8) == 0;</span>

<span class="fc" id="L127">            int numBytesPerSample = getNumBytesPerSample();</span>
<span class="fc" id="L128">			int numBytes          = numBytesPerSample * mNumSamples;</span>

<span class="fc" id="L130">			mPCMBuffer     = Field.expand(mPCMBuffer, numBytes, false);</span>
<span class="fc" id="L131">            mPCMBuffer     = Dsp.convertUniformPCM(mPCMBuffer, mAudioBuffer, mNumSamples, numBytesPerSample);</span>
<span class="fc" id="L132">			mPCMBufferSize = numBytes;</span>
<span class="fc" id="L133">        }</span>

		boolean write(int numBytes)
        {
<span class="fc" id="L137">			int frameSize                 = getNumBytesPerSample() * getNumChannels();</span>
<span class="fc" id="L138">			int numRemainingBytesInBuffer = mPCMBufferSize - mNumBytesWritten;</span>
<span class="fc" id="L139">			int available                 = mLine.available();</span>

			// ATTENTION: this should never happen but if it happens, it is likely
			//            that the mLine.available() method returns an &quot;unsigned int&quot;
			//            from its native C method and thus will be handled as an
			//            &quot;signed int&quot; in java. for a fix we simply set the value
			//            to the highest possible signed interger value
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">			if(available &lt; 0)</span>
<span class="nc" id="L147">				available = Integer.MAX_VALUE;</span>

<span class="fc" id="L149">			numBytes  = Math.min(numBytes, numRemainingBytesInBuffer);</span>
<span class="fc" id="L150">			numBytes  = Math.min(numBytes, mNumBytesToWrite         );</span>
<span class="fc" id="L151">			numBytes  = Math.min(numBytes, available                );</span>
<span class="fc" id="L152">			numBytes /= frameSize;</span>
<span class="fc" id="L153">			numBytes *= frameSize;</span>
<span class="fc" id="L154">			numBytes  = mLine.write(mPCMBuffer, mNumBytesWritten, numBytes);</span>

			// ATTENTION: if no audio data was written to the output line even though
			//            the line is not full (mLine.available() is not 0)
			//            the line blocks for some (unknown) reason
			//            the simplest workaround here is to simply discard the remaining
			//            audio data and pretend everything was written (return false)
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">			if(available &gt; 0 &amp;&amp; numBytes == 0)</span>
<span class="nc" id="L162">				return false;</span>

<span class="fc" id="L164">			mNumBytesWritten          += numBytes;</span>
<span class="fc" id="L165">			mNumBytesToWrite          -= numBytes;</span>
<span class="fc" id="L166">			numRemainingBytesInBuffer -= numBytes;</span>
			
<span class="fc bfc" id="L168" title="All 2 branches covered.">			if(numRemainingBytesInBuffer &lt; frameSize)</span>
<span class="fc" id="L169">				reset();</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">			if(mNumBytesToWrite &lt; frameSize)</span>
<span class="fc" id="L172">				return false;</span>
			
<span class="fc" id="L174">			return true;</span>
        }
	}

<span class="nc bnc" id="L178" title="All 2 branches missed.">	public static class Output extends SignalProcessor</span>
	{
		AudioFormat         mAudioFormat;
<span class="nc" id="L181">		float[]             mAudioBuffer     = null; // the interleaved normalized PCM data</span>
<span class="nc" id="L182">		float[]             mMixingBuffer    = null;</span>
<span class="nc" id="L183">		int                 mNumSamples      = 0;    // the number of samples received</span>
<span class="nc" id="L184">		int                 mNumSamplesMixed = 0;</span>
<span class="nc" id="L185">		final AtomicInteger mLevel           = new AtomicInteger(0);</span>
<span class="nc" id="L186">		final AtomicInteger mIntensity       = new AtomicInteger(PRECISION);</span>

		Output(AudioFormat format, int level)
<span class="nc" id="L189">		{</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">			assert format != null;</span>
<span class="nc" id="L191">			mAudioFormat = format;</span>
<span class="nc" id="L192">			mLevel.set(level);</span>
<span class="nc" id="L193">		}</span>

<span class="nc" id="L195">		public void  setIntensity(float intensity) { mIntensity.set(Numeric.floatToInt(intensity, PRECISION)); }</span>
<span class="nc" id="L196">		public float getIntensity()                { return Numeric.intToFloat(mIntensity.get(), PRECISION);   }</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">		boolean receivedData   () { return mNumSamples &gt; 0;                   }</span>
<span class="nc" id="L199">		int     getNumChannels () { return mAudioFormat.getChannels();        }</span>
<span class="nc" id="L200">		int     getSampleRate  () { return (int)mAudioFormat.getSampleRate(); }</span>
<span class="nc" id="L201">		int     getLayer       () { return mLevel.get();                      }</span>
<span class="nc" id="L202">		float[] getMixingBuffer() { return mMixingBuffer;                     }</span>

		void reset()
		{
<span class="nc" id="L206">			mNumSamples      = 0;</span>
<span class="nc" id="L207">			mNumSamplesMixed = 0;</span>
<span class="nc" id="L208">		}</span>

		void clearMixingBuffer(int bufferSize)
		{
<span class="nc" id="L212">			mMixingBuffer = Field.expand(mMixingBuffer, bufferSize, false);</span>
<span class="nc" id="L213">			Arrays.fill(mMixingBuffer, 0.0f);</span>
<span class="nc" id="L214">		}</span>
		
		void setBuffer(float[] buffer, int numSamples)
		{
<span class="nc bnc" id="L218" title="All 6 branches missed.">			assert (buffer == null) || (numSamples &lt;= buffer.length);</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">			assert (numSamples % getNumChannels()) == 0;</span>

<span class="nc" id="L221">			mAudioBuffer = buffer;</span>
<span class="nc" id="L222">			mNumSamples  = numSamples;</span>
<span class="nc" id="L223">		}</span>
		
		boolean mix(float[] buffer, int size)
		{
<span class="nc" id="L227">			int offset          = 0;</span>
<span class="nc" id="L228">			int numSamplesToMix = size;</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">			while(numSamplesToMix &gt; 0)</span>
			{
<span class="nc bnc" id="L232" title="All 2 branches missed.">				if(!receivedData())</span>
<span class="nc" id="L233">					request();</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">				if(!receivedData())</span>
<span class="nc" id="L236">					return false;</span>

<span class="nc" id="L238">				int numSamples = mNumSamples - mNumSamplesMixed;</span>
<span class="nc" id="L239">				numSamples = Math.min(numSamples, numSamplesToMix);</span>

<span class="nc" id="L241">				Dsp.mixAudioData(buffer, offset, mAudioBuffer, mNumSamplesMixed, numSamples, Numeric.intToFloat(mIntensity.get(), PRECISION));</span>

<span class="nc" id="L243">				offset           += numSamples;</span>
<span class="nc" id="L244">				mNumSamplesMixed += numSamples;</span>
<span class="nc" id="L245">				numSamplesToMix  -= numSamples;</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">				if(mNumSamples == mNumSamplesMixed)</span>
<span class="nc" id="L248">					reset();</span>
<span class="nc" id="L249">			}</span>

<span class="nc" id="L251">			return true;</span>
		}

		@Override
        protected void modify(float[] buffer, int frames, int channels, int rate)
        {
<span class="nc bnc" id="L257" title="All 8 branches missed.">            if (buffer != null &amp;&amp; frames &gt; 0 &amp;&amp; channels &gt; 0 &amp;&amp; rate &gt; 0)</span>
            {
<span class="nc bnc" id="L259" title="All 4 branches missed.">                assert (frames * channels) &lt;= buffer.length;</span>
<span class="nc" id="L260">				buffer = Dsp.convertChannels(buffer, frames, channels, getNumChannels());</span>

<span class="nc" id="L262">				setBuffer(buffer, (frames * getNumChannels()));</span>

<span class="nc" id="L264">				buffer = Dsp.convertSampleRate(buffer, (frames * channels), channels, rate, getSampleRate());</span>

<span class="nc" id="L266">				float ratio = (float)frames / (float)rate;</span>
<span class="nc" id="L267">				setBuffer(buffer, (int)(ratio * getSampleRate() * channels));</span>
<span class="nc" id="L268">			}</span>
			else
			{
<span class="nc" id="L271">				setBuffer(null, 0);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">				assert false: &quot;could not convert sample rate&quot;;</span>
			}
<span class="nc" id="L274">        }</span>
	}

	private final static int    STATE_EXITING   = 0;
	private final static int    STATE_RUNNING   = 1;
	private final static int    STATE_PAUSING   = 2;
	private final static int    STATE_SUSPENDED = 3;
<span class="fc" id="L281">	private final static Time   ZERO_DURATION   = new Time();</span>
<span class="fc" id="L282">	private final static Time   SLEEP_DURATION  = new Time(100, Time.Unit.MILLI);</span>
	private final static int    PRECISION       = 1000000;
<span class="fc" id="L284">	private final static Logger logger          = Logger.getLogger(SoundSystemNG.class);</span>

<span class="pc" id="L286">	private final LinkedList&lt;Output&gt;     mMixerOutputs          = new LinkedList&lt;Output&gt;();</span>
<span class="pc" id="L287">	private volatile SystemOutput        mSystemOutput          = null;</span>
<span class="pc" id="L288">    private volatile AudioFormat         mAudioFormat           = null;</span>
<span class="pc" id="L289">    private final AtomicReference&lt;Time&gt;  mBufferDuration        = new AtomicReference&lt;Time&gt;(null);</span>
<span class="pc" id="L290">    private final AtomicBoolean          mUseDynamicLoadScaling = new AtomicBoolean(false);</span>
<span class="pc" id="L291">	private final AtomicReference&lt;Time&gt;  mStateChangeDelay      = new AtomicReference&lt;Time&gt;(ZERO_DURATION);</span>
<span class="pc" id="L292">	private final AtomicInteger          mTargetSystemState     = new AtomicInteger(STATE_EXITING);</span>
<span class="pc" id="L293">	private final AtomicInteger          mCurrentSystemState    = new AtomicInteger(STATE_EXITING);</span>
<span class="pc" id="L294">	private float[]                      mMixBuffer             = null;</span>

	public SoundSystemNG(AudioFormat audioFormat, Time bufferDuration)
<span class="nc" id="L297">	{</span>
<span class="nc" id="L298">		init(null, audioFormat, bufferDuration);</span>
<span class="nc" id="L299">	}</span>

    public SoundSystemNG(SourceDataLine outputLine, Time bufferDuration)
<span class="fc" id="L302">    {</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if(outputLine == null)</span>
<span class="nc" id="L304">			throw new IllegalArgumentException(&quot;outputLine argument must not be null&quot;);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">		if(bufferDuration == null)</span>
<span class="nc" id="L306">			throw new IllegalArgumentException(&quot;bufferDuration argument must not be null&quot;);</span>

<span class="fc" id="L308">		init(outputLine, outputLine.getFormat(), bufferDuration);</span>
<span class="fc" id="L309">    }</span>

	public void suspend(Time delay, boolean closeSystemOutput)
	{
<span class="nc bnc" id="L313" title="All 2 branches missed.">		if(closeSystemOutput)</span>
<span class="nc" id="L314">			changeSystemState(STATE_SUSPENDED, delay);</span>
		else
<span class="nc" id="L316">			changeSystemState(STATE_PAUSING, delay);</span>
<span class="nc" id="L317">	}</span>

	public void proceed(Time delay)
	{
<span class="nc" id="L321">		changeSystemState(STATE_RUNNING, delay);</span>
<span class="nc" id="L322">	}</span>

	public void proceed(Time delay, SourceDataLine outputLine)
    {
<span class="nc bnc" id="L326" title="All 4 branches missed.">		if(outputLine != null &amp;&amp; !outputLine.getFormat().matches(mAudioFormat))</span>
<span class="nc" id="L327">			throw new IllegalArgumentException(&quot;outputLine has the wrong audio format&quot;);</span>
		
<span class="nc" id="L329">		init(outputLine, mAudioFormat, mBufferDuration.get());</span>
<span class="nc" id="L330">		changeSystemState(STATE_RUNNING, delay);</span>
<span class="nc" id="L331">	}</span>
	
	public boolean isRunning()
	{
<span class="nc bnc" id="L335" title="All 2 branches missed.">		return mCurrentSystemState.get() == STATE_RUNNING;</span>
	}

	public Output openOutput(int layerID, SignalProcessor ...processorChain)
	{
<span class="nc" id="L340">		Output output = new Output(mAudioFormat, layerID);</span>
<span class="nc" id="L341">		SignalProcessor.createChain(Field.append(processorChain, processorChain.length, output));</span>

<span class="nc" id="L343">		synchronized(mMixerOutputs)</span>
		{
<span class="nc" id="L345">			mMixerOutputs.add(output);</span>
<span class="nc" id="L346">		}</span>

<span class="nc" id="L348">		logger.debug(&quot;opening a mixer output (using manual mixing)&quot;);</span>
<span class="nc" id="L349">		return output;</span>
	}

    public void closeOutput(Output output)
    {
<span class="nc bnc" id="L354" title="All 2 branches missed.">		if(output != null)</span>
		{
<span class="nc" id="L356">			output.disconnect();</span>

<span class="nc" id="L358">			synchronized(mMixerOutputs)</span>
			{
<span class="nc" id="L360">				logger.debug(&quot;closing a mixer output&quot;);</span>
<span class="nc" id="L361">				mMixerOutputs.remove(output);</span>
<span class="nc" id="L362">			}</span>
		}
<span class="nc" id="L364">    }</span>

    public void closeAllOutputs()
    {
<span class="nc" id="L368">		logger.debug(&quot;closing all outputs excluding the output for manual mixing&quot;);</span>

<span class="nc" id="L370">		synchronized(mMixerOutputs)</span>
		{
<span class="nc" id="L372">			mMixerOutputs.clear();</span>
<span class="nc" id="L373">		}</span>
<span class="nc" id="L374">    }</span>

    public void exit(Time delay)
    {
<span class="nc bnc" id="L378" title="All 2 branches missed.">		logger.info(&quot;stopping sound system after &quot; + ((delay != null) ? delay.getInMilliSeconds() : 0) + &quot;ms&quot;);</span>
<span class="nc" id="L379">		changeSystemState(STATE_EXITING, delay);</span>
<span class="nc" id="L380">    }</span>

    @Override
    public void run()
    {
<span class="fc" id="L385">		class StateChanger</span>
		{
<span class="fc" id="L387">			long    mSystemTime  = 0;</span>
<span class="fc" id="L388">			boolean mChangeState = false;</span>

			void processStateChange()
			{
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">				if(!mChangeState)</span>
				{
<span class="fc bfc" id="L394" title="All 2 branches covered.">					if(mCurrentSystemState.get() != mTargetSystemState.get())</span>
					{
<span class="fc" id="L396">						logger.debug(&quot;change state&quot;);</span>
						
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">						if(mStateChangeDelay.get().getInNanoSeconds() &lt;= 0)</span>
						{
<span class="fc" id="L400">							mCurrentSystemState.set(mTargetSystemState.get());</span>
<span class="fc" id="L401">							return;</span>
						}

<span class="nc" id="L404">						mSystemTime  = System.nanoTime();</span>
<span class="nc" id="L405">						mChangeState = true;</span>
					}
				}
				else
				{
<span class="nc bnc" id="L410" title="All 2 branches missed.">					if((System.nanoTime() - mSystemTime) &gt;= mStateChangeDelay.get().getInNanoSeconds())</span>
					{
<span class="nc" id="L412">						mCurrentSystemState.set(mTargetSystemState.get());</span>
<span class="nc" id="L413">						mChangeState = false;</span>
					}
				}
<span class="fc" id="L416">			}</span>
		}

<span class="fc" id="L419">        double       averageTimeToProcessSound = 0;</span>
<span class="fc" id="L420">        double       multiplicator             = 0.995;</span>
<span class="fc" id="L421">		StateChanger stateChanger              = new StateChanger();</span>

<span class="fc" id="L423">		mCurrentSystemState.set(STATE_RUNNING);</span>
<span class="fc" id="L424">		mTargetSystemState.set(STATE_RUNNING);</span>
<span class="fc" id="L425">		mStateChangeDelay.set(ZERO_DURATION);</span>

<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        while(mCurrentSystemState.get() != STATE_EXITING)</span>
        {
<span class="fc" id="L429">			stateChanger.processStateChange();</span>

<span class="pc bpc" id="L431" title="2 of 4 branches missed.">			switch(mCurrentSystemState.get())</span>
			{
			case STATE_RUNNING:
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">				if(mSystemOutput == null)</span>
				{
<span class="nc" id="L436">					changeSystemState(STATE_SUSPENDED, null);</span>
<span class="nc" id="L437">					logger.warn(&quot;no output line was opened. sound system will be suspended&quot;);</span>
				}
<span class="fc bfc" id="L439" title="All 4 branches covered.">				else if(!mSystemOutput.isReady() &amp;&amp; !mSystemOutput.start())</span>
				{
<span class="fc" id="L441">					changeSystemState(STATE_SUSPENDED, null);</span>
<span class="fc" id="L442">					logger.warn(&quot;suspend sound system due to unavailability of an output line&quot;);</span>
				}
				else
				{
<span class="fc" id="L446">					long duration       = System.nanoTime();</span>
<span class="fc" id="L447">					long bufferDuration = mBufferDuration.get().getInNanoSeconds();</span>

<span class="fc" id="L449">					processOutputs();</span>

<span class="pc bpc" id="L451" title="1 of 2 branches missed.">					if(mUseDynamicLoadScaling.get())</span>
					{
<span class="nc" id="L453">						duration                  = System.nanoTime() - duration;</span>
<span class="nc" id="L454">						averageTimeToProcessSound = (averageTimeToProcessSound + duration) / 2.0;</span>

<span class="nc bnc" id="L456" title="All 2 branches missed.">						if(averageTimeToProcessSound &gt; bufferDuration)</span>
<span class="nc" id="L457">							averageTimeToProcessSound = bufferDuration;</span>

<span class="nc" id="L459">						long nanos = (long)((bufferDuration - averageTimeToProcessSound) * multiplicator);</span>
<span class="nc" id="L460">						threadSleep(nanos);</span>
					}
				}
<span class="fc" id="L463">				break;</span>

			case STATE_PAUSING:
<span class="nc" id="L466">				mSystemOutput.pause();</span>
<span class="nc" id="L467">				threadSleep(SLEEP_DURATION.getInNanoSeconds());</span>
<span class="nc" id="L468">				break;</span>

			case STATE_SUSPENDED:
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">				if(mSystemOutput != null)</span>
<span class="fc" id="L472">					mSystemOutput.close();</span>
<span class="fc" id="L473">				threadSleep(SLEEP_DURATION.getInNanoSeconds());</span>
<span class="fc" id="L474">				break;</span>
			}
        }

<span class="nc" id="L478">        closeAllOutputs();</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">		if(mSystemOutput != null)</span>
<span class="nc" id="L481">			mSystemOutput.close();</span>
<span class="nc" id="L482">    }</span>

	private void changeSystemState(int state, Time delay)
	{
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">		if(delay == null)</span>
<span class="fc" id="L487">			delay = ZERO_DURATION;</span>
		else
<span class="nc" id="L489">			delay = delay.clone();</span>

<span class="fc" id="L491">		mStateChangeDelay.set(delay);</span>
<span class="fc" id="L492">		mTargetSystemState.set(state);</span>
<span class="fc" id="L493">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void processOutputs()
	{
		LinkedList&lt;Output&gt; mixerOutputs;
<span class="fc" id="L499">		SystemOutput       systemOutput = mSystemOutput;</span>

<span class="fc" id="L501">		synchronized(mMixerOutputs)</span>
		{
<span class="fc" id="L503">			mixerOutputs = (LinkedList&lt;Output&gt;)mMixerOutputs.clone();</span>
<span class="pc" id="L504">		}</span>

<span class="fc" id="L506">		int sampleRate        = systemOutput.getSampleRate();</span>
<span class="fc" id="L507">		int numBytesPerSample = systemOutput.getNumBytesPerSample();</span>
<span class="fc" id="L508">		int numChannels       = systemOutput.getNumChannels();</span>
<span class="fc" id="L509">		int numBytesToWrite   = (int)(mBufferDuration.get().getInSamples(sampleRate) * numChannels * numBytesPerSample);</span>

<span class="fc" id="L511">		systemOutput.setNumBytesToWrite(numBytesToWrite);</span>
<span class="fc" id="L512">		numBytesToWrite = systemOutput.getNumBytesToWrite();</span>

<span class="fc" id="L514">		int numSamples = numBytesToWrite / numBytesPerSample;</span>

<span class="fc" id="L516">		mMixBuffer = Field.expand(mMixBuffer, numSamples, false);</span>
<span class="fc" id="L517">		Arrays.fill(mMixBuffer, 0, numSamples, 0.0f);</span>

<span class="pc bpc" id="L519" title="1 of 2 branches missed.">		for(Output output: mixerOutputs)</span>
<span class="nc" id="L520">			output.mix(mMixBuffer, numSamples);</span>

<span class="fc" id="L522">		systemOutput.setBuffer(mMixBuffer, numSamples);</span>
<span class="fc" id="L523">		systemOutput.convert();</span>

<span class="fc" id="L525">		boolean lineIsBlocked = false;</span>

<span class="fc bfc" id="L527" title="All 2 branches covered.">		while(systemOutput.write(Integer.MAX_VALUE))</span>
		{
<span class="fc bfc" id="L529" title="All 2 branches covered.">			if(systemOutput.available() &lt; systemOutput.getFrameSize())</span>
			{
				// if the line is full even though we waited a few milliseconds
				// we will asume that the line is blocked for some (unknown) reason
				// so we will discard the rest of the non written audio data and return
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">				if(lineIsBlocked)</span>
<span class="nc" id="L535">					return;</span>

				// if the buffer of the output line is full we will wait a few milliseconds
				// to let the system mixer process the audio data
<span class="fc" id="L539">				threadSleep(SLEEP_DURATION.getInNanoSeconds());</span>
<span class="fc" id="L540">				lineIsBlocked = true;</span>
			}
			else
			{
<span class="fc" id="L544">				lineIsBlocked = false;</span>
			}
		}
<span class="fc" id="L547">	}</span>

	private void init(SourceDataLine line, AudioFormat audioFormat, Time bufferDuration)
	{
<span class="fc" id="L551">		mBufferDuration.set(bufferDuration);</span>
<span class="fc" id="L552">        mAudioFormat = audioFormat;</span>

<span class="pc bpc" id="L554" title="1 of 2 branches missed.">		if(line != null)</span>
		{
<span class="fc" id="L556">			logger.info(&quot;opening sound system with line \&quot;&quot; + line + &quot;\&quot; and audio format \&quot;&quot; + audioFormat + &quot;\&quot;&quot;);</span>
<span class="fc" id="L557">			mSystemOutput = new SystemOutput(line);</span>
		}
		else
		{
<span class="nc" id="L561">			mSystemOutput = null;</span>
		}
<span class="fc" id="L563">	}</span>

    private void threadSleep(long nanos)
    {
        try
        {
<span class="fc" id="L569">            long millis = nanos / Time.Unit.MILLI.getNanos();</span>

<span class="fc" id="L571">            nanos %= Time.Unit.MILLI.getNanos();</span>

<span class="fc" id="L573">            sleep(millis, (int)nanos);</span>
        }
<span class="pc" id="L575">        catch(InterruptedException ex) { }</span>
<span class="fc" id="L576">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>