<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MazeGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.maps.quests.maze</a> &gt; <span class="el_source">MazeGenerator.java</span></div><h1>MazeGenerator.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.maps.quests.maze;

import games.stendhal.common.MathHelper;
import games.stendhal.common.Rand;
import games.stendhal.common.color.ARGB;
import games.stendhal.common.color.HSL;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.common.tiled.LayerDefinition;
import games.stendhal.common.tiled.StendhalMapStructure;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.Spot;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.core.engine.ZoneAttributes;
import games.stendhal.server.core.engine.dbcommand.WriteHallOfFamePointsCommand;
import games.stendhal.server.core.events.MovementListener;
import games.stendhal.server.entity.ActiveEntity;
import games.stendhal.server.entity.item.Corpse;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.mapstuff.portal.Portal;
import games.stendhal.server.entity.mapstuff.portal.Teleporter;
import games.stendhal.server.entity.mapstuff.sound.BackgroundMusicSource;
import games.stendhal.server.entity.npc.action.IncrementQuestAction;
import games.stendhal.server.entity.npc.action.SetQuestAction;
import games.stendhal.server.entity.player.Player;
import games.stendhal.server.util.TimeUtil;

import java.awt.Point;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import marauroa.common.game.RPObject;
import marauroa.server.db.command.DBCommandQueue;

import org.apache.log4j.Logger;

/**
 * A random maze zone.
 */
public class MazeGenerator {
	/**
	 * Time in minutes how long the player can spend in the maze
	 * to earn &lt;code&gt;DEFAULT_REWARD_POINTS&lt;/code&gt;. Shorter times
	 * get a higher reward, and longer times lower.
	 */
	private static final int DEFAULT_SOLVING_TIME = 5;
	/**
	 * Amount of points for solving the maze in &lt;code&gt;DEFAULT_SOLVING_TIME&lt;/code&gt;.
	 */
	private static final int DEFAULT_REWARD_POINTS = 100;
	private static final int REWARD_XP = 30;
<span class="fc" id="L68">	private static final Logger logger = Logger.getLogger(MazeGenerator.class);</span>

	private static final int WALL_THICKNESS = 2;
<span class="fc" id="L71">	private static final String[] prizes = {</span>
		&quot;summon scroll&quot;,
		&quot;home scroll&quot;,
		&quot;ados city scroll&quot;,
		&quot;nalwor city scroll&quot;,
		&quot;kirdneh city scroll&quot;,
		&quot;kalavan city scroll&quot;,
		&quot;empty scroll&quot;
	};

	/** The music track to be played in the maze */
	private static final String MUSIC_TRACK = &quot;medieval_harp&quot;;
	/** Volume of the music */
	private static final int MUSIC_VOLUME = 80;

	private final String name;
	private final int width, height;
	private Point startPosition;
<span class="fc" id="L89">	private List&lt;Point&gt; corners = null;</span>

	private final StendhalMapStructure mapStructure;
<span class="fc" id="L92">	private StendhalRPZone	zone = null;</span>

	/** The name of the zone where to return a leaving player */
	private String returnZoneName;
	/** The coordinates where to return a leaving player */
	private int returnX, returnY;

	/** The time when the player was sent to the maze. */
	private long timeStamp;
	private MazeSign sign;

	private Teleporter portal;

	/**
	 * Create a maze.
	 *
	 * @param name Name of the maze to be used as the zone name
	 * @param width Width of the generated zone
	 * @param height Height of the generated zone
	 */
<span class="fc" id="L112">	public MazeGenerator(String name, int width, int height) {</span>
<span class="fc" id="L113">		this.name = name;</span>
<span class="fc" id="L114">		this.width = width;</span>
<span class="fc" id="L115">		this.height = height;</span>

<span class="fc" id="L117">		mapStructure = generateMapStructure(width, height);</span>
<span class="fc" id="L118">	}</span>

	/**
	 * Get the location where to teleport a player.
	 *
	 * @return the intended starting location of the maze
	 */
	public Point getStartPosition() {
<span class="fc bfc" id="L126" title="All 2 branches covered.">		if (startPosition == null) {</span>
<span class="fc" id="L127">			startPosition = Rand.rand(getCorners());</span>
		}

<span class="fc" id="L130">		return startPosition;</span>
	}

	/**
	 * Set the location where a player logging out or returning
	 * via a portal should be placed.
	 *
	 * @param zoneName Name of the return zone
	 * @param x X coordinate
	 * @param y Y coordinate
	 */
	public void setReturnLocation(String zoneName, int x, int y) {
<span class="fc" id="L142">		returnZoneName= zoneName;</span>
<span class="fc" id="L143">		returnX = x;</span>
<span class="fc" id="L144">		returnY = y;</span>
<span class="fc" id="L145">	}</span>

	/**
	 * Set the sign for hall of fame.
	 * @param sign sign
	 */
	public void setSign(MazeSign sign) {
<span class="fc" id="L152">		this.sign = sign;</span>
<span class="fc" id="L153">	}</span>

	/**
	 * Get the zone generated by this maze instance.
	 *
	 * @return The generated zone
	 */
	public StendhalRPZone getZone() {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">		if (zone == null) {</span>
<span class="fc" id="L162">			zone = generateZone();</span>
		}
<span class="fc" id="L164">		return zone;</span>
	}

	/**
	 * Start timing how long the player takest to solve the maze.
	 */
	public void startTiming() {
<span class="fc" id="L171">		timeStamp = System.currentTimeMillis();</span>
<span class="fc" id="L172">	}</span>

	/**
	 * Generate the map.
	 * 
	 * @param width
	 * @param height
	 * @return map
	 */
	private StendhalMapStructure generateMapStructure(int width, int height) {
<span class="fc" id="L182">		LayerDefinition floor = new LayerDefinition(width, height);</span>
<span class="fc" id="L183">		floor.setName(&quot;0_floor&quot;);</span>
<span class="fc" id="L184">		floor.build();</span>

<span class="fc" id="L186">		LayerDefinition terrain = new LayerDefinition(width, height);</span>
<span class="fc" id="L187">		terrain.setName(&quot;1_terrain&quot;);</span>

<span class="fc" id="L189">		LayerDefinition object = new LayerDefinition(width, height);</span>
<span class="fc" id="L190">		object.setName(&quot;2_object&quot;);</span>

<span class="fc" id="L192">		LayerDefinition roof = new LayerDefinition(width, height);</span>
<span class="fc" id="L193">		roof.setName(&quot;3_roof&quot;);</span>

<span class="fc" id="L195">		LayerDefinition collision = new LayerDefinition(width, height);</span>
<span class="fc" id="L196">		collision.setName(&quot;collision&quot;);</span>

<span class="fc" id="L198">		LayerDefinition protection = new LayerDefinition(width, height);</span>
<span class="fc" id="L199">		protection.setName(&quot;protection&quot;);</span>

<span class="fc" id="L201">		StendhalMapStructure map = new StendhalMapStructure(width, height);</span>

<span class="fc" id="L203">		map.addLayer(floor);</span>
<span class="fc" id="L204">		map.addLayer(terrain);</span>
<span class="fc" id="L205">		map.addLayer(object);</span>
<span class="fc" id="L206">		map.addLayer(roof);</span>
<span class="fc" id="L207">		map.addLayer(collision);</span>
<span class="fc" id="L208">		map.addLayer(protection);</span>

<span class="fc" id="L210">		generateCollisions(collision);</span>

		// solves client caching, but makes other trouble
		//String md5 = Hash.toHexString(Hash.hash(collision.exposeRaw()));
		//name += &quot;_&quot; + md5;

<span class="fc" id="L216">		MazePainter painter = new MazePainter();</span>
<span class="fc" id="L217">		painter.paint(map);</span>
<span class="fc" id="L218">		Point pos = getPortalPosition();</span>
<span class="fc" id="L219">		painter.paintPortal(map, pos.x, pos.y);</span>

<span class="fc" id="L221">		return map;</span>
	}

	/**
	 * Generate random maze collisions.
	 * 
	 * @param layer collision layer
	 */
	private void generateCollisions(LayerDefinition layer) {
<span class="fc" id="L230">		layer.build();</span>

		// create a grid
<span class="fc bfc" id="L233" title="All 2 branches covered.">		for (int i = 0; i &lt; width; i++) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">			for (int j = 0; j &lt; height; j++) {</span>
<span class="fc bfc" id="L235" title="All 4 branches covered.">				if (!((i % (WALL_THICKNESS + 1) == WALL_THICKNESS) &amp;&amp; (j % (WALL_THICKNESS + 1) == WALL_THICKNESS))) {</span>
<span class="fc" id="L236">					setCollide(layer, i, j, true);</span>
				}
			}
		}

<span class="fc" id="L241">		burrowCave(getStartPosition(), layer);</span>
<span class="fc" id="L242">		widenCorners(layer);</span>
<span class="fc" id="L243">	}</span>

	/**
	 * Make the tunnels. The actual maze generation algorithm.
	 *
	 * @param point Starting point for the tunnels
	 * @param layer Collision layer
	 */
	private void burrowCave(Point point, LayerDefinition layer) {
<span class="fc" id="L252">		Queue&lt;Point&gt; branchPoints = new LinkedList&lt;Point&gt;();</span>
<span class="fc" id="L253">		HashSet&lt;Point&gt; visited = new HashSet&lt;Point&gt;();</span>
<span class="fc" id="L254">		branchPoints.add(point);</span>
<span class="fc" id="L255">		List&lt;Point&gt; neighbours = getUnvisitedNeighbours(point, visited);</span>

		do {
<span class="fc" id="L258">			visited.add(point);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">			if (neighbours.size() &gt; 0) {</span>
<span class="fc" id="L260">				Point next = Rand.rand(neighbours);</span>
<span class="fc" id="L261">				branchPoints.add(next);</span>

				// Knock down the wall between
<span class="fc" id="L264">				int diffx = Integer.signum(next.x - point.x);</span>
<span class="fc" id="L265">				int diffy = Integer.signum(next.y - point.y);</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">				for (int i = 1; i &lt;= WALL_THICKNESS; i++) {</span>
<span class="fc" id="L267">					setCollide(layer, point.x + i * diffx, point.y + i * diffy, false);</span>
				}

<span class="fc" id="L270">				point = next;</span>
<span class="fc" id="L271">			} else {</span>
				// branch from the beginning to make nice and long tunnels
<span class="fc" id="L273">				point = branchPoints.poll();</span>
			}

<span class="fc" id="L276">			neighbours = getUnvisitedNeighbours(point, visited);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">		} while (point != null);</span>
<span class="fc" id="L278">	}</span>

	/**
	 * Get the unvisited neighbors of a node.
	 * 
	 * @param point point whose neighbors should be checked 
	 * @param visited all visited locations
	 * @return list of unvisited neighbors
	 */
	private List&lt;Point&gt; getUnvisitedNeighbours(Point point, HashSet&lt;Point&gt; visited) {
<span class="fc bfc" id="L288" title="All 2 branches covered.">		if (point == null) {</span>
<span class="fc" id="L289">			return null;</span>
		}

<span class="fc" id="L292">		List&lt;Point&gt; neighbours = new ArrayList&lt;Point&gt;(4);</span>

<span class="fc" id="L294">		Point left = new Point(point.x - (WALL_THICKNESS +1), point.y);</span>
<span class="fc bfc" id="L295" title="All 4 branches covered.">		if ((left.x &gt; 0) &amp;&amp; !visited.contains(left)) {</span>
<span class="fc" id="L296">			neighbours.add(left);</span>
		}

<span class="fc" id="L299">		Point right = new Point(point.x + (WALL_THICKNESS + 1), point.y);</span>
<span class="fc bfc" id="L300" title="All 4 branches covered.">		if ((right.x &lt; width) &amp;&amp; !visited.contains(right)) {</span>
<span class="fc" id="L301">			neighbours.add(right);</span>
		}

<span class="fc" id="L304">		Point up = new Point(point.x, point.y - (WALL_THICKNESS +1));</span>
<span class="fc bfc" id="L305" title="All 4 branches covered.">		if ((up.y &gt; 0) &amp;&amp; !visited.contains(up)) {</span>
<span class="fc" id="L306">			neighbours.add(up);</span>
		}

<span class="fc" id="L309">		Point down = new Point(point.x, point.y + (WALL_THICKNESS +1));</span>
<span class="fc bfc" id="L310" title="All 4 branches covered.">		if ((down.y &lt; height) &amp;&amp; !visited.contains(down)) {</span>
<span class="fc" id="L311">			neighbours.add(down);</span>
		}

<span class="fc" id="L314">		return neighbours;</span>
	}

	/**
	 * Enlarge the corridors at the map corners. Creates the &quot;rooms&quot; for the
	 * portal and the rewards.
	 * 
	 * @param layer collision layer
	 */
	private void widenCorners(LayerDefinition layer) {
		// top left corner
<span class="fc" id="L325">		setCollide(layer, WALL_THICKNESS - 1, WALL_THICKNESS - 1, false);</span>
<span class="fc" id="L326">		setCollide(layer, WALL_THICKNESS - 1, WALL_THICKNESS, false);</span>
<span class="fc" id="L327">		setCollide(layer, WALL_THICKNESS, WALL_THICKNESS - 1, false);</span>
		// top right corner
<span class="fc" id="L329">		setCollide(layer, width - width % (WALL_THICKNESS + 1) - 1, WALL_THICKNESS - 1, false);</span>
<span class="fc" id="L330">		setCollide(layer, width - width % (WALL_THICKNESS + 1), WALL_THICKNESS - 1, false);</span>
<span class="fc" id="L331">		setCollide(layer, width - width % (WALL_THICKNESS + 1), WALL_THICKNESS, false);</span>
		// bottom left corner
<span class="fc" id="L333">		setCollide(layer, WALL_THICKNESS - 1, height - height % (WALL_THICKNESS + 1) - 1, false);</span>
<span class="fc" id="L334">		setCollide(layer, WALL_THICKNESS - 1, height - height % (WALL_THICKNESS + 1), false);</span>
<span class="fc" id="L335">		setCollide(layer, WALL_THICKNESS, height - height % (WALL_THICKNESS + 1), false);</span>
		// bottom right corner
<span class="fc" id="L337">		setCollide(layer, width - width % (WALL_THICKNESS + 1) - 1, height - height % (WALL_THICKNESS + 1), false);</span>
<span class="fc" id="L338">		setCollide(layer, width - width % (WALL_THICKNESS + 1), height - height % (WALL_THICKNESS + 1), false);</span>
<span class="fc" id="L339">		setCollide(layer, width - width % (WALL_THICKNESS + 1), height - height % (WALL_THICKNESS + 1) - 1, false);</span>
<span class="fc" id="L340">	}</span>

	/**
	 * Get the map corner locations.
	 * 
	 * @return map corners
	 */
	private List&lt;Point&gt; getCorners() {
<span class="fc bfc" id="L348" title="All 2 branches covered.">		if (corners == null) {</span>
<span class="fc" id="L349">			corners = new LinkedList&lt;Point&gt;();</span>
			// Order is important. Opposite corners should not be next to each other
<span class="fc" id="L351">			corners.add(new Point(WALL_THICKNESS, WALL_THICKNESS));</span>
<span class="fc" id="L352">			corners.add(new Point(width - width % (WALL_THICKNESS + 1) - 1, WALL_THICKNESS));</span>
<span class="fc" id="L353">			corners.add(new Point(width - width % (WALL_THICKNESS + 1) - 1,</span>
					height - height % (WALL_THICKNESS + 1) - 1));
<span class="fc" id="L355">			corners.add(new Point(WALL_THICKNESS, height - height % (WALL_THICKNESS + 1) - 1));</span>
		}

<span class="fc" id="L358">		return corners;</span>
	}

	/**
	 * Get the exit portal location.
	 * 
	 * @return portal location
	 */
	private Point getPortalPosition() {
		// opposite corner to start
<span class="fc" id="L368">		Point start = getStartPosition();</span>
<span class="fc" id="L369">		Point pos = (Point) getCorners().get((getCorners().indexOf(start) + 2) % 4).clone();</span>
		// shift a bit to put the portal deeper in the corner
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">		pos.x += (start.x &gt; pos.x) ? -1 : 1;</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">		pos.y += (start.y &gt; pos.y) ? -1 : 1;</span>

<span class="fc" id="L374">		return pos;</span>
	}

	/**
	 * Change the collision at a location.
	 * 
	 * @param layer collision layer
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param collide if &lt;code&gt;true&lt;/code&gt; set the location to a collision,
	 * 	else make it walkable
	 */
	private void setCollide(LayerDefinition layer, int x, int y, boolean collide) {
<span class="fc bfc" id="L387" title="All 2 branches covered.">		layer.set(x, y, collide ? 1 : 0);</span>
<span class="fc" id="L388">	}</span>
	
	/**
	 * Make the zone randomly colored using the soft light blend mode.
	 *  
	 * @param zone
	 */
	private void setRandomlyColored(StendhalRPZone zone) {
<span class="fc" id="L396">		ZoneAttributes attr = new ZoneAttributes(zone);</span>
		
		// Random hue, Bright color, Medium lightness
<span class="fc" id="L399">		float[] hsl = new float[] {(float) Rand.rand(), (float) Rand.rand(), 0.5f};</span>
<span class="fc" id="L400">		hsl[0] = (float) Rand.rand();</span>
<span class="fc" id="L401">		int[] argb = new int[4];</span>
<span class="fc" id="L402">		HSL.hsl2rgb(hsl, argb);</span>
<span class="fc" id="L403">		int color = ARGB.mergeRgb(argb);</span>
		
<span class="fc" id="L405">		attr.put(&quot;color_method&quot;, &quot;softlight&quot;);</span>
<span class="fc" id="L406">		attr.put(&quot;color&quot;, Integer.toString(color));</span>
		
<span class="fc" id="L408">		zone.setAttributes(attr);</span>
<span class="fc" id="L409">	}</span>

	/**
	 * Generate a random map zone with an exit portal and prizes at the other
	 * corners
	 * 
	 * @return zone
	 */
	private StendhalRPZone generateZone() {
<span class="fc" id="L418">		mapStructure.build();</span>

<span class="fc" id="L420">		final StendhalRPZone zone = new StendhalRPZone(name, width, height);</span>

		try {
<span class="fc" id="L423">			zone.addTilesets(name + &quot;.tilesets&quot;, mapStructure.getTilesets());</span>
<span class="fc" id="L424">			zone.addLayer(name + &quot;.0_floor&quot;, mapStructure.getLayer(&quot;0_floor&quot;));</span>
<span class="fc" id="L425">			zone.addLayer(name + &quot;.1_terrain&quot;, mapStructure.getLayer(&quot;1_terrain&quot;));</span>
<span class="fc" id="L426">			zone.addLayer(name + &quot;.2_object&quot;, mapStructure.getLayer(&quot;2_object&quot;));</span>
<span class="fc" id="L427">			zone.addLayer(name + &quot;.3_roof&quot;, mapStructure.getLayer(&quot;3_roof&quot;));</span>

<span class="fc" id="L429">			zone.addCollisionLayer(name + &quot;.collision&quot;,</span>
					mapStructure.getLayer(&quot;collision&quot;));
<span class="fc" id="L431">			zone.addProtectionLayer(name + &quot;.protection&quot;,</span>
					mapStructure.getLayer(&quot;protection&quot;));
<span class="nc" id="L433">		} catch (IOException e) {</span>
<span class="nc" id="L434">			logger.error(e);</span>
<span class="fc" id="L435">		}</span>

		// Create the return portal
<span class="fc" id="L438">		portal = new ReturnTeleporter(new Spot(SingletonRepository.getRPWorld().getZone(returnZoneName), returnX, returnY));</span>
<span class="fc" id="L439">		Point pos = getPortalPosition();</span>
<span class="fc" id="L440">		portal.setPosition(pos.x, pos.y);</span>
<span class="fc" id="L441">		zone.add(portal);</span>

		// disable double click move and teleport in
<span class="fc" id="L444">		zone.setMoveToAllowed(false);</span>
<span class="fc" id="L445">		zone.disallowIn();</span>
		
		// set the blend mode
<span class="fc" id="L448">		setRandomlyColored(zone);</span>

		// Add some scrolls
<span class="fc" id="L451">		addPrizes(zone);</span>

		/*
		 * Add music to the otherwise quiet zone. The radius is set
		 * to be a bit more than the max distance, so at start the
		 * music will be really quiet.
		 */
<span class="fc" id="L458">		BackgroundMusicSource music = new BackgroundMusicSource(MUSIC_TRACK,</span>
				(int) Math.sqrt(width * width + height * height) + 1, MUSIC_VOLUME);
		// set it at the the exit portal so that it's louder when the player is near
<span class="fc" id="L461">		music.setPosition(pos.x, pos.y);</span>
<span class="fc" id="L462">		zone.add(music);</span>

<span class="fc" id="L464">		zone.addMovementListener(new MazeMovementListener());</span>
<span class="fc" id="L465">		return zone;</span>
	}

	/**
	 * Drop random prizes to the side corners.
	 *
	 * @param zone the maze zone to drop the items
	 */
	private void addPrizes(StendhalRPZone zone) {
<span class="fc" id="L474">		int idx = getCorners().indexOf(getStartPosition());</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">		for (int i = 1; i &lt;= 3; i += 2) {</span>
<span class="fc" id="L477">			Item prize = SingletonRepository.getEntityManager().getItem(Rand.rand(prizes));</span>
<span class="fc" id="L478">			Point location = getCorners().get((idx + i) % 4);</span>
<span class="fc" id="L479">			prize.setPosition(location.x, location.y);</span>

<span class="fc" id="L481">			zone.add(prize, true);</span>
		}
<span class="fc" id="L483">	}</span>

	/**
	 * A listener to destroy the zone when players have left and to return the
	 * player to the right place in case she logged out.
	 */
	private final class MazeMovementListener implements MovementListener {
		private final Rectangle2D area;

<span class="fc" id="L492">		public MazeMovementListener() {</span>
<span class="fc" id="L493">			area = new Rectangle2D.Double(0, 0, width, height);</span>
<span class="fc" id="L494">		}</span>

		@Override
		public Rectangle2D getArea() {
<span class="fc" id="L498">			return area;</span>
		}

		@Override
		public void onEntered(final ActiveEntity entity, final StendhalRPZone zone, final int newX,
				final int newY) {
			// ignore
<span class="fc" id="L505">		}</span>

		@Override
		public void onExited(final ActiveEntity entity, final StendhalRPZone zone, final int oldX,
				final int oldY) {
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">			if (!(entity instanceof Player)) {</span>
<span class="nc" id="L511">				return;</span>
			}
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">			if (zone.getPlayers().size() == 1) {</span>
				// since we are about to destroy the arena, change the player zoneid to house so that
				// if they are relogging, they can enter back to the house (not the default zone of PlayerRPClass).
				// If they are out or walking out the portal it works as before.
<span class="fc" id="L517">				entity.put(&quot;zoneid&quot;, returnZoneName);</span>
<span class="fc" id="L518">				entity.put(&quot;x&quot;, returnX);</span>
<span class="fc" id="L519">				entity.put(&quot;y&quot;, returnY);</span>
				// Tell corpses they're going to be removed (from pets or creatures
				// from summon scrolls). This is for stopping the rotting timers
<span class="fc bfc" id="L522" title="All 2 branches covered.">				for (RPObject obj : zone) {</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">					if (obj instanceof Corpse) {</span>
<span class="nc" id="L524">						((Corpse) obj).onRemoved(zone);</span>
					}
<span class="fc" id="L526">				}</span>
<span class="fc" id="L527">				SingletonRepository.getRPWorld().removeZone(zone);</span>
			}
<span class="fc" id="L529">		}</span>

		@Override
		public void onMoved(final ActiveEntity entity, final StendhalRPZone zone, final int oldX,
				final int oldY, final int newX, final int newY) {
			// ignore
<span class="fc" id="L535">		}</span>

		@Override
		public void beforeMove(ActiveEntity entity, StendhalRPZone zone,
				int oldX, int oldY, int newX, int newY) {
			// does nothing, but is specified in the implemented interface
<span class="nc" id="L541">		}</span>
	}

	/**
	 * Give the player a reward, and notify him.
	 * 
	 * @param player
	 */
	protected void rewardPlayer(Player player) {
<span class="fc" id="L550">		long timediff = System.currentTimeMillis() - timeStamp;</span>
<span class="fc" id="L551">		double normalized = timediff / (double) (DEFAULT_SOLVING_TIME * MathHelper.MILLISECONDS_IN_ONE_MINUTE);</span>
		// theoretical maximum e * DEFAULT_REWARD_POINTS
<span class="fc" id="L553">		int points = (int) (DEFAULT_REWARD_POINTS * Math.exp(1 - normalized));</span>
		// Give at least one xp for persistent but hopelessly slow players
<span class="fc" id="L555">		points = Math.max(points, 1);</span>

<span class="fc" id="L557">		DBCommandQueue.get().enqueue(new WriteHallOfFamePointsCommand(player.getName(), &quot;M&quot;, points, true));</span>
<span class="fc" id="L558">		new SetQuestAction(&quot;maze&quot;, 0, &quot;done&quot;).fire(player, null, null);</span>
<span class="fc" id="L559">		new IncrementQuestAction(&quot;maze&quot;, 2, 1).fire(player, null, null);</span>
<span class="fc" id="L560">		player.sendPrivateText(&quot;You used &quot; + TimeUtil.timeUntil((int) (timediff / 1000), true)</span>
				+ &quot; to solve the maze. That was worth &quot; + Grammar.quantityplnoun(points, &quot;point&quot;) + &quot;.&quot;);
<span class="fc" id="L562">		SingletonRepository.getAchievementNotifier().onFinishQuest(player);</span>
<span class="fc" id="L563">		player.addXP(REWARD_XP);</span>
<span class="fc" id="L564">	}</span>

	/**
	 * Portal for returning from the zone. Triggers rewarding the player and
	 * updating the hall of fame sign.
	 */
	private class ReturnTeleporter extends Teleporter {
<span class="fc" id="L571">		public ReturnTeleporter(Spot spot) {</span>
<span class="fc" id="L572">			super(spot);</span>
<span class="fc" id="L573">		}</span>

		@Override
		protected boolean usePortal(final Player player) {
<span class="fc" id="L577">			boolean success = super.usePortal(player);</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">			if (success) {</span>
<span class="fc" id="L579">				rewardPlayer(player);</span>
<span class="fc" id="L580">				sign.updatePlayers();</span>
			}
<span class="fc" id="L582">			return success;</span>
		}
	}

	/**
	 * Access the portal from MazeTest.
	 *
	 * @return the exit portal
	 */
	public Portal getPortal() {
<span class="fc" id="L592">		return portal;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>