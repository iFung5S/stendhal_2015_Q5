<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MultiProducerBehaviour.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity.npc.behaviour.impl</a> &gt; <span class="el_source">MultiProducerBehaviour.java</span></div><h1>MultiProducerBehaviour.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.entity.npc.behaviour.impl;

import games.stendhal.common.grammar.Grammar;
import games.stendhal.common.grammar.ItemParserResult;
import games.stendhal.common.parser.ExpressionType;
import games.stendhal.common.parser.WordList;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.entity.item.StackableItem;
import games.stendhal.server.entity.npc.EventRaiser;
import games.stendhal.server.entity.player.Player;
import games.stendhal.server.util.TimeUtil;

import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;
import java.util.Iterator;

import org.apache.log4j.Logger;

/**
 * The behaviour of an NPC who is able to produce one or more things for a player,
 * given that the player brings the necessary resources. 
 * Production takes time, depending on the amount of the product requested.
 *
 * @author omero
 */
public class MultiProducerBehaviour extends TransactionBehaviour {

	/**
	 * To store the current status of a production order, each MultiProducerBehaviour
     * needs to have an exclusive quest slot.
	 *
	 * This slot can have three states:
	 * &lt;ul&gt;
	 * &lt;li&gt;unset: if the player has never asked the NPC to produce anything.&lt;/li&gt;
	 * &lt;li&gt;done: if the player's last order has been processed.&lt;/li&gt;
	 * &lt;li&gt;number;product;time: if the player has given an order and has not
	 * yet retrieved the product. number is the amount of products that the
	 * player will get, product is the name of the ordered product, and time is
	 * the time when the order was given, in milliseconds since the epoch.&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
    private final String questSlot;

	/**
	 * The name of the activity, e.g. &quot;build&quot;, &quot;forge&quot;, &quot;bake&quot;
	 */
    private final String productionActivity;

	/**
	 * TODO: For each of the products, in which units the product is counted, e.g. &quot;bags&quot;, &quot;pieces&quot;, &quot;pounds&quot;
     * This is not used at the moment.
	 */
    //private final HashMap&lt;String, Map&lt;String, String&gt;&gt; productsUnits;

    /**
     * TODO: Use this to return a 'default' product among the ones the NPC is able to produce?
     * This is not used at the moment.
     */
	//private final String productName;

	/**
	 * The set of products the NPC is providing
	 */
    private final HashSet&lt;String&gt; productsNames;

	/**
	 * For each of the products, whether the product will be bound to the player or not
	 */
    private final HashMap&lt;String, Boolean&gt; productsBound;

	/**
	 * Maps each of the products to which resources are required for producing one unit of it
	 */
    private final HashMap&lt;String, Map&lt;String, Integer&gt;&gt; requiredResourcesPerProduct;

	/**
	 * Maps each of the products to how many seconds it will take to produce one unit of the product.
	 */
    private final HashMap&lt;String, Integer&gt; productionTimesPerProduct;

<span class="nc" id="L97">    private static Logger logger = Logger.getLogger(MultiProducerBehaviour.class);</span>

    /**
     * Creates a new MultiProducerBehaviour.
     * 
     * @param questSlot
     *            The slot that is used to store the status of the production.
     * @param productionActivity
     *            The name of the activity, e.g. &quot;build&quot;, &quot;brew&quot;, &quot;bake&quot;
	 * @param productsNames
	 *            The set of items that the NPC is able to produce.
     *            All must be valid items names.
     * @param requiredResourcesPerProduct
     *            The mapping which maps the name of each product to 
     *            the mapping of resources required for producing that product, stated as &lt;item, quantity&gt; 
     * @param productionTimesPerProduct
     *            The mapping of the name of a product to
     *            the amount of time required to produce it
     * @param productsBound
     *            The mapping of the name of a product to
     *            whether or not that product will be bound to the player.
     */
    public MultiProducerBehaviour(
            final String questSlot,
            final String productionActivity,
            final HashSet&lt;String&gt; productsNames,
            final HashMap&lt;String, Map&lt;String, Integer&gt;&gt; requiredResourcesPerProduct,
            final HashMap&lt;String, Integer&gt; productionTimesPerProduct,
            final HashMap&lt;String, Boolean&gt; productsBound) {

<span class="nc" id="L127">        super(productsNames);</span>

<span class="nc" id="L129">        this.questSlot = questSlot;</span>
<span class="nc" id="L130">        this.productionActivity = productionActivity;</span>
		// this.productsUnits = productsUnits;
<span class="nc" id="L132">        this.productsNames = productsNames;</span>
<span class="nc" id="L133">        this.requiredResourcesPerProduct = requiredResourcesPerProduct;</span>
<span class="nc" id="L134">        this.productionTimesPerProduct = productionTimesPerProduct;</span>
<span class="nc" id="L135">        this.productsBound = productsBound;</span>

		// add the activity word as verb to the word list in case it is still missing there
<span class="nc" id="L138">        logger.debug(&quot;Registering VERB [&quot; + productionActivity + &quot;] in the word list&quot;);</span>
<span class="nc" id="L139">		WordList.getInstance().registerVerb(productionActivity);</span>

        // iterate through each of the required resource items and add them as a object to the word list
        String requiredResourceName;
<span class="nc" id="L143">        Iterator&lt;String&gt; i = requiredResourcesPerProduct.keySet().iterator();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L145">            requiredResourceName = i.next();</span>
<span class="nc" id="L146">            logger.debug(&quot;Registering OBJECT [&quot; + requiredResourceName + &quot;] in the word list&quot;);</span>
<span class="nc" id="L147">			WordList.getInstance().registerName(requiredResourceName, ExpressionType.OBJECT);</span>
		}
<span class="nc" id="L149">    }</span>

    public String getQuestSlot() {
<span class="nc" id="L152">        return questSlot;</span>
    }

    protected Map&lt;String, Integer&gt; getRequiredResourcesPerProduct(final String productName) {
<span class="nc" id="L156">        return requiredResourcesPerProduct.get(productName);</span>
    }

    public String getProductionActivity() {
<span class="nc" id="L160">        return productionActivity;</span>
    }

//	protected String getProductUnit(final String productName) {
//	return productsUnits.get(productName);
//	}

	/**
	 * Return what products the NPC is able to produce
	 *
	 * @return products names
	 */
    public HashSet&lt;String&gt; getProductsNames() {
<span class="nc" id="L173">        return productsNames;</span>
    }

    /**
     * Return how much time is required to make the requested amount of products
     * 
     * @param productName
     * @param amount
     * @return amount of time to produce amount of product
     */
    protected int getProductionTime(final String productName, final int amount) {
<span class="nc" id="L184">        return productionTimesPerProduct.get(productName) * amount;</span>
    }

	/**
	 * Return whether the requested product will be bound to the player.
	 *
	 * @param productName
	 * @return &lt;code&gt;true&lt;/code&gt; if the product should be bound.
	 */
	public boolean isProductBound(final String productName) {
<span class="nc" id="L194">		return productsBound.get(productName);</span>
	}

    /**
     * Create a text representing a saying of approximate time until
     * the order being produced is ready
     * 
     * @param player
     * @return A string describing the remaining time.
     */
    public String getApproximateRemainingTime(final Player player) {
<span class="nc" id="L205">        final String orderString = player.getQuest(questSlot);</span>
<span class="nc" id="L206">        final String[] order = orderString.split(&quot;;&quot;);</span>
<span class="nc" id="L207">        final long orderTime = Long.parseLong(order[2]);</span>
<span class="nc" id="L208">        final long timeNow = new Date().getTime();</span>
<span class="nc" id="L209">        final int numberOfProductItems = Integer.parseInt(order[0]);</span>
<span class="nc" id="L210">        final String productName = order[1];</span>

<span class="nc" id="L212">        final long finishTime = orderTime</span>
                + (getProductionTime(productName, numberOfProductItems) * 1000L);
<span class="nc" id="L214">        final int remainingSeconds = (int) ((finishTime - timeNow) / 1000);</span>
<span class="nc" id="L215">        return TimeUtil.approxTimeUntil(remainingSeconds);</span>
    }

    /**
     * Is the order ready for this player?
     * 
     * @param player
     * @return true if the order is ready.
     */
    public boolean isOrderReady(final Player player) {
<span class="nc" id="L225">        final String orderString = player.getQuest(questSlot);</span>
<span class="nc" id="L226">        final String[] order = orderString.split(&quot;;&quot;);</span>
<span class="nc" id="L227">        final int numberOfProductItems = Integer.parseInt(order[0]);</span>
<span class="nc" id="L228">        final String productName = order[1];</span>
<span class="nc" id="L229">        final long orderTime = Long.parseLong(order[2]);</span>
<span class="nc" id="L230">        final long timeNow = new Date().getTime();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        return timeNow - orderTime &gt;= getProductionTime(productName, numberOfProductItems) * 1000L; </span>
    }

    /**
     * Checks how many items are being produced for this particular order
     * 
     * @param player
     * @return number of items
     */
    public int getNumberOfProductItems(final Player player) {
<span class="nc" id="L241">        final String orderString = player.getQuest(questSlot);</span>
<span class="nc" id="L242">        final String[] order = orderString.split(&quot;;&quot;);</span>

<span class="nc" id="L244">        return Integer.parseInt(order[0]);</span>
    }

    /**
     * Return a nicely formulated string that describes the amounts and names of
     * the resources that are required to produce &lt;i&gt;amount&lt;/i&gt; units of the
     * choosen product, with hashes prepended to the resource names in order to
     * highlight them, e.g. &quot;4 #wood, 2 #iron, and 6 #leather&quot;.
     * 
     * @param productName
     *            The requested product name
	 * @param amount
	 *            The amount of products that were requested
     * @return A string describing the required resources with hashes.
     */
    public String getRequiredResourceNamesWithHashes(final String productName, final int amount) {
        // use sorted TreeSet instead of HashSet
<span class="nc" id="L261">        final Set&lt;String&gt; requiredResourcesWithHashes = new TreeSet&lt;String&gt;();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        for (final Map.Entry&lt;String, Integer&gt; entry : getRequiredResourcesPerProduct(productName).entrySet()) {</span>
<span class="nc" id="L263">            requiredResourcesWithHashes.add(Grammar.quantityplnounWithHash(amount</span>
                    * entry.getValue(), entry.getKey()));
<span class="nc" id="L265">        }</span>
<span class="nc" id="L266">        return Grammar.enumerateCollection(requiredResourcesWithHashes);</span>
    }

	/**
	 * Return a nicely formulated string that describes the amounts and names of
	 * the resources that are required to produce &lt;i&gt;amount&lt;/i&gt; units of the
	 * chosen product.
	 *
     * @param productName
     *            The requested product name
	 * @param amount
	 *            The amount of products that were requested
	 * @return A string describing the required resources.
	 */
    public String getRequiredResourceNames(final String productName, final int amount) {
		// use sorted TreeSet instead of HashSet
<span class="nc" id="L282">		final Set&lt;String&gt; requiredResources = new TreeSet&lt;String&gt;();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">		for (final Map.Entry&lt;String, Integer&gt; entry : getRequiredResourcesPerProduct(productName).entrySet()) {</span>
<span class="nc" id="L284">			requiredResources.add(Grammar.quantityplnoun(amount * entry.getValue(), entry.getKey()));</span>
<span class="nc" id="L285">		}</span>
<span class="nc" id="L286">		return Grammar.enumerateCollection(requiredResources);</span>
	}

    /**
     * At the time the order is made,
     * Checks how many items the NPC can offer to produce based on what the player is carrying
     * 
     * @param productName
     *            The requested product name
     * @param player
     * @return maximum number of items
     */
    protected int getMaximalAmount(final String productName, final Player player) {
<span class="nc" id="L299">        int maxAmount = Integer.MAX_VALUE;</span>

<span class="nc bnc" id="L301" title="All 2 branches missed.">        for (final Map.Entry&lt;String, Integer&gt; entry : getRequiredResourcesPerProduct(productName).entrySet()) {</span>
<span class="nc" id="L302">            final int limitationByThisResource = player.getNumberOfEquipped(entry.getKey()) / entry.getValue();</span>
<span class="nc" id="L303">            maxAmount = Math.min(maxAmount, limitationByThisResource);</span>
<span class="nc" id="L304">        }</span>

<span class="nc" id="L306">        return maxAmount;</span>
    }

    /**
     * At the time the order is made,
	 * Tries to take all the resources required to produce &lt;i&gt;amount&lt;/i&gt; units
	 * of the product from the player. If this is possible, asks the user if the
	 * order should be initiated.
     * 
	 * @param res
     * @param npc
     * @param player
     * @return true if all resources can be taken
     */
    public boolean askForResources(final ItemParserResult res, final EventRaiser npc, final Player player) {
<span class="nc" id="L321">		int amount = res.getAmount();</span>
<span class="nc" id="L322">        String productName = res.getChosenItemName();</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (getMaximalAmount(productName, player) &lt; amount) {</span>
<span class="nc" id="L325">            npc.say(&quot;I can only &quot; + getProductionActivity() + &quot; &quot;</span>
                    + Grammar.quantityplnoun(amount, productName, &quot;a&quot;)
                    + &quot; if you bring me &quot;
                    + getRequiredResourceNamesWithHashes(productName, amount) + &quot;.&quot;);
<span class="nc" id="L329">            return false;</span>
        } else {
<span class="nc" id="L331">			res.setAmount(amount);</span>
<span class="nc" id="L332">            npc.say(&quot;I need you to fetch me &quot;</span>
                    + getRequiredResourceNamesWithHashes(productName, amount)
					+ &quot; for this job, which will take &quot;
                    + TimeUtil.approxTimeUntil(getProductionTime(productName, amount))
                    + &quot;. Do you have what I need?&quot;);
                   
<span class="nc" id="L338">            return true;</span>
        }
    }

    /**
     * At the time the order is made,
     * tries to take all the resources required to produce the agreed amount of
     * the chosen product from the player. If this is possible, initiates an order.
     * 
     * @param npc
     *            the involved NPC
     * @param player
     *            the involved player
     */
    @Override
    public boolean transactAgreedDeal(ItemParserResult res, final EventRaiser npc, final Player player) {
<span class="nc" id="L354">		int amount = res.getAmount();</span>
<span class="nc" id="L355">        String productName = res.getChosenItemName();</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (getMaximalAmount(productName, player) &lt; amount) {</span>
            // The player tried to cheat us by placing the resource
            // onto the ground after saying &quot;yes&quot;
<span class="nc" id="L360">            npc.say(&quot;Hey! I'm over here! You'd better not be trying to trick me...&quot;);</span>
<span class="nc" id="L361">            return false;</span>
        } else {
<span class="nc bnc" id="L363" title="All 2 branches missed.">            for (final Map.Entry&lt;String, Integer&gt; entry : getRequiredResourcesPerProduct(productName).entrySet()) {</span>
<span class="nc" id="L364">                final int amountToDrop = amount * entry.getValue();</span>
<span class="nc" id="L365">                player.drop(entry.getKey(), amountToDrop);</span>
<span class="nc" id="L366">            }</span>
<span class="nc" id="L367">            final long timeNow = new Date().getTime();</span>
<span class="nc" id="L368">            player.setQuest(questSlot, amount + &quot;;&quot; + productName + &quot;;&quot; + timeNow);</span>
<span class="nc" id="L369">            npc.say(&quot;OK, I will &quot;</span>
                    + getProductionActivity()
                    + &quot; &quot;
                    + Grammar.quantityplnoun(amount, productName, &quot;a&quot;)
                    + &quot; for you, but that will take some time. Please come back in &quot;
                    + getApproximateRemainingTime(player) + &quot;.&quot;);
<span class="nc" id="L375">            return true;</span>
        }
    }

	/**
	 * At the time the player returns to pick up the finished product,
     * check that the NPC is done with the order.
     * If that is the case, the player is given the product,
     * otherwise the NPC tells to the player to come back later.
	 * 
	 * @param npc
	 *            The producing NPC
	 * @param player
	 *            The player who wants to fetch the product
	 */
	public void giveProduct(final EventRaiser npc, final Player player) {
<span class="nc" id="L391">        final String orderString = player.getQuest(questSlot);</span>
<span class="nc" id="L392">        final String[] order = orderString.split(&quot;;&quot;);</span>
<span class="nc" id="L393">        final int numberOfProductItems = Integer.parseInt(order[0]);</span>
<span class="nc" id="L394">        final String productName = order[1];</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">		if (!isOrderReady(player)) {</span>
<span class="nc" id="L397">			npc.say(&quot;Welcome back! I'm still busy with your order to &quot;</span>
					+ getProductionActivity() + &quot; &quot; + Grammar.quantityplnoun(numberOfProductItems, productName, &quot;a&quot;)
					+ &quot; for you. Come back in &quot;
					+ getApproximateRemainingTime(player) + &quot; to get it.&quot;);
		} else {
<span class="nc" id="L402">			final StackableItem products = (StackableItem) SingletonRepository.getEntityManager().getItem(productName);</span>
<span class="nc" id="L403">			products.setQuantity(numberOfProductItems);</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">			if (isProductBound(productName)) {</span>
<span class="nc" id="L406">				products.setBoundTo(player.getName());</span>
			}

<span class="nc bnc" id="L409" title="All 2 branches missed.">			if (player.equipToInventoryOnly(products)) {					</span>
<span class="nc" id="L410">				npc.say(&quot;Welcome back! I'm done with your order. Here you have &quot;</span>
					+ Grammar.quantityplnoun(numberOfProductItems, productName, &quot;the&quot;) + &quot;.&quot;);
<span class="nc" id="L412">				player.setQuest(questSlot, &quot;done&quot;);</span>
				// give some XP as a little bonus for industrious workers
<span class="nc" id="L414">				player.addXP(numberOfProductItems);</span>
<span class="nc" id="L415">				player.notifyWorldAboutChanges();</span>
<span class="nc" id="L416">				player.incProducedCountForItem(productName, products.getQuantity());</span>
<span class="nc" id="L417">				SingletonRepository.getAchievementNotifier().onProduction(player);</span>
			} else {
<span class="nc" id="L419">				npc.say(&quot;Welcome back! I'm done with your order. But right now you cannot take the &quot;</span>
						+ Grammar.plnoun(numberOfProductItems, productName) 
						+ &quot;. Come back when you have space.&quot;);
			}
		}
<span class="nc" id="L424">	}</span>

	/**
	 * Answer with an error message in case the request could not be fulfilled.
	 *
	 * @param res
	 * @param npcAction
	 * @return error message
	 */
	public String getErrormessage(final ItemParserResult res, final String npcAction) {
<span class="nc" id="L434">		return getErrormessage(res, getProductionActivity(), npcAction);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>