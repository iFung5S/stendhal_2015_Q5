<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StendhalRPZone.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.core.engine</a> &gt; <span class="el_source">StendhalRPZone.java</span></div><h1>StendhalRPZone.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                      (C) Copyright 2003 - Marauroa                      *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.core.engine;

import games.stendhal.common.CRC;
import games.stendhal.common.CollisionDetection;
import games.stendhal.common.Debug;
import games.stendhal.common.Line;
import games.stendhal.common.MathHelper;
import games.stendhal.common.filter.FilterCriteria;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.common.tiled.LayerDefinition;
import games.stendhal.common.tiled.TileSetDefinition;
import games.stendhal.server.core.config.zone.TeleportationRules;
import games.stendhal.server.core.events.MovementListener;
import games.stendhal.server.core.events.ZoneEnterExitListener;
import games.stendhal.server.core.rp.StendhalRPAction;
import games.stendhal.server.core.rule.EntityManager;
import games.stendhal.server.entity.ActiveEntity;
import games.stendhal.server.entity.Blood;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.RPEntity;
import games.stendhal.server.entity.creature.AttackableCreature;
import games.stendhal.server.entity.creature.BabyDragon;
import games.stendhal.server.entity.creature.Creature;
import games.stendhal.server.entity.creature.DomesticAnimal;
import games.stendhal.server.entity.creature.Sheep;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.mapstuff.portal.OneWayPortalDestination;
import games.stendhal.server.entity.mapstuff.portal.Portal;
import games.stendhal.server.entity.mapstuff.spawner.CreatureRespawnPoint;
import games.stendhal.server.entity.mapstuff.spawner.PassiveEntityRespawnPoint;
import games.stendhal.server.entity.mapstuff.spawner.PassiveEntityRespawnPointFactory;
import games.stendhal.server.entity.mapstuff.spawner.SheepFood;
import games.stendhal.server.entity.npc.NPC;
import games.stendhal.server.entity.npc.SpeakerNPC;
import games.stendhal.server.entity.player.Player;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import marauroa.common.game.IRPZone;
import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;
import marauroa.common.net.OutputSerializer;
import marauroa.common.net.message.TransferContent;
import marauroa.server.game.rp.MarauroaRPZone;

import org.apache.log4j.Logger;

public class StendhalRPZone extends MarauroaRPZone {
	/**
	 * When calculating the danger level, short distance between creatures
	 * (weighted with creature levels) has an effect of adding to the total
	 * score. Adjust this constant to make the effect stronger or weaker. Value
	 * of 0 would mean that the danger level is equal to the level of the
	 * highest level creature.
	 */
	private static final double DANGER_WEIGHT_CREATURE_DENSITY = 1.0;

<span class="fc" id="L84">	TeleportationRules teleRules = new TeleportationRules();</span>

	/** the logger instance. */
<span class="fc" id="L87">	private static final Logger logger = Logger.getLogger(StendhalRPZone.class);</span>

	private final List&lt;TransferContent&gt; contents;

	/** Data layer for zone attributes. */
	private ZoneAttributes attributes;

	private Point entryPoint;

	private final List&lt;Portal&gt; portals;

	private final List&lt;NPC&gt; npcs;

	/**
	 * The sheep foods in the zone.
	 */
	private final List&lt;SheepFood&gt; sheepFoods;

	private final List&lt;CreatureRespawnPoint&gt; respawnPoints;

	private final List&lt;PassiveEntityRespawnPoint&gt; plantGrowers;

	private final List&lt;RPEntity&gt; playersAndFriends;

	private final List&lt;Player&gt; players;

	/**
	 * The blood spills.
	 */
	private final List&lt;Blood&gt; bloods;

	//private boolean teleportAllowed = true;

<span class="fc" id="L120">	private boolean moveToAllowed = true;</span>

	/**
	 * Objects that implement MovementListener.
	 */
	private final List&lt;MovementListener&gt; movementListeners;


	private final List&lt;ZoneEnterExitListener&gt; zoneListeners;

	/**
	 * A set of all items that are lying on the ground in this zone. This set is
	 * currently only used for plant growers, and these might be changed so that
	 * this set is no longer needed, so try to avoid using it.
	 */
	private final Set&lt;Item&gt; itemsOnGround;

	/** contains data to if a certain area is walkable. */
	public CollisionDetection collisionMap;

	/** Contains data to verify is someone is in a PK-free area. */
	public CollisionDetection protectionMap;

	/** Position of this zone in the world map. */
<span class="fc" id="L144">	private boolean interior = true;</span>

	private int level;

	private int x;

	private int y;
	
	/** User representable name of the zone. */
	private final String readableName;

	public StendhalRPZone(final String name) {
<span class="fc" id="L156">		super(name);</span>

<span class="fc" id="L158">		contents = new LinkedList&lt;TransferContent&gt;();</span>
<span class="fc" id="L159">		entryPoint = null;</span>
<span class="fc" id="L160">		portals = new LinkedList&lt;Portal&gt;();</span>
<span class="fc" id="L161">		itemsOnGround = new HashSet&lt;Item&gt;();</span>
<span class="fc" id="L162">		bloods = new LinkedList&lt;Blood&gt;();</span>
<span class="fc" id="L163">		npcs = new LinkedList&lt;NPC&gt;();</span>
<span class="fc" id="L164">		sheepFoods = new LinkedList&lt;SheepFood&gt;();</span>
<span class="fc" id="L165">		respawnPoints = new LinkedList&lt;CreatureRespawnPoint&gt;();</span>
<span class="fc" id="L166">		plantGrowers = new LinkedList&lt;PassiveEntityRespawnPoint&gt;();</span>
<span class="fc" id="L167">		players = new LinkedList&lt;Player&gt;();</span>
<span class="fc" id="L168">		playersAndFriends = new LinkedList&lt;RPEntity&gt;();</span>

<span class="fc" id="L170">		movementListeners = new LinkedList&lt;MovementListener&gt;();</span>
<span class="fc" id="L171">		zoneListeners = new LinkedList&lt;ZoneEnterExitListener&gt;();</span>

<span class="fc" id="L173">		collisionMap = new CollisionDetection();</span>
<span class="fc" id="L174">		protectionMap = new CollisionDetection();</span>
<span class="fc" id="L175">		String readable = createReadableName(name);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (!name.equals(readable)) {</span>
<span class="fc" id="L177">			readableName = readable;</span>
			// Ensure that the zone has attribute layer if it has a readable
			// name that differs from the internal name
<span class="fc" id="L180">			ZoneAttributes attr = new ZoneAttributes(this);</span>
<span class="fc" id="L181">			setAttributes(attr);</span>
<span class="fc" id="L182">		} else {</span>
<span class="fc" id="L183">			readableName = null;</span>
		}
<span class="fc" id="L185">	}</span>

	public StendhalRPZone(final String name, final int width, final int height) {
<span class="fc" id="L188">		this(name);</span>
<span class="fc" id="L189">		collisionMap.init(width, height);</span>
<span class="fc" id="L190">	}</span>

	public StendhalRPZone(final String name, final StendhalRPZone zone) {
<span class="nc" id="L193">		this(name);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">		if (attributes != null) {</span>
			// Try to match the attribute layer name with the rest of the zone
<span class="nc" id="L196">			attributes.setBaseName(zone.getName());</span>
		}
<span class="nc" id="L198">		contents.addAll(zone.contents);</span>
<span class="nc" id="L199">		collisionMap = zone.collisionMap;</span>
<span class="nc" id="L200">		protectionMap  = zone.protectionMap;</span>

<span class="nc" id="L202">		this.zoneid = new ID(name);</span>
<span class="nc" id="L203">	}</span>

	/**
	 * Get blood (if any) at a specified zone position.
	 *
	 * @param x
	 *            The X coordinate.
	 * @param y
	 *            The Y coordinate.
	 *
	 * @return The blood, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public Blood getBlood(final int x, final int y) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">		for (final Blood blood : bloods) {</span>
<span class="fc bfc" id="L217" title="All 4 branches covered.">			if ((blood.getX() == x) &amp;&amp; (blood.getY() == y)) {</span>
<span class="fc" id="L218">				return blood;</span>
			}
<span class="fc" id="L220">		}</span>

<span class="fc" id="L222">		return null;</span>
	}

	public List&lt;NPC&gt; getNPCList() {
<span class="fc" id="L226">		return npcs;</span>
	}

	public List&lt;Portal&gt; getPortals() {
<span class="fc" id="L230">		return portals;</span>
	}

	public Portal getPortal(final Object reference) {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		if (reference == null) {</span>
<span class="nc" id="L235">			return null;</span>
		}
<span class="fc bfc" id="L237" title="All 2 branches covered.">		for (final Portal portal : portals) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">			if (reference.equals(portal.getIdentifier())) {</span>
<span class="fc" id="L239">				return portal;</span>
			}
<span class="fc" id="L241">		}</span>

<span class="fc" id="L243">		return null;</span>
	}

	/**
	 * Get the portal (if any) at a specified zone position.
	 *
	 * @param x
	 *            The X coordinate.
	 * @param y
	 *            The Y coordinate.
	 *
	 * @return The portal, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public Portal getPortal(final int x, final int y) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">		for (final Portal portal : portals) {</span>
<span class="fc bfc" id="L258" title="All 4 branches covered.">			if ((portal.getX() == x) &amp;&amp; (portal.getY() == y)) {</span>
<span class="fc" id="L259">				return portal;</span>
			}
<span class="fc" id="L261">		}</span>

<span class="fc" id="L263">		return null;</span>
	}

	/**
	 * Get the list of sheep foods in the zone.
	 *
	 * @return The list of sheep foods.
	 */
	public List&lt;SheepFood&gt; getSheepFoodList() {
<span class="fc" id="L272">		return sheepFoods;</span>
	}

	public List&lt;CreatureRespawnPoint&gt; getRespawnPointList() {
<span class="fc" id="L276">		return respawnPoints;</span>
	}

	/**
	 * Add a creature respawn point to the zone.
	 *
	 * @param point
	 *            The respawn point.
	 */
	public void add(final CreatureRespawnPoint point) {
<span class="fc" id="L286">		respawnPoints.add(point);</span>
<span class="fc" id="L287">	}</span>

	/**
	 * Remove a creature respawn point from the zone.
	 *
	 * @param point
	 *            The respawn point.
	 */
	public void remove(final CreatureRespawnPoint point) {
<span class="nc" id="L296">		respawnPoints.remove(point);</span>
<span class="nc" id="L297">	}</span>

	public List&lt;PassiveEntityRespawnPoint&gt; getPlantGrowers() {
<span class="fc" id="L300">		return plantGrowers;</span>
	}

	/** We reserve the first 64 portals ids for hand made portals. */
<span class="fc" id="L304">	private int maxPortalNumber = 64;</span>

	public Object assignPortalID(final Portal portal) {
<span class="fc" id="L307">		portal.setIdentifier(Integer.valueOf(++maxPortalNumber));</span>

<span class="fc" id="L309">		return portal.getIdentifier();</span>
	}

	public void setEntryPoint(final int x, final int y) {
<span class="fc" id="L313">		entryPoint = new Point(x, y);</span>
<span class="fc" id="L314">	}</span>

	public boolean placeObjectAtEntryPoint(final Entity entity) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">		if (entryPoint != null) {</span>
<span class="nc" id="L318">			return StendhalRPAction.placeat(this, entity, entryPoint.x,</span>
					entryPoint.y);
		} else {
<span class="nc" id="L321">			return false;</span>
		}
	}

	public void addLayer(final String name, final LayerDefinition layer) throws IOException {
<span class="fc" id="L326">		final byte[] byteContents = layer.encode();</span>
<span class="fc" id="L327">		addToContent(name, byteContents);</span>
<span class="fc" id="L328">	}</span>

	public void addTilesets(final String name, final List&lt;TileSetDefinition&gt; tilesets)
			throws IOException {
		/*
		 * Serialize the tileset data to send it to client.
		 */
<span class="fc" id="L335">		final ByteArrayOutputStream array = new ByteArrayOutputStream();</span>
<span class="fc" id="L336">		final OutputSerializer out = new OutputSerializer(array);</span>

<span class="fc" id="L338">		int amount = 0;</span>

<span class="fc bfc" id="L340" title="All 2 branches covered.">		for (final TileSetDefinition set : tilesets) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">			if (!set.getSource().contains(&quot;logic/&quot;)) {</span>
<span class="fc" id="L342">				amount++;</span>
			}

<span class="fc" id="L345">		}</span>

<span class="fc" id="L347">		out.write(amount);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">		for (final TileSetDefinition set : tilesets) {</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">			if (!set.getSource().contains(&quot;logic/&quot;)) {</span>
<span class="fc" id="L350">				set.writeObject(out);</span>
			}
<span class="fc" id="L352">		}</span>

<span class="fc" id="L354">		addToContent(name, array.toByteArray());</span>
<span class="fc" id="L355">	}</span>

	/**
	 * Creates a new TransferContent for the specified data and adds it to the
	 * contents list.
	 * @param name
	 * @param byteContents
	 */
	private void addToContent(final String name, final byte[] byteContents) {
		// Remove old data by the same name if it exists
<span class="fc" id="L365">		Iterator&lt;TransferContent&gt; it = contents.iterator();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">		while (it.hasNext()) {</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">			if (name.equals(it.next().name)) {</span>
<span class="nc" id="L368">				logger.info(&quot;Replacing old '&quot; + name + &quot;' layer.&quot;);</span>
<span class="nc" id="L369">				it.remove();</span>
			}
		}
		
<span class="fc" id="L373">		final TransferContent content = new TransferContent();</span>
<span class="fc" id="L374">		content.name = name;</span>
<span class="fc" id="L375">		content.cacheable = true;</span>
<span class="fc" id="L376">		logger.debug(&quot;Layer timestamp: &quot; + Integer.toString(content.timestamp));</span>
<span class="fc" id="L377">		content.data = byteContents;</span>
<span class="fc" id="L378">		content.timestamp = CRC.cmpCRC(content.data);</span>

<span class="fc" id="L380">		contents.add(content);</span>
<span class="fc" id="L381">	}</span>
	
	/**
	 * Resend the zone data to players on the zone. This is meant for situations
	 * where the map data changes. (Weather and lighting changes, and so on).
	 */
	public void notifyOnlinePlayers() {
		// Notify resident players about the changed weather
<span class="nc bnc" id="L389" title="All 2 branches missed.">		if (!getPlayers().isEmpty()) {</span>
<span class="nc" id="L390">			List&lt;TransferContent&gt; newContents = getContents();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">			for (Player player : getPlayers()) {</span>
				// Old clients do not understand content transfer that just
				// update the old map, and end up with no entities on the screen
<span class="nc bnc" id="L394" title="All 4 branches missed.">				if (!player.isDisconnected() &amp;&amp; player.isClientNewerThan(&quot;0.97&quot;)) {</span>
<span class="nc" id="L395">					StendhalRPAction.transferContent(player, newContents);</span>
				}
<span class="nc" id="L397">			}</span>
		}
<span class="nc" id="L399">	}</span>

	/**
	 * Set zone attributes that should be passed to the client.
	 *
	 * @param attr attributes
	 */
	public void setAttributes(ZoneAttributes attr) {
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">		if (readableName != null) {</span>
<span class="fc" id="L408">			attr.put(&quot;readable_name&quot;, readableName);</span>
		}
<span class="fc" id="L410">		attributes = attr;</span>
<span class="fc" id="L411">	}</span>

	public void addCollisionLayer(final String name, final LayerDefinition collisionLayer)
			throws IOException {
<span class="fc" id="L415">		addToContent(name, collisionLayer.encode());</span>
<span class="fc" id="L416">		collisionMap.setCollisionData(collisionLayer);</span>
<span class="fc" id="L417">	}</span>

	public void addProtectionLayer(final String name, final LayerDefinition protectionLayer)
			throws IOException {
<span class="fc" id="L421">		addToContent(name, protectionLayer.encode());</span>
<span class="fc" id="L422">		protectionMap.setCollisionData(protectionLayer);</span>
<span class="fc" id="L423">	}</span>

	public void setPosition(final int level, final int x, final int y) {
<span class="fc" id="L426">		this.interior = false;</span>
<span class="fc" id="L427">		this.level = level;</span>
<span class="fc" id="L428">		this.x = x;</span>
<span class="fc" id="L429">		this.y = y;</span>
<span class="fc" id="L430">	}</span>

	public void setPosition() {
<span class="fc" id="L433">		this.interior = true;</span>
<span class="fc" id="L434">	}</span>

	public int getX() {
<span class="fc" id="L437">		return x;</span>
	}

	public int getY() {
<span class="fc" id="L441">		return y;</span>
	}

	public int getLevel() {
<span class="fc" id="L445">		return level;</span>
	}

	public boolean isInterior() {
<span class="fc" id="L449">		return interior;</span>
	}

	/**
	 * Determine if this zone overlaps an area in global coordinates.
	 *
	 * @param area
	 *            The area (in global coordinate space).
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if the area overlaps.
	 */
	public boolean intersects(final Rectangle2D area) {
<span class="nc" id="L461">		final Rectangle2D zone = new Rectangle(x, y, getWidth(), getHeight());</span>

<span class="nc" id="L463">		return zone.intersects(area);</span>
	}

	/**
	 * Populate a zone based on it's map content.
	 *
	 * TODO: This should be moved to the zone loader or something.
	 * @param objectsLayer
	 */
	public void populate(final LayerDefinition objectsLayer) {
		/* We build the layer data */
<span class="fc" id="L474">		objectsLayer.build();</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">		for (int yTemp = 0; yTemp &lt; objectsLayer.getHeight(); yTemp++) {</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">			for (int xTemp = 0; xTemp &lt; objectsLayer.getWidth(); xTemp++) {</span>
<span class="fc" id="L478">				final int value = objectsLayer.getTileAt(xTemp, yTemp);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">				if (value &gt; 0) {</span>
					/*
					 * When the value is 0, it means that there is no tile at
					 * that point.
					 */
<span class="fc" id="L484">					final TileSetDefinition tileset = objectsLayer.getTilesetFor(value);</span>
<span class="fc" id="L485">					createEntityAt(tileset.getSource(), value</span>
							- tileset.getFirstGid(), xTemp, yTemp);
				}
			}
		}
<span class="fc" id="L490">	}</span>

	/**
	 * Calculate danger level for the zone, and store it in the data layer.
	 */
	public void calculateDangerLevel() {
		// Avoid divide by zero
<span class="fc" id="L497">		int maxLevel = 1;</span>
<span class="fc" id="L498">		int levelSum = 1;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">		for (CreatureRespawnPoint spawner : respawnPoints) {</span>
<span class="fc" id="L500">			Creature creature = spawner.getPrototypeCreature();</span>
			// Rare creatures should not count.
<span class="fc bfc" id="L502" title="All 2 branches covered.">			if (creature.isRare()) {</span>
<span class="fc" id="L503">				continue;</span>
			}
			// Add 1, so that level 0 creatures do not get completely ignored.
<span class="fc" id="L506">			int level = creature.getLevel() + 1;</span>
			// The level restriction is a hack to keep the chess pieces from
			// being included.
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">			if (level &gt; 1000) {</span>
<span class="nc" id="L510">				continue;</span>
			}
<span class="fc" id="L512">			maxLevel = Math.max(level, maxLevel);</span>
<span class="fc" id="L513">			levelSum += level;</span>
<span class="fc" id="L514">		}</span>
		// Avoid divide by zero
<span class="fc" id="L516">		int area = getFreeArea() + 1;</span>
		/*
		 * Use as the level of the highest level creature as the base, and
		 * adjust it upwards by creatures near the same level, inversely
		 * proportionally to the average distance between the creatures.
		 */
<span class="fc" id="L522">		double dangerLevel = maxLevel * (1 + DANGER_WEIGHT_CREATURE_DENSITY * (levelSum - maxLevel) / maxLevel / Math.sqrt(area)) - 1;</span>
		/*
		 * Leave out if 0; the client does not need it, and it can save needing
		 * to send a data layer for zones that do not have any other attributes.
		 */
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">		if (maxLevel &gt; 0) {</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">			if (attributes == null) {</span>
<span class="nc" id="L529">				attributes = new ZoneAttributes(this);</span>
			}
<span class="fc" id="L531">			attributes.put(&quot;danger_level&quot;, Double.toString(dangerLevel));</span>
		}
<span class="fc" id="L533">	}</span>

	/**
	 * Get the area of the zone, excluding static collisions.
	 *
	 * @return free area size
	 */
	private int getFreeArea() {
<span class="fc" id="L541">		int res = 0;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">		for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">			for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">				if (!collides(x, y)) {</span>
<span class="fc" id="L545">					res++;</span>
				}
			}
		}
<span class="fc" id="L549">		return res;</span>
	}

	/**
	 * Create a map entity as a given coordinate.
	 *
	 * @param clazz
	 *            the clazz of entity we are loading.&lt;br&gt;
	 *            It is related to the way entities are stored in tilesets now.
	 * @param type integer to represent the type of entity to be created.
	 * &lt;p&gt; if the class contains portal type is evaluated as follows:
	 * &lt;ul&gt;
	 * &lt;li&gt; 0 , 1  entry point
	 * &lt;li&gt; 1 zone change
	 * &lt;li&gt; 5 ,2 , 3 LevelPortal
	 * &lt;/ul&gt;

	 * @param x
	 * @param y
	 *
	 *
	 */
	protected void createEntityAt(final String clazz, final int type, final int x, final int y) {
<span class="fc" id="L572">		logger.debug(&quot;creating &quot; + clazz + &quot;:&quot; + type + &quot; at &quot; + x + &quot;,&quot; + y);</span>
		final int ENTRY_POINT = 0;
		final int ZONE_CHANGE = 1;
		final int DOOR = 6;
		final int PORTAL = 4;
		final int PORTAL_STAIRS_DOWN = 3;
		final int PORTAL_STAIRS_UP = 2;
		final int ONE_WAY_PORTAL_DESTINATION = 5;

		try {
<span class="fc bfc" id="L582" title="All 2 branches covered.">			if (clazz.contains(&quot;logic/portal&quot;)) {</span>
<span class="pc bpc" id="L583" title="2 of 5 branches missed.">				switch (type) {</span>

				case ENTRY_POINT:
				case ZONE_CHANGE:
<span class="fc" id="L587">					setEntryPoint(x, y);</span>
<span class="fc" id="L588">					break;</span>

				case ONE_WAY_PORTAL_DESTINATION:
				case PORTAL_STAIRS_UP:
				case PORTAL_STAIRS_DOWN:
<span class="fc" id="L593">					createLevelPortalAt(type, x, y);</span>
<span class="fc" id="L594">					break;</span>

				case PORTAL:
<span class="fc" id="L597">					break;</span>

				case DOOR:
<span class="nc" id="L600">					break;</span>

				default:
<span class="nc" id="L603">					logger.error(&quot;Unknown Portal (class/type: &quot; + clazz + &quot;:&quot;</span>
							+ type + &quot;) at (&quot; + x + &quot;,&quot; + y + &quot;) of &quot; + getID()
							+ &quot; found&quot;);
<span class="nc" id="L606">					break;</span>
				}
<span class="fc bfc" id="L608" title="All 2 branches covered.">			} else if (clazz.contains(&quot;sheep.png&quot;)) {</span>
<span class="fc" id="L609">				final Sheep sheep = new Sheep();</span>
<span class="fc" id="L610">				sheep.setPosition(x, y);</span>
<span class="fc" id="L611">				add(sheep);</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">			} else if (clazz.contains(&quot;logic/creature&quot;)) {</span>
				// get the default EntityManager
<span class="fc" id="L614">				final EntityManager manager = SingletonRepository.getEntityManager();</span>

				// Is the entity a creature
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">				if (manager.isCreature(clazz, type)) {</span>
<span class="fc" id="L618">					final Creature creature = manager.getCreature(clazz, type);</span>
<span class="fc" id="L619">					final CreatureRespawnPoint point = new CreatureRespawnPoint(this,</span>
							x, y, creature, 1);
<span class="fc" id="L621">					add(point);</span>
<span class="fc" id="L622">				} else {</span>
<span class="nc" id="L623">					logger.error(&quot;Unknown Entity (class/type: &quot; + clazz + &quot;:&quot;</span>
							+ type + &quot;) at (&quot; + x + &quot;,&quot; + y + &quot;) of &quot; + getID()
							+ &quot; found&quot;);
				}
<span class="fc bfc" id="L627" title="All 2 branches covered.">			} else if (clazz.contains(&quot;logic/item&quot;)) {</span>
<span class="fc" id="L628">				final PassiveEntityRespawnPoint passiveEntityrespawnPoint = PassiveEntityRespawnPointFactory.create(</span>
						clazz, type, getID(), x, y);
<span class="fc bfc" id="L630" title="All 2 branches covered.">				if (passiveEntityrespawnPoint != null) {</span>
<span class="fc" id="L631">					passiveEntityrespawnPoint.setPosition(x, y);</span>
<span class="fc" id="L632">					add(passiveEntityrespawnPoint);</span>
<span class="fc" id="L633">					passiveEntityrespawnPoint.setStartState();</span>

				}
			}
<span class="nc" id="L637">		} catch (final RuntimeException e) {</span>
<span class="nc" id="L638">			logger.error(&quot;error creating entity &quot; + type + &quot; at (&quot; + x + &quot;,&quot;</span>
					+ y + &quot;)&quot;, e);
<span class="fc" id="L640">		}</span>
<span class="fc" id="L641">	}</span>

	/*
	 * Create a portal between levels.
	 *
	 *
	 */
	protected void createLevelPortalAt(final int type, final int x, final int y) {
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L650">			logger.debug(&quot;Portal stairs at &quot; + this + &quot;: &quot; + x + &quot;,&quot; + y);</span>
		}

		Portal portal;

<span class="pc bpc" id="L655" title="1 of 2 branches missed.">		if (type != 5) {</span>
<span class="fc" id="L656">			portal = new Portal();</span>
		} else {
<span class="nc" id="L658">			portal = new OneWayPortalDestination();</span>
		}

<span class="fc" id="L661">		portal.setPosition(x, y);</span>
<span class="fc" id="L662">		assignPortalID(portal);</span>
<span class="fc" id="L663">		add(portal);</span>

<span class="fc" id="L665">		boolean assigned = false;</span>

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">		if (isInterior()) {</span>
			// The algo doesn't work on interiors
<span class="nc" id="L669">			return;</span>
		}

<span class="fc bfc" id="L672" title="All 2 branches covered.">		for (final IRPZone i : SingletonRepository.getRPWorld()) {</span>
<span class="fc" id="L673">			final StendhalRPZone zone = (StendhalRPZone) i;</span>

<span class="fc bfc" id="L675" title="All 2 branches covered.">			if (zone.isInterior()) {</span>
<span class="fc" id="L676">				continue;</span>
			}

			/*
			 * Portals in the correct direction?
			 */
<span class="fc bfc" id="L682" title="All 2 branches covered.">			if (type == 2) {</span>
				/* portal stairs up */
<span class="fc bfc" id="L684" title="All 2 branches covered.">				if ((zone.getLevel() - getLevel()) != 1) {</span>
<span class="fc" id="L685">					continue;</span>
				}
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">			} else if (type == 3) {</span>
				/* portal stairs down */
<span class="fc bfc" id="L689" title="All 2 branches covered.">				if ((zone.getLevel() - getLevel()) != -1) {</span>
<span class="fc" id="L690">					continue;</span>
				}
			} else {
				/* one way portal - POTENTIALLY WRONG LEVEL */
				/* Should they always go down (drop only)? */
<span class="nc bnc" id="L695" title="All 2 branches missed.">				if (Math.abs(zone.getLevel() - getLevel()) != 1) {</span>
<span class="nc" id="L696">					continue;</span>
				}
			}

<span class="fc" id="L700">			final Portal target = zone.getPortal(</span>
					portal.getX() + getX() - zone.getX(), portal.getY()
							+ getY() - zone.getY());

<span class="fc bfc" id="L704" title="All 2 branches covered.">			if (target == null) {</span>
<span class="fc" id="L705">				continue;</span>
			}

<span class="fc" id="L708">			logger.debug(zone + &quot; contains &quot; + target);</span>

<span class="pc bpc" id="L710" title="1 of 2 branches missed.">			if (target.loaded()) {</span>
<span class="nc" id="L711">				logger.debug(target + &quot; already loaded&quot;);</span>
<span class="nc" id="L712">				continue;</span>
			}

<span class="pc bpc" id="L715" title="1 of 2 branches missed.">			if (type != 5) {</span>
<span class="fc" id="L716">				portal.setDestination(zone.getName(),</span>
						zone.assignPortalID(target));
			}

<span class="fc" id="L720">			target.setDestination(getName(), portal.getIdentifier());</span>

<span class="fc" id="L722">			logger.debug(&quot;Portals LINKED&quot;);</span>
<span class="fc" id="L723">			logger.debug(portal);</span>
<span class="fc" id="L724">			logger.debug(target);</span>
<span class="fc" id="L725">			assigned = true;</span>
<span class="fc" id="L726">			break;</span>
		}

<span class="fc bfc" id="L729" title="All 2 branches covered.">		if (!assigned) {</span>
<span class="fc" id="L730">			logger.debug(portal + &quot; has no destination&quot;);</span>
		}
<span class="fc" id="L732">	}</span>

	public int getWidth() {
<span class="fc" id="L735">		return collisionMap.getWidth();</span>
	}

	public int getHeight() {
<span class="fc" id="L739">		return collisionMap.getHeight();</span>
	}

	public List&lt;TransferContent&gt; getContents() {
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">		if (attributes != null) {</span>
<span class="fc" id="L744">			TransferContent attr = attributes.getContents();</span>
			// Remove old attributes, if needed
<span class="fc bfc" id="L746" title="All 4 branches covered.">			if (!contents.isEmpty() &amp;&amp; (contents.get(0).name.equals(attr.name))) {</span>
<span class="fc" id="L747">				contents.remove(0);</span>
			}
			// Ensure the attributes comes first, so that the client has coloring
			// information
<span class="fc" id="L751">			contents.add(0, attr);</span>
		}
<span class="fc" id="L753">		return contents;</span>
	}

	public boolean isInProtectionArea(final Entity entity) {
<span class="fc" id="L757">		final Rectangle2D area = entity.getArea();</span>
<span class="fc" id="L758">		return protectionMap.collides(area);</span>
	}

	public boolean leavesZone(final Entity entity, final double x, final double y) {
<span class="nc" id="L762">		final Rectangle2D area = entity.getArea(x, y);</span>
<span class="nc" id="L763">		return collisionMap.leavesZone(area);</span>
	}

	public boolean simpleCollides(final Entity entity, final double x, final double y, final double w, final double h) {
<span class="fc" id="L767">		return collisionMap.collides(x, y, w, h);</span>
	}

	@Override
	public synchronized void add(final RPObject object) {
<span class="fc" id="L772">		add(object, true);</span>
<span class="fc" id="L773">	}</span>

	/**
	 * Adds an object to the ground.
	 *
	 * The player parameter can be used to create special items that react when
	 * they are dropped on the ground by a player.
	 *
	 * @param object
	 *            The object that should be added to the zone
	 * @param player
	 * 		The player that dropped the item
	 */
	public void add(final RPObject object, final Player player) {
<span class="fc" id="L787">		add(object, player, true);</span>
<span class="fc" id="L788">	}</span>

	/**
	 * Adds an object to the ground.
	 *
	 * @param object
	 *            The object that should be added to the zone
	 * @param expire
	 *            True if the item should expire according to its normal behaviour,
	 *            false otherwise
	 */
	public void add(final RPObject object, final boolean expire) {
<span class="fc" id="L800">		add(object, null, expire);</span>
<span class="fc" id="L801">	}</span>

	private synchronized void add(final RPObject object, final Player player, final boolean expire) {
		/*
		 * Assign [zone relative] ID info. TODO: Move up to MarauroaRPZone
		 */
<span class="fc" id="L807">		assignRPObjectID(object);</span>
<span class="fc" id="L808">		super.add(object);</span>

<span class="fc" id="L810">		notifyAdded(object);</span>

		// Needs to be before adding an item, in case Item.onPutOnGround()
		// needs proper zone information
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">		if (object instanceof Entity) {</span>
<span class="fc" id="L815">			((Entity) object).onAdded(this);</span>
		}

<span class="fc bfc" id="L818" title="All 2 branches covered.">		if (object instanceof Item) {</span>
<span class="fc" id="L819">			final Item item = (Item) object;</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">			if (player != null) {</span>
				// let item decide what to do when it's thrown by a player
<span class="fc" id="L822">				item.onPutOnGround(player);</span>
			} else {
				// otherwise follow expire
<span class="fc" id="L825">				item.onPutOnGround(expire);</span>
			}
<span class="fc" id="L827">			itemsOnGround.add(item);</span>
		}

		/*
		 * Eventually move to &lt;Entity&gt;.onAdded().
		 */
<span class="fc bfc" id="L833" title="All 2 branches covered.">		if (object instanceof PassiveEntityRespawnPoint) {</span>
<span class="fc" id="L834">			plantGrowers.add((PassiveEntityRespawnPoint) object);</span>
		}

<span class="fc bfc" id="L837" title="All 2 branches covered.">		if (object instanceof Blood) {</span>
<span class="fc" id="L838">			bloods.add((Blood) object);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">		} else if (object instanceof Player) {</span>
<span class="fc" id="L840">			Player playerObject = (Player) object;</span>
<span class="fc" id="L841">			players.add(playerObject);</span>
<span class="fc" id="L842">			playersAndFriends.add(playerObject);</span>
			/*
			 * super.add() clears the events, so this needs to be after it for
			 * the player to see the zone achievements. Also, Player.onAdded()
			 * sets the !visited slot, so this should be after it to have the
			 * achievement appear when the player enters the last missing zone.
			 */
<span class="fc" id="L849">			SingletonRepository.getAchievementNotifier().onZoneEnter(playerObject);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">		} else if (object instanceof AttackableCreature) {</span>
<span class="fc" id="L851">			playersAndFriends.add((AttackableCreature) object);</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">		} else if (object instanceof Sheep) {</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">			if (((Sheep) object).wasOwned()) {</span>
<span class="fc" id="L854">				playersAndFriends.add((Sheep) object);</span>
			}
<span class="fc bfc" id="L856" title="All 2 branches covered.">		} else if (object instanceof SheepFood) {</span>
<span class="fc" id="L857">			sheepFoods.add((SheepFood) object);</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">		} else if (object instanceof BabyDragon) {</span>
<span class="fc" id="L859">			playersAndFriends.add((BabyDragon) object);</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">		} else if (object instanceof SpeakerNPC) {</span>
<span class="fc" id="L861">			SingletonRepository.getNPCList().add((SpeakerNPC) object);</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">		} else if (object instanceof Portal) {</span>
<span class="fc" id="L863">			portals.add((Portal) object);</span>
		}

<span class="fc bfc" id="L866" title="All 2 branches covered.">		if (object instanceof NPC) {</span>
<span class="fc" id="L867">			npcs.add((NPC) object);</span>
		}

		// TODO: Move up to MarauroaRPZone?
<span class="fc" id="L871">		SingletonRepository.getRPWorld().requestSync(object);</span>
<span class="fc" id="L872">	}</span>

	/**
	 * adds an RPEntity to the playersAndFriends list.
	 *
	 * @param object RPEntity
	 */
	public void addToPlayersAndFriends(RPEntity object) {
<span class="fc bfc" id="L880" title="All 2 branches covered.">		if (!playersAndFriends.contains(object)) {</span>
<span class="fc" id="L881">			playersAndFriends.add(object);</span>
		}
<span class="fc" id="L883">	}</span>

	private void notifyAdded(final RPObject object) {
<span class="fc bfc" id="L886" title="All 2 branches covered.">		for (final ZoneEnterExitListener l : zoneListeners) {</span>
<span class="fc" id="L887">				l.onEntered(object, this);</span>
<span class="fc" id="L888">		}</span>
<span class="fc" id="L889">	}</span>

	private void notifyRemoved(final RPObject object) {
<span class="fc bfc" id="L892" title="All 2 branches covered.">		for (final ZoneEnterExitListener l : zoneListeners) {</span>
<span class="fc" id="L893">			l.onExited(object, this);</span>
<span class="fc" id="L894">		}</span>
<span class="fc" id="L895">	}</span>

	@Override
	public synchronized RPObject remove(final RPObject.ID id) {

<span class="fc" id="L900">		final RPObject object = get(id);</span>
<span class="fc" id="L901">		notifyRemoved(object);</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">		if (object instanceof Entity) {</span>
<span class="fc" id="L903">			((Entity) object).onRemoved(this);</span>
		}

<span class="fc bfc" id="L906" title="All 2 branches covered.">		if (object instanceof NPC) {</span>
<span class="fc" id="L907">			npcs.remove(object);</span>
		}

		/*
		 * Eventually move to &lt;Entity&gt;.onRemoved().
		 */
<span class="fc bfc" id="L913" title="All 2 branches covered.">		if (object instanceof PassiveEntityRespawnPoint) {</span>
<span class="fc" id="L914">			plantGrowers.remove(object);</span>
		}

<span class="fc bfc" id="L917" title="All 2 branches covered.">		if (object instanceof Blood) {</span>
<span class="fc" id="L918">			bloods.remove(object);</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">		} else if (object instanceof Player) {</span>
<span class="fc" id="L920">			players.remove(object);</span>
<span class="fc" id="L921">			playersAndFriends.remove(object);</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">		} else if (object instanceof AttackableCreature) {</span>
<span class="nc" id="L923">			playersAndFriends.remove(object);</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">		} else if (object instanceof Sheep) {</span>
<span class="fc" id="L925">			playersAndFriends.remove(object);</span>
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">		} else if (object instanceof SheepFood) {</span>
<span class="nc" id="L927">			sheepFoods.remove(object);</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">		} else if (object instanceof BabyDragon) {</span>
<span class="nc" id="L929">			playersAndFriends.remove(object);</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">		} else if (object instanceof SpeakerNPC) {</span>
<span class="fc" id="L931">			SingletonRepository.getNPCList().remove(((SpeakerNPC) object).getName());</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">		} else if (object instanceof Portal) {</span>
<span class="fc" id="L933">			portals.remove(object);</span>
		}

<span class="pc bpc" id="L936" title="1 of 2 branches missed.">		if (object instanceof ZoneEnterExitListener) {</span>
<span class="nc" id="L937">			removeZoneEnterExitListener((ZoneEnterExitListener) object);</span>
		}
<span class="fc bfc" id="L939" title="All 2 branches covered.">		if (object instanceof MovementListener) {</span>
<span class="fc" id="L940">			removeMovementListener((MovementListener) object);</span>
		}

<span class="fc" id="L943">		super.remove(id);</span>

<span class="fc bfc" id="L945" title="All 2 branches covered.">		if (object instanceof Item) {</span>
<span class="fc" id="L946">			final Item item = (Item) object;</span>
<span class="fc" id="L947">			itemsOnGround.remove(item);</span>
<span class="fc" id="L948">			item.onRemoveFromGround();</span>
		}

<span class="fc" id="L951">		return object;</span>
	}



	/**
	 * removes object from zone.
	 *
	 * @param object
	 * @return the removed object
	 */
	public synchronized RPObject remove(final RPObject object) {
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">		if (object.isContained()) {</span>
<span class="nc" id="L964">			modify(object);</span>

<span class="nc bnc" id="L966" title="All 2 branches missed.">			if (object instanceof SpeakerNPC) {</span>
<span class="nc" id="L967">				SingletonRepository.getNPCList().remove(((SpeakerNPC) object).getName());</span>
			}

<span class="nc bnc" id="L970" title="All 2 branches missed.">			if (object instanceof NPC) {</span>
<span class="nc" id="L971">				npcs.remove(object);</span>
			}

<span class="nc" id="L974">			final RPSlot slot = object.getContainerSlot();</span>
<span class="nc" id="L975">			return slot.remove(object.getID());</span>
		} else {
<span class="fc" id="L977">			return remove(object.getID());</span>
		}
	}

	@Override
	public synchronized void modify(final RPObject object) {
		// We modify the base container if the object changes.
<span class="fc" id="L984">		super.modify(object.getBaseContainer());</span>
<span class="fc" id="L985">	}</span>

	/**
	 * Checks if there is a collision on the airline between 2 positions. Only
	 * the collision map will be used.
	 *
	 * @param x1
	 *            x value of position 1
	 * @param y1
	 *            y value of position 1
	 * @param x2
	 *            x value of position 2
	 * @param y2
	 *            y value of position 2
	 * @return true if there is a collision
	 */
	public boolean collidesOnLine(final int x1, final int y1, final int x2, final int y2) {
		Vector&lt;Point&gt; points;
		// Always draw the line to the same direction, so that if A to B
		// collides, then so does B to A
<span class="nc bnc" id="L1005" title="All 6 branches missed.">		if ((x1 &lt; x2) || ((x1 == x2) &amp;&amp; (y1 &lt; y2))) {</span>
<span class="nc" id="L1006">			points = Line.renderLine(x1, y1, x2, y2);</span>
		} else {
<span class="nc" id="L1008">			points = Line.renderLine(x2, y2, x1, y1);</span>
		}
<span class="nc bnc" id="L1010" title="All 2 branches missed.">		for (final Point point : points) {</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">			if (collides((int) point.getX(), (int) point.getY())) {</span>
<span class="nc" id="L1012">				return true;</span>
			}
<span class="nc" id="L1014">		}</span>
<span class="nc" id="L1015">		return false;</span>
	}

	public boolean collides(final int x, final int y) {
<span class="fc" id="L1019">		return collisionMap.collides(x, y);</span>
	}

	/**
	 * Checks whether the given entity would be able to stand at the given
	 * position, or if it would collide with the collision map or with another
	 * entity.
	 *
	 * @param entity
	 *            The entity that would stand on the given position
	 * @param x
	 *            The x coordinate of the position where the entity would stand
	 * @param y
	 *            The y coordinate of the position where the entity would stand
	 * @return true iff the entity could stand on the given position
	 */
	public synchronized boolean collides(final Entity entity, final double x, final double y) {
<span class="fc" id="L1036">		return collides(entity, x, y, true);</span>
	}

	/**
	 * Checks whether the given entity would be able to stand at the given
	 * position, or if it would collide with the collision map or (if
	 * &lt;i&gt;checkObjects&lt;/i&gt; is enabled) with another entity.
	 *
	 * @param entity
	 *            The entity that would stand on the given position
	 * @param x
	 *            The x coordinate of the position where the entity would stand
	 * @param y
	 *            The y coordinate of the position where the entity would stand
	 * @param checkObjects
	 *            If false, only the collision map will be used.
	 * @return true iff the entity could stand on the given position
	 */
	public synchronized boolean collides(final Entity entity, final double x, final double y,
			final boolean checkObjects) {

<span class="fc bfc" id="L1057" title="All 2 branches covered.">		if (collisionMap.collides(x, y, entity.getWidth(), entity.getHeight())) {</span>
<span class="fc" id="L1058">			return true;</span>
		}

<span class="fc bfc" id="L1061" title="All 2 branches covered.">		if (checkObjects) {</span>
<span class="fc" id="L1062">			Rectangle2D area = entity.getArea(x, y);</span>
<span class="fc" id="L1063">			return collidesObjects(entity, area);</span>
		}

<span class="fc" id="L1066">		return false;</span>
	}

	public boolean collidesObjects(final Entity entity, final Rectangle2D area) {
		// For every other object in this zone, check whether it's in the
		// way.
<span class="fc bfc" id="L1072" title="All 2 branches covered.">		return getCollidingObject(entity, area) != null;</span>
	}

	private Entity getCollidingObject(final Entity entity, final Rectangle2D area) {
<span class="fc bfc" id="L1076" title="All 2 branches covered.">		for (final RPObject other : objects.values()) {</span>
			// Ignore same object
<span class="fc bfc" id="L1078" title="All 2 branches covered.">			if (entity != other) {</span>
<span class="fc" id="L1079">				final Entity otherEntity = (Entity) other;</span>

				// Check if the objects overlap
<span class="fc bfc" id="L1082" title="All 2 branches covered.">				if (area.intersects(otherEntity.getX(), otherEntity.getY(), otherEntity.getWidth(), otherEntity.getHeight())) {</span>
					// Check if it's blocking
<span class="fc bfc" id="L1084" title="All 2 branches covered.">					if (otherEntity.isObstacle(entity)) {</span>
<span class="fc" id="L1085">						return otherEntity;</span>
					}
				}
			}
<span class="fc" id="L1089">		}</span>

<span class="fc" id="L1091">		return null;</span>
	}

	/**
	 * Finds an Entity at the given coordinates.
	 *
	 * @param x coordinate
	 * @param y coordinate
	 * @return the first entity found if there are more than one or null if there are none
	 */
	public synchronized Entity getEntityAt(final double x, final double y) {
<span class="fc bfc" id="L1102" title="All 2 branches covered.">		for (final RPObject other : objects.values()) {</span>
<span class="fc" id="L1103">			final Entity otherEntity = (Entity) other;</span>

<span class="fc" id="L1105">			final Rectangle2D rect = otherEntity.getArea();</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">			if (rect.contains(x, y)) {</span>
<span class="fc" id="L1107">				return otherEntity;</span>
			}
<span class="fc" id="L1109">		}</span>
<span class="fc" id="L1110">		return null;</span>
	}

	/**
	 * Finds all entities at the given coordinates.
	 * @param x coordinate
	 * @param y coordinate
	 * @return list of entities at (x, y)
	 */
	public synchronized List&lt;Entity&gt; getEntitiesAt(final double x, final double y) {
<span class="fc" id="L1120">		List&lt;Entity&gt; entities = new LinkedList&lt;Entity&gt;();</span>

<span class="fc bfc" id="L1122" title="All 2 branches covered.">		for (final RPObject other : objects.values()) {</span>
<span class="fc" id="L1123">			final Entity entity = (Entity) other;</span>

<span class="fc" id="L1125">			final Rectangle2D rect = entity.getArea();</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">			if (rect.contains(x, y)) {</span>
<span class="fc" id="L1127">				entities.add(entity);</span>
			}
<span class="fc" id="L1129">		}</span>

<span class="fc" id="L1131">		return entities;</span>
	}

	/**
	 * Get the zone name. This is the same as &lt;code&gt;getID().getID()&lt;/code&gt;,
	 * only cleaner to use.
	 *
	 * @return The zone name.
	 */
	public String getName() {
<span class="fc" id="L1141">		return getID().getID();</span>
	}

	/**
	 * Notify anything interested in when an entity entered.
	 *
	 * @param entity
	 *            The entity that entered.
	 * @param newX
	 *            The new X coordinate.
	 * @param newY
	 *            The new Y coordinate.
	 */
	public void notifyEntered(final ActiveEntity entity, final int newX, final int newY) {
		Rectangle2D eArea;

<span class="fc" id="L1157">		eArea = entity.getArea(newX, newY);</span>

<span class="fc bfc" id="L1159" title="All 2 branches covered.">		for (final MovementListener l : movementListeners) {</span>
<span class="fc" id="L1160">			Rectangle2D area = l.getArea();</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">			if (area.intersects(eArea)) {</span>
<span class="fc" id="L1162">				l.onEntered(entity, this, newX, newY);</span>
			}
<span class="fc" id="L1164">		}</span>
<span class="fc" id="L1165">	}</span>

	/**
	 * Notify anything interested in when an entity exited.
	 *
	 * @param entity
	 *            The entity that moved.
	 * @param oldX
	 *            The old X coordinate.
	 * @param oldY
	 *            The old Y coordinate.
	 */
	public void notifyExited(final ActiveEntity entity, final int oldX, final int oldY) {
		Rectangle2D eArea;

<span class="fc" id="L1180">		eArea = entity.getArea(oldX, oldY);</span>

<span class="fc bfc" id="L1182" title="All 2 branches covered.">		for (final MovementListener l : movementListeners) {</span>
<span class="fc" id="L1183">			Rectangle2D area = l.getArea();</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">			if (area.intersects(eArea)) {</span>
<span class="fc" id="L1185">				l.onExited(entity, this, oldX, oldY);</span>
			}
<span class="fc" id="L1187">		}</span>
<span class="fc" id="L1188">	}</span>

	/**
	 * Notify anything interested that an entity moved.
	 *
	 * @param entity
	 *            The entity that moved.
	 * @param oldX
	 *            The old X coordinate.
	 * @param oldY
	 *            The old Y coordinate.
	 * @param newX
	 *            The new X coordinate.
	 * @param newY
	 *            The new Y coordinate.
	 */
	public void notifyMovement(final ActiveEntity entity, final int oldX, final int oldY,
			final int newX, final int newY) {
		Rectangle2D oeArea;
		Rectangle2D neArea;
		boolean oldIn;
		boolean newIn;

<span class="fc" id="L1211">		oeArea = entity.getArea(oldX, oldY);</span>
<span class="fc" id="L1212">		neArea = entity.getArea(newX, newY);</span>

<span class="fc bfc" id="L1214" title="All 2 branches covered.">		for (final MovementListener l : movementListeners) {</span>
<span class="fc" id="L1215">			Rectangle2D area = l.getArea();</span>

<span class="fc" id="L1217">			oldIn = area.intersects(oeArea);</span>
<span class="fc" id="L1218">			newIn = area.intersects(neArea);</span>

<span class="pc bpc" id="L1220" title="1 of 4 branches missed.">			if (!oldIn &amp;&amp; newIn) {</span>
<span class="fc" id="L1221">				l.onEntered(entity, this, newX, newY);</span>
			}

<span class="fc bfc" id="L1224" title="All 4 branches covered.">			if (oldIn &amp;&amp; newIn) {</span>
<span class="fc" id="L1225">				l.onMoved(entity, this, oldX, oldY, newX, newY);</span>
			}

<span class="fc bfc" id="L1228" title="All 4 branches covered.">			if (oldIn &amp;&amp; !newIn) {</span>
<span class="fc" id="L1229">				l.onExited(entity, this, oldX, oldY);</span>
			}
<span class="fc" id="L1231">		}</span>
<span class="fc" id="L1232">	}</span>

	public void notifyBeforeMovement(final ActiveEntity entity, final int oldX, final int oldY,
			final int newX, final int newY) {
		Rectangle2D neArea;
		boolean newIn;

<span class="fc" id="L1239">		neArea = entity.getArea(newX, newY);</span>

<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">		for (final MovementListener l : movementListeners) {</span>
<span class="nc" id="L1242">			Rectangle2D area = l.getArea();</span>

<span class="nc" id="L1244">			newIn = area.intersects(neArea);</span>

<span class="nc bnc" id="L1246" title="All 2 branches missed.">			if (newIn) {</span>
<span class="nc" id="L1247">				l.beforeMove(entity, this, oldX, oldY, newX, newY);</span>
			}

<span class="nc" id="L1250">		}</span>
<span class="fc" id="L1251">	}</span>

	public void addZoneEnterExitListener(final ZoneEnterExitListener listener) {
<span class="fc" id="L1254">		zoneListeners.add(listener);</span>
<span class="fc" id="L1255">	}</span>

	public void removeZoneEnterExitListener(final ZoneEnterExitListener listener) {
<span class="nc" id="L1258">		zoneListeners.add(listener);</span>
<span class="nc" id="L1259">	}</span>



	/**
	 * Register a movement listener for notification. Eventually create a
	 * macro-block hash to cut down on listeners to check.
	 *
	 * @param listener
	 *            A movement listener to register.
	 */
	public void addMovementListener(final MovementListener listener) {
<span class="fc" id="L1271">		movementListeners.add(listener);</span>
<span class="fc" id="L1272">	}</span>

	/**
	 * Unregister a movement listener from notification.
	 *
	 * @param listener
	 *            A movement listener to unregister.
	 */
	public void removeMovementListener(final MovementListener listener) {
<span class="fc" id="L1281">		movementListeners.remove(listener);</span>
<span class="fc" id="L1282">	}</span>

	@Override
	public String toString() {
<span class="fc" id="L1286">		return &quot;zone &quot; + zoneid + &quot; at (&quot; + x + &quot;,&quot; + y + &quot;, &quot; + level + &quot;) interior: &quot; + isInterior();</span>
	}

	/**
	 * @return a set of all items that are lying on the ground in this zone.
	 */
	public Set&lt;Item&gt; getItemsOnGround() {
<span class="fc" id="L1293">		return itemsOnGround;</span>
	}

	/**
	 * Gets all players in this zone.
	 *
	 * @return A list of all players.
	 */
	public List&lt;Player&gt; getPlayers() {
<span class="fc" id="L1302">		return players;</span>
	}

	/**
	 * Gets all players in this zone, as well as friendly entities such as
	 * sheep. These are the targets (enemies) for wild creatures such as orcs.
	 *
	 * @return a list of all players and friendly entities
	 */
	public List&lt;RPEntity&gt; getPlayerAndFriends() {
<span class="fc" id="L1312">		return playersAndFriends;</span>
	}

	/**
	 * Can moveto (mouse movement using pathfinding) be done on this map?
	 *
	 * @return true, if moveto is possible, false otherwise
	 */
	public boolean isMoveToAllowed() {
<span class="fc" id="L1321">		return moveToAllowed;</span>
	}

	/**
	 * Sets the flag whether moveto (mouse movement using pathfinding) is
	 * possible in this zone.
	 *
	 * @param moveToAllowed
	 *            true, if it is possible, false otherwise
	 */
	public void setMoveToAllowed(final boolean moveToAllowed) {
<span class="fc" id="L1332">		this.moveToAllowed = moveToAllowed;</span>

<span class="fc" id="L1334">	}</span>

	private int debugturn;

	private boolean accessible;

	private String noItemMoveMessage;



	@Override
	@SuppressWarnings(&quot;unused&quot;)
	public void nextTurn() {
<span class="fc" id="L1347">		super.nextTurn();</span>

<span class="fc" id="L1349">		debugturn++;</span>

		if (Debug.SHOW_LIST_SIZES &amp;&amp; (debugturn % 1000 == 0)) {
			final StringBuilder os = new StringBuilder(&quot;Name: &quot; + this.getID());
			os.append(&quot;blood: &quot; + bloods.size() + &quot;\n&quot;);
			os.append(&quot;itemsOnGround: &quot; + itemsOnGround.size() + &quot;\n&quot;);
			os.append(&quot;movementListeners: &quot; + movementListeners.size() + &quot;\n&quot;);
			os.append(&quot;npcs: &quot; + npcs.size() + &quot;\n&quot;);
			os.append(&quot;plantGrowers: &quot; + plantGrowers.size() + &quot;\n&quot;);
			os.append(&quot;players: &quot; + players.size() + &quot;\n&quot;);
			os.append(&quot;playersAndFriends: &quot; + playersAndFriends.size() + &quot;\n&quot;);
			os.append(&quot;portals: &quot; + portals.size() + &quot;\n&quot;);
			os.append(&quot;respawnPoints: &quot; + respawnPoints.size() + &quot;\n&quot;);
			os.append(&quot;sheepFoods: &quot; + sheepFoods.size() + &quot;\n&quot;);
			os.append(&quot;objects: &quot; + objects.size() + &quot;\n&quot;);
			logger.info(os);
		}
<span class="fc" id="L1366">	}</span>

	public void logic() {
<span class="fc bfc" id="L1369" title="All 2 branches covered.">		for (final NPC npc : npcs) {</span>
			try {
<span class="fc" id="L1371">				npc.logic();</span>
<span class="nc" id="L1372">			} catch (final Exception e) {</span>
<span class="nc" id="L1373">				logger.error(&quot;Error in npc logic for zone &quot; + getID().getID(), e);</span>
<span class="fc" id="L1374">			}</span>
<span class="fc" id="L1375">		}</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">		for (final Portal portal : portals) {</span>
		    try {
<span class="fc" id="L1378">		        portal.logic();</span>
<span class="nc" id="L1379">		    } catch (final Exception e) {</span>
<span class="nc" id="L1380">		        logger.error(&quot;Error in portal logic for zone &quot; + getID().getID(), e);</span>
<span class="fc" id="L1381">		    }</span>
<span class="fc" id="L1382">		}</span>
<span class="fc" id="L1383">	}</span>

	/**
	 * Return whether the zone is completely empty.
	 * @return true if there are no objects in zone
	 */
	public boolean isEmpty() {
<span class="nc" id="L1390">	    return objects.isEmpty();</span>
	}

	/**
	 * Return whether the zone contains one or more players.
	 * @return if there are players in zone
	 */
	public boolean containsPlayer() {
<span class="nc bnc" id="L1398" title="All 2 branches missed.">	    for (final RPObject obj : objects.values()) {</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">	        if (obj instanceof Player) {</span>
<span class="nc" id="L1400">	            return true;</span>
            }
<span class="nc" id="L1402">	    }</span>

<span class="nc" id="L1404">	    return false;</span>
	}

    /**
     * Return whether the zone contains one or more animals.
     * @return true if there are domesticalanimals in zone
     */
    public boolean containsAnimal() {
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        for (final RPObject obj : objects.values()) {</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">            if (obj instanceof DomesticAnimal) {</span>
<span class="nc" id="L1414">                return true;</span>
            }
<span class="nc" id="L1416">        }</span>

<span class="nc" id="L1418">        return false;</span>
    }

    /**
     * Return whether the zone contains any creature including players and animals.
     * @return true if there are creatures in zone
     */
    public boolean containsCreature() {
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        for (final RPObject obj : objects.values()) {</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">            if (obj instanceof Creature) {</span>
<span class="nc" id="L1428">                return true;</span>
            }
<span class="nc" id="L1430">        }</span>

<span class="nc" id="L1432">        return false;</span>
    }


	public List&lt;Entity&gt; getFilteredEntities(final FilterCriteria&lt;Entity&gt; criteria) {
<span class="fc" id="L1437">		final List &lt;Entity&gt; result = new LinkedList&lt;Entity&gt;();</span>

<span class="fc bfc" id="L1439" title="All 2 branches covered.">		for (final RPObject obj : objects.values()) {</span>
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">	            if (obj instanceof Entity) {</span>
<span class="fc" id="L1441">					final Entity entity = (Entity) obj;</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">					if (criteria.passes(entity)) {</span>
<span class="fc" id="L1443">						result.add(entity);</span>
					}

				}
<span class="fc" id="L1447">	        }</span>

<span class="fc" id="L1449">		return result;</span>


	}

	/**
	 * Sets the flag whether magic scrolls for teleportation may be uses in this
	 * zone.
	 */
	public void disAllowTeleport() {
<span class="fc" id="L1459">		disallowIn();</span>
<span class="fc" id="L1460">		disallowOut();</span>
<span class="fc" id="L1461">	}</span>

	/**
	 * Disallow teleporting to and from a specified area.
	 *
	 * @param x left x coordinate
	 * @param y top y coordinate
	 * @param width width of the area
	 * @param height height of the area
	 */
	public void disAllowTeleport(int x, int y, int width, int height) {
<span class="fc" id="L1472">		disallowIn(x, y, width, height);</span>
<span class="fc" id="L1473">		disallowOut(x, y, width, height);</span>
<span class="fc" id="L1474">	}</span>

	/**
	 * Check if teleporting with a scroll to a location is allowed.
	 *
	 * @param x x coordinate
	 * @param y y coordinate
	 * @return &lt;code&gt;true&lt;/code&gt; iff teleporting is allowed
	 */
	public boolean isTeleportInAllowed(int x, int y) {
<span class="fc" id="L1484">		return teleRules.isInAllowed(x, y);</span>
	}

	/**
	 * Check if teleporting with a scroll from a location is allowed.
	 *
	 * @param x x coordinate
	 * @param y y coordinate
	 * @return &lt;code&gt;true&lt;/code&gt; iff teleporting is allowed
	 */
	public boolean isTeleportOutAllowed(int x, int y) {
<span class="fc" id="L1495">		return teleRules.isOutAllowed(x, y);</span>
	}

	/**
	 * Forbid teleporting to the entire zone using a scroll.
	 */
	public void disallowIn() {
<span class="fc" id="L1502">		teleRules.disallowIn();</span>
<span class="fc" id="L1503">	}</span>

	/**
	 * Disallow teleporting to specified area.
	 *
	 * @param x left x coordinate
	 * @param y top y coordinate
	 * @param width width of the area
	 * @param height height of the area
	 */
	public void disallowIn(int x, int y, int width, int height) {
<span class="fc" id="L1514">		teleRules.disallowIn(x, y, width, height);</span>
<span class="fc" id="L1515">	}</span>

	/**
	 * Forbid teleporting from the entire zone using a scroll.
	 */
	public void disallowOut() {
<span class="fc" id="L1521">		teleRules.disallowOut();</span>
<span class="fc" id="L1522">	}</span>

	/**
	 * Disallow teleporting from specified area.
	 *
	 * @param x left x coordinate
	 * @param y top y coordinate
	 * @param width width of the area
	 * @param height height of the area
	 */
	public void disallowOut(int x, int y, int width, int height) {
<span class="fc" id="L1533">		teleRules.disallowOut(x, y, width, height);</span>
<span class="fc" id="L1534">	}</span>

	public void onRemoved() {
<span class="nc bnc" id="L1537" title="All 2 branches missed.">		for (RPObject inspected : this) {</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">			if (inspected instanceof ActiveEntity) {</span>
<span class="nc" id="L1539">				((ActiveEntity) inspected).onRemoved(this);</span>
			}
<span class="nc" id="L1541">		}</span>
<span class="nc" id="L1542">	}</span>

	/**
	 * @return is this zone accessible by the public
	 */
	public boolean isPublicAccessible() {
<span class="fc" id="L1548">		return accessible;</span>
	}

	/**
	 * Sets the public accessibility of this zone
	 *
	 * @param accessible
	 */
	public void setPublicAccessible(boolean accessible) {
<span class="fc" id="L1557">		this.accessible = accessible;</span>
<span class="fc" id="L1558">	}</span>

	/**
	 * Mappings for the zone names that would look weird with the dynamic
	 * translation.
	 */
<span class="fc" id="L1564">	private static final Map&lt;String, String&gt; zoneNameMappings = new HashMap&lt;String, String&gt;();</span>

	static {
<span class="fc" id="L1567">		zoneNameMappings.put(&quot;0_athor_ship_w2&quot;, &quot;on Athor ferry&quot;);</span>
<span class="fc" id="L1568">		zoneNameMappings.put(&quot;-1_athor_ship_w2&quot;, &quot;on Athor ferry&quot;);</span>
<span class="fc" id="L1569">		zoneNameMappings.put(&quot;-2_athor_ship_w2&quot;, &quot;on Athor ferry&quot;);</span>
<span class="fc" id="L1570">		zoneNameMappings.put(&quot;hell&quot;, &quot;in Hell&quot;);</span>
<span class="fc" id="L1571">	}</span>

	/**
	 * Translate zone name into a more readable form.
	 *
	 * @param zoneName
	 * @return translated zone name
	 */
	private static String translateZoneName(final String zoneName) {

<span class="fc bfc" id="L1581" title="All 2 branches covered.">		if (zoneNameMappings.get(zoneName) != null) {</span>
<span class="fc" id="L1582">			return zoneNameMappings.get(zoneName);</span>
		}
<span class="fc" id="L1584">		String result = &quot;&quot;;</span>
<span class="fc" id="L1585">		final Pattern p = Pattern.compile(&quot;^(-?[\\d]|int)_(.+)$&quot;);</span>
<span class="fc" id="L1586">		final Matcher m = p.matcher(zoneName);</span>
<span class="fc" id="L1587">		int levelValue = -1;</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">		if (m.matches()) {</span>
<span class="fc" id="L1589">			final String level = m.group(1);</span>
<span class="fc" id="L1590">			String remainder = m.group(2);</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">			if (&quot;int&quot;.equals(level)) {</span>
<span class="fc" id="L1592">				return &quot;inside a building in &quot; + Grammar.makeUpperCaseWord(getInteriorName(zoneName));</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">			} else if (level.startsWith(&quot;-&quot;)) {</span>
				try {
<span class="fc" id="L1595">					levelValue = Integer.parseInt(level);</span>
<span class="nc" id="L1596">				} catch (final NumberFormatException e) {</span>
<span class="nc" id="L1597">					levelValue = 0;</span>
<span class="fc" id="L1598">				}</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">				if (levelValue &lt; -2) {</span>
<span class="fc" id="L1600">					result = &quot;deep below ground level at &quot;;</span>
				} else {
<span class="fc" id="L1602">					result = &quot;below ground level at &quot;;</span>
				}
<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">			} else if (level.matches(&quot;^\\d&quot;)) {</span>
				/* positive floor */
				try {
<span class="fc" id="L1607">					levelValue = Integer.parseInt(level);</span>
<span class="nc" id="L1608">				} catch (final NumberFormatException e) {</span>
<span class="nc" id="L1609">					levelValue = 0;</span>
<span class="fc" id="L1610">				}</span>
<span class="fc bfc" id="L1611" title="All 2 branches covered.">				if (levelValue != 0) {</span>
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">					if (levelValue &gt; 1) {</span>
<span class="fc" id="L1613">						result = &quot;high above the ground level at &quot;;</span>
					} else {
<span class="nc" id="L1615">						result = &quot;above the ground level at &quot;;</span>
					}
				}
			}
<span class="fc" id="L1619">			final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L1620">			final String[] directions = new String[] { &quot;.+_n\\d?e\\d?($|_).*&quot;,</span>
					&quot;north east &quot;, &quot;_n\\d?e\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_n\\d?w\\d?($|_).*&quot;, &quot;north west &quot;, &quot;_n\\d?w\\d?($|_)&quot;,
					&quot;_&quot;, &quot;.+_s\\d?e\\d?($|_).*&quot;, &quot;south east &quot;,
					&quot;_s\\d?e\\d?($|_)&quot;, &quot;_&quot;, &quot;.+_s\\d?w\\d?($|_).*&quot;,
					&quot;south west &quot;, &quot;_s\\d?w\\d?($|_)&quot;, &quot;_&quot;, &quot;.+_n\\d?($|_).*&quot;,
					&quot;north &quot;, &quot;_n\\d?($|_)&quot;, &quot;_&quot;, &quot;.+_s\\d?($|_).*&quot;, &quot;south &quot;,
					&quot;_s\\d?($|_)&quot;, &quot;_&quot;, &quot;.+_w\\d?($|_).*&quot;, &quot;west &quot;,
					&quot;_w\\d?($|_)&quot;, &quot;_&quot;, &quot;.+_e\\d?($|_).*&quot;, &quot;east &quot;,
					&quot;_e\\d?($|_)&quot;, &quot;_&quot;, };
<span class="fc bfc" id="L1630" title="All 2 branches covered.">			for (int i = 0; i &lt; directions.length; i += 4) {</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">				if (remainder.matches(directions[i])) {</span>
<span class="fc" id="L1632">					sb.append(directions[i + 1]);</span>
<span class="fc" id="L1633">					remainder = remainder.replaceAll(directions[i + 2],</span>
							directions[i + 3]);
				}
			}
<span class="fc" id="L1637">			String direction = sb.toString();</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">			if (direction.length() &gt; 0) {</span>
<span class="fc" id="L1639">				result += direction + &quot;of &quot;;</span>
<span class="fc bfc" id="L1640" title="All 2 branches covered.">			} else if (levelValue == 0)  {</span>
				// if level 0 and no other direction we need an extra in for grammar
<span class="fc" id="L1642">				result =&quot; in &quot;;</span>
			}
			// here we need to capitalise the city name
<span class="fc" id="L1645">			result += Grammar.makeUpperCaseWord(remainder.replaceAll(&quot;_&quot;, &quot; &quot;));</span>
<span class="fc" id="L1646">		} else {</span>
<span class="fc" id="L1647">			logger.warn(&quot;no match: &quot; + zoneName);</span>
		}
<span class="fc bfc" id="L1649" title="All 2 branches covered.">		if (&quot;&quot;.equals(result)) {</span>
<span class="fc" id="L1650">			return zoneName;</span>
		} else {
<span class="fc" id="L1652">			return result.trim();</span>
		}
	}

	private static String getInteriorName(final String zoneName) {
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">		if (zoneName == null) {</span>
<span class="nc" id="L1658">			throw new IllegalArgumentException(&quot;zoneName is null&quot;);</span>
		}
<span class="fc" id="L1660">		final int start = zoneName.indexOf('_') + 1;</span>
<span class="fc" id="L1661">		int end = zoneName.indexOf('_', start);</span>
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">		if (end &lt; 0) {</span>
<span class="nc" id="L1663">			end = zoneName.length();</span>
		}
<span class="pc bpc" id="L1665" title="2 of 4 branches missed.">		if (start &gt; 0 &amp;&amp; end &gt; start) {</span>
<span class="fc" id="L1666">			return zoneName.substring(start, end);</span>
		} else {
<span class="nc" id="L1668">			return zoneName;</span>
		}
	}

	public static String describe(final String zoneName) {
<span class="fc" id="L1673">		return StendhalRPZone.translateZoneName(zoneName);</span>
	}
	public String describe() {
<span class="fc" id="L1676">		return StendhalRPZone.translateZoneName(this.getName());</span>
	}
	
	/**
	 * Generate a precise zone name that can be shown to players (in client
	 * minimap). For vague zone names, use {@link #describe()}.
	 * 
	 * @param zoneName game internal zone name 
	 * @return human readable zone name
	 */
	private String createReadableName(String zoneName) {
<span class="fc" id="L1687">		StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L1688">		final Pattern p = Pattern.compile(&quot;^(-?[\\d]|int)_(.+)$&quot;);</span>
<span class="fc" id="L1689">		final Matcher m = p.matcher(zoneName);</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">		if (m.matches()) {</span>
<span class="fc" id="L1691">			final String level = m.group(1);</span>
<span class="fc" id="L1692">			String remainder = m.group(2);</span>
			
<span class="fc" id="L1694">			final String[] directions = new String[] {</span>
					&quot;.+_n(\\d?)e(\\d?)($|_).*&quot;, &quot;N$1E$2&quot;, &quot;_n\\d?e\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_n(\\d?)w(\\d?)($|_).*&quot;, &quot;N$1W$2&quot;, &quot;_n\\d?w\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_s(\\d?)e(\\d?)($|_).*&quot;, &quot;S$1E$2 &quot;, &quot;_s\\d?e\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_s(\\d?)w(\\d?)($|_).*&quot;, &quot;S$1W$2&quot;, &quot;_s\\d?w\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_n(\\d?)($|_).*&quot;, &quot;N$1&quot;, &quot;_n\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_s(\\d?)($|_).*&quot;, &quot;S$1&quot;, &quot;_s\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_w(\\d?)($|_).*&quot;, &quot;W$1&quot;, &quot;_w\\d?($|_)&quot;, &quot;_&quot;,
					&quot;.+_e(\\d?)($|_).*&quot;, &quot;E$1&quot;, &quot;_e\\d?($|_)&quot;, &quot;_&quot;, };
<span class="fc" id="L1703">			StringBuilder dirBuf = new StringBuilder();</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">			for (int i = 0; i &lt; directions.length; i += 4) {</span>
<span class="fc" id="L1705">				Matcher match = Pattern.compile(directions[i]).matcher(remainder);</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">				if (match.matches()) {</span>
<span class="fc" id="L1707">					dirBuf.append(match.replaceAll(directions[i + 1]));</span>
<span class="fc" id="L1708">					remainder = remainder.replaceAll(directions[i + 2],</span>
							directions[i + 3]);
				}
			}
			
			// here we need to capitalize the city name
<span class="fc" id="L1714">			result.append(Grammar.makeUpperCaseWord(remainder.replaceAll(&quot;_&quot;, &quot; &quot;)));</span>
<span class="fc" id="L1715">			result.append(dirBuf);</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">			if (&quot;int&quot;.equals(level)) {</span>
<span class="fc" id="L1717">				result.append(&quot;, interior&quot;);</span>
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">			} else if (level.matches(&quot;^-?\\d&quot;)) {</span>
<span class="fc" id="L1719">				int levelValue = MathHelper.parseInt(level);</span>
<span class="fc bfc" id="L1720" title="All 2 branches covered.">				if (levelValue != 0) {</span>
<span class="fc" id="L1721">					result.append(&quot;, level &quot;);</span>
<span class="fc" id="L1722">					result.append(levelValue);</span>
				}
			}
<span class="fc" id="L1725">		} else {</span>
			// As of this writing (2014-01-15), the few zone names that do not
			// match produce good results with this. 
<span class="fc" id="L1728">			logger.info(&quot;no match: &quot; + zoneName);</span>
<span class="fc" id="L1729">			return Grammar.makeUpperCaseWord(zoneName.replaceAll(&quot;_&quot;, &quot; &quot;));</span>
		}
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">		if (result.length() == 0) {</span>
<span class="nc" id="L1732">			return null;</span>
		} else {
<span class="fc" id="L1734">			return result.toString().trim();</span>
		}
	}

	/**
	 * Disabled movement of items in this zone.
	 *
	 * @param message in game error message
	 */
	public void setNoItemMoveMessage(String message) {
<span class="fc" id="L1744">		this.noItemMoveMessage = message;</span>
<span class="fc" id="L1745">	}</span>

	/**
	 * Gets the in game error message if movement of items is disabled in this zone.
	 *
	 * @return message in game error message or &lt;code&gt;null&lt;/code&gt;
	 */
	public String getNoItemMoveMessage() {
<span class="fc" id="L1753">		return this.noItemMoveMessage;</span>
	}

	/**
	 * gets the zone attributes
	 *
	 * @return zone attributes
	 */
	public ZoneAttributes getAttributes() {
<span class="nc" id="L1762">		return attributes;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>