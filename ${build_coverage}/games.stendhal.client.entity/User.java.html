<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>User.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.entity</a> &gt; <span class="el_source">User.java</span></div><h1>User.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.entity;

import static games.stendhal.common.constants.Actions.AUTOWALK;
import static games.stendhal.common.constants.Actions.MODE;
import static games.stendhal.common.constants.Actions.TYPE;
import static games.stendhal.common.constants.Actions.WALK;
import static games.stendhal.common.constants.Common.PATHSET;
import games.stendhal.client.ClientSingletonRepository;
import games.stendhal.client.GameObjects;
import games.stendhal.client.StendhalClient;
import games.stendhal.client.gui.chatlog.HeaderLessEventLine;
import games.stendhal.common.Direction;
import games.stendhal.common.NotificationType;
import games.stendhal.common.constants.Testing;
import games.stendhal.common.grammar.Grammar;

import java.awt.event.KeyEvent;
import java.awt.geom.Rectangle2D;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import marauroa.common.game.RPAction;
import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;

import org.apache.log4j.Logger;

/**
 * This class identifies the user of this client.
 *
 * @author durkham, hendrik
 */
public class User extends Player {
	/* The logger instance. */
<span class="fc" id="L48">	private static final Logger logger = Logger.getLogger(User.class);</span>

	private static User instance;
	private static String groupLootmode;
	private static Set&lt;String&gt; groupMembers;
<span class="fc" id="L53">	private final HashSet&lt;String&gt; ignore = new HashSet&lt;String&gt;();</span>
	private final SpeedPredictor speedPredictor;

	/**
	 * is the user object not set, yet?
	 *
	 * @return true, if the the user object is unknown; false if it is known
	 */
	public static boolean isNull() {
<span class="fc bfc" id="L62" title="All 2 branches covered.">		return instance == null;</span>
	}

	/**
	 * gets the User object
	 *
	 * @return user object
	 */
	public static User get() {
<span class="fc" id="L71">		return instance;</span>
	}

	/**
	 * creates a User object
	 */
<span class="fc" id="L77">	public User() {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">		if (instance == null) {</span>
<span class="fc" id="L79">			speedPredictor = new SpeedPredictor();</span>
		} else {
<span class="fc" id="L81">			speedPredictor = new SpeedPredictor(instance.speedPredictor);</span>
		}
<span class="fc" id="L83">		instance = this;</span>
<span class="fc" id="L84">	}</span>

	@Override
	protected void onAway(final String message) {
<span class="nc" id="L88">		super.onAway(message);</span>

		String text;
<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (message == null) {</span>
<span class="nc" id="L92">			text = &quot;You are no longer marked as being away.&quot;;</span>
		} else {
<span class="nc" id="L94">			text = &quot;You have been marked as being away.&quot;;</span>
		}
<span class="nc" id="L96">		ClientSingletonRepository.getUserInterface().addEventLine(new HeaderLessEventLine(text, NotificationType.INFORMATION));</span>
<span class="nc" id="L97">	}</span>

	/**
	 * is this user an admin with an adminlevel equal or above 600?
	 *
	 * @return true, if the user is an admin; false otherwise
	 */
	public static boolean isAdmin() {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">		if (isNull()) {</span>
<span class="nc" id="L106">			return false;</span>
		}

<span class="fc" id="L109">		final User me = User.get();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">		if (me.rpObject == null) {</span>
<span class="fc" id="L111">			return false;</span>
		}

<span class="nc bnc" id="L114" title="All 4 branches missed.">		return me.rpObject.has(&quot;adminlevel&quot;)</span>
				&amp;&amp; (me.rpObject.getInt(&quot;adminlevel&quot;) &gt;= 600);
	}

	/**
	 * gets the level of the current user
	 *
	 * @return level
	 */
	public static int getPlayerLevel() {
<span class="nc bnc" id="L124" title="All 2 branches missed.">		if (!isNull()) {</span>
<span class="nc" id="L125">			final User me = User.get();</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (me.rpObject != null) {</span>
<span class="nc" id="L128">				return me.getLevel();</span>
			}
		}

<span class="nc" id="L132">		return 0;</span>
	}

	/**
	 * checks whether the user owns a sheep
	 *
	 * @return true, if the user owns a sheep; false otherwise
	 */
	public boolean hasSheep() {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">		if (rpObject == null) {</span>
<span class="fc" id="L142">			return false;</span>
		}
<span class="nc" id="L144">		return rpObject.has(&quot;sheep&quot;);</span>
	}

	/**
	 * checks whether the user owns a pet
	 *
	 * @return true, if the user owns a pet; false otherwise
	 */
	public boolean hasPet() {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		if (rpObject == null) {</span>
<span class="fc" id="L154">			return false;</span>
		}
<span class="nc" id="L156">		return rpObject.has(&quot;pet&quot;);</span>
	}

	/**
	 * gets the ID of a sheep
	 *
	 * @return ID of sheep
	 */
	public int getSheepID() {
<span class="nc" id="L165">		return rpObject.getInt(&quot;sheep&quot;);</span>
	}

	/**
	 * gets the ID of a pet
	 *
	 * @return ID of pet
	 */
	public int getPetID() {
<span class="nc" id="L174">		return rpObject.getInt(&quot;pet&quot;);</span>
	}

	@Override
	public void onHealed(final int amount) {
<span class="nc" id="L179">		super.onHealed(amount);</span>
<span class="nc" id="L180">		ClientSingletonRepository.getUserInterface().addEventLine(</span>
				new HeaderLessEventLine(
						getTitle() + &quot; heals &quot;
						+ Grammar.quantityplnoun(amount, &quot;health point&quot;) + &quot;.&quot;,
						NotificationType.HEAL));
<span class="nc" id="L185">	}</span>

	/**
	 * The absolute world area (coordinates) where the player can possibly hear.
	 * sounds
	 *
	 * @return Rectangle2D area
	 */
	public Rectangle2D getHearingArea() {
		final double HEARING_RANGE = 20;
		final double width = HEARING_RANGE * 2;
<span class="fc" id="L196">		return new Rectangle2D.Double(getX() - HEARING_RANGE, getY()</span>
				- HEARING_RANGE, width, width);
	}

	/**
	 * The object added/changed attribute(s).
	 *
	 * @param object
	 *            The base object.
	 * @param changes
	 *            The changes.
	 */
	@Override
	public void onChangedAdded(final RPObject object, final RPObject changes) {
		/* TODO: Remove condition when walking bug fix is finished. */
		if (false) { // DISABLED
			if (!this.stopped()) {
				boolean shouldStop = true;
				String debugString = &quot;Stopped on:&quot;;

				if (StendhalClient.get().directionKeyIsPressed()) {
					shouldStop = false;
				} else {
					debugString += &quot; !directionKeyIsPressed()&quot;;
				}
				if (object.has(AUTOWALK)) {
					shouldStop = false;
				} else {
					debugString += &quot; !has(AUTOWALK)&quot;;
				}
				if (object.has(PATHSET)) {
					shouldStop = false;
				} else {
					debugString += &quot; !has(PATHSET)&quot;;
				}

				if (shouldStop) {
					/* Stop the character's movement. */
					this.stopMovement();

					if (logger.isDebugEnabled() || Testing.DEBUG) {
						logger.info(debugString);
					}
				}
			}
		}

<span class="fc" id="L243">		super.onChangedAdded(object, changes);</span>

		// The first time we ignore it.
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">		if (object != null) {</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">			if (changes.has(&quot;offline&quot;)) {</span>
<span class="nc" id="L248">				final String[] players = changes.get(&quot;offline&quot;).split(&quot;,&quot;);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">				for (final String playername : players) {</span>
<span class="nc" id="L250">						ClientSingletonRepository.getUserInterface().addEventLine(</span>
							new HeaderLessEventLine(
							playername + &quot; has left Stendhal.&quot;,
							NotificationType.INFORMATION));
				}
			}

<span class="pc bpc" id="L257" title="1 of 2 branches missed.">			if (changes.has(&quot;online&quot;)) {</span>
<span class="nc" id="L258">				final String[] players = changes.get(&quot;online&quot;).split(&quot;,&quot;);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">				for (final String playerName : players) {</span>
<span class="nc" id="L260">					ClientSingletonRepository.getUserInterface().addEventLine(</span>
							new HeaderLessEventLine(
							playerName + &quot; has joined Stendhal.&quot;,
							NotificationType.INFORMATION));
				}
			}

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">			if (changes.hasSlot(&quot;!ignore&quot;)) {</span>
<span class="nc" id="L268">				RPObject ign = changes.getSlot(&quot;!ignore&quot;).getFirst();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">				if (ign != null) {</span>
<span class="nc" id="L270">					addIgnore(ign);</span>
				}
			}
		}
<span class="fc" id="L274">	}</span>

	@Override
	public void onChangedRemoved(final RPObject base, final RPObject diff) {
<span class="nc" id="L278">		super.onChangedRemoved(base, diff);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">		if (diff.hasSlot(&quot;!ignore&quot;)) {</span>
<span class="nc" id="L280">			RPObject ign = diff.getSlot(&quot;!ignore&quot;).getFirst();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">			if (ign != null) {</span>
<span class="nc" id="L282">				removeIgnore(ign);</span>
			}
		}
<span class="nc" id="L285">	}</span>

	/**
	 * Resets the class to uninitialized.
	 */
	static void setNull() {
<span class="fc" id="L291">		instance = null;</span>
<span class="fc" id="L292">	}</span>

	/**
	 * Returns the objectid for the named item.
	 *
	 * @param slotName
	 *            name of slot to search
	 * @param itemName
	 *            name of item
	 * @return objectid or &lt;code&gt;-1&lt;/code&gt; in case there is no such item
	 */
	public int findItem(final String slotName, final String itemName) {
<span class="fc" id="L304">		RPSlot slot = getSlot(slotName);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">		if (slot == null) {</span>
<span class="nc" id="L306">			return -1;</span>
		}
<span class="fc bfc" id="L308" title="All 2 branches covered.">		for (final RPObject item : slot) {</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">			if (item.get(&quot;name&quot;).equals(itemName)) {</span>
<span class="fc" id="L310">				final int itemID = item.getID().getObjectID();</span>

<span class="fc" id="L312">				return itemID;</span>
			}
<span class="nc" id="L314">		}</span>

<span class="fc" id="L316">		return -1;</span>
	}

	/**
	 * Is this object the user of this client?
	 *
	 * @return true
	 */
	@Override
	public boolean isUser() {
<span class="fc" id="L326">		return true;</span>
	}

	/**
	 * calculates the squared distance between the user and the specified coordinates
	 *
	 * @param x2 x coordinate
	 * @param y2 y coordinate
	 * @return the squared distance
	 */
	static double squaredDistanceTo(final double x2, final double y2) {
<span class="fc bfc" id="L337" title="All 2 branches covered.">		if (User.isNull()) {</span>
<span class="fc" id="L338">			return Double.POSITIVE_INFINITY;</span>
		}
<span class="fc" id="L340">		return (User.get().getX() - x2) * (User.get().getX() - x2)</span>
				+ (User.get().getY() - y2) * (User.get().getY() - y2);
	}

	/**
	 * is the named player ignored?
	 *
	 * @param name name of player
	 * @return true, if the player should be ignored; false otherwise
	 */
	public static boolean isIgnoring(String name) {
<span class="nc bnc" id="L351" title="All 2 branches missed.">		if (User.isNull()) {</span>
<span class="nc" id="L352">			return false;</span>
		}

<span class="nc" id="L355">		return User.get().ignore.contains(name);</span>
	}

	/**
	 * is the specified charname a buddy of us?
	 *
	 * @param name charname to test
	 * @return true, if it is a buddy, false if it is not a buddy or the user object is unknown.
	 */
	public static boolean hasBuddy(String name) {
<span class="nc bnc" id="L365" title="All 2 branches missed.">		if (User.isNull()) {</span>
<span class="nc" id="L366">			return false;</span>
		}

<span class="nc" id="L369">		RPObject rpobject = User.get().rpObject;</span>
<span class="nc" id="L370">		return rpobject.has(&quot;buddies&quot;, name);</span>
	}

	/**
	 * gets the server release version
	 *
	 * @return server release version or &lt;code&gt;null&lt;/code&gt;
	 */
	public static String getServerRelease() {
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (User.isNull()) {</span>
<span class="nc" id="L380">			return null;</span>
		}

<span class="nc" id="L383">		return User.get().rpObject.get(&quot;release&quot;);</span>
	}

	/**
	 * gets the name of the player's character
	 *
	 * @return charname or &lt;code&gt;null&lt;/code&gt;
	 */
	public static String getCharacterName() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">		if (User.isNull()) {</span>
<span class="nc" id="L393">			return null;</span>
		}
<span class="nc" id="L395">		return User.get().getName();</span>
	}

	/**
	 * Add players to the set of ignored players.
	 * Player names are the attributes prefixed with '_'.
	 *
	 * @param ignoreObj The container object for player names
	 */
	private void addIgnore(RPObject ignoreObj) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">		for (String attr : ignoreObj) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">			if (attr.charAt(0) == '_') {</span>
<span class="nc" id="L407">				ignore.add(attr.substring(1));</span>
			}
<span class="nc" id="L409">		}</span>
<span class="nc" id="L410">	}</span>

	/**
	 * Remove players from the set of ignored players.
	 * Player names are the attributes prefixed with '_'.
	 *
	 * @param ignoreObj The container object for player names
	 */
	private void removeIgnore(RPObject ignoreObj) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">		for (String attr : ignoreObj) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">			if (attr.charAt(0) == '_') {</span>
<span class="nc" id="L421">				ignore.remove(attr.substring(1));</span>
			}
<span class="nc" id="L423">		}</span>
<span class="nc" id="L424">	}</span>

	/**
	 * is the player in a group which shares the loot?
	 *
	 * @return true if this player is a group and it uses shared looting
	 */
	public static boolean isGroupSharingLoot() {
<span class="nc bnc" id="L432" title="All 4 branches missed.">		return groupLootmode != null &amp;&amp; groupLootmode.equals(&quot;shared&quot;);</span>
	}

	/**
	 * checks if the specified player is in the same group as this player
	 *
	 * @param otherPlayer name of the other player
	 * @return true if the other player is in the same group
	 */
	public static boolean isPlayerInGroup(String otherPlayer) {
<span class="nc bnc" id="L442" title="All 2 branches missed.">		if (groupMembers == null) {</span>
<span class="nc" id="L443">			return false;</span>
		}
<span class="nc" id="L445">		return groupMembers.contains(otherPlayer);</span>
	}

	/**
	 * updates the group information
	 *
	 * @param members members
	 * @param lootmode lootmode
	 */
	public static void updateGroupStatus(List&lt;String&gt; members, String lootmode) {
<span class="nc" id="L455">		Set&lt;String&gt; oldGroupMembers = User.groupMembers;</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">		if (members == null) {</span>
<span class="nc" id="L458">			User.groupMembers = null;</span>
		} else {
<span class="nc" id="L460">			User.groupMembers = new HashSet&lt;String&gt;(members);</span>
		}
<span class="nc" id="L462">		User.groupLootmode = lootmode;</span>

		// fire change event to color of player object on minimap
<span class="nc bnc" id="L465" title="All 2 branches missed.">		for (IEntity entity : GameObjects.getInstance()) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">			if (entity instanceof Player) {</span>
<span class="nc bnc" id="L467" title="All 8 branches missed.">				if (((oldGroupMembers != null) &amp;&amp; oldGroupMembers.contains(entity.getName()))</span>
						|| ((User.groupMembers != null) &amp;&amp; User.groupMembers.contains(entity.getName()))) {
<span class="nc" id="L469">					((Player) entity).fireChange(RPEntity.PROP_GROUP_MEMBERSHIP);</span>
				}
			}
<span class="nc" id="L472">		}</span>
<span class="nc" id="L473">	}</span>

	/**
	 * gets the zone name
	 *
	 * @return zone name
	 */
	public String getZoneName() {
<span class="nc" id="L481">		return rpObject.getID().getZoneID();</span>
	}

	@Override
	protected void processPositioning(final RPObject base, final RPObject diff) {
<span class="nc bnc" id="L486" title="All 8 branches missed.">		if (speedPredictor.isActive() &amp;&amp; (diff.has(&quot;direction&quot;) || diff.has(&quot;x&quot;) || diff.has(&quot;y&quot;))) {</span>
<span class="nc" id="L487">			speedPredictor.onMoved();</span>
		}
<span class="nc" id="L489">		super.processPositioning(base, diff);</span>
<span class="nc" id="L490">	}</span>

	/**
	 * Start movement towards a direction. This is for
	 * the client side movement prediction to start moving before the server
	 * responds to the move action.
	 *
	 * @param direction new direction
	 * @param facing &lt;code&gt;true&lt;/code&gt; if the player should just turn
	 */
	public void predictMovement(Direction direction, boolean facing) {
		// Only handle the case of starting movement. Prediction when already
		// moving looks odd.
<span class="nc bnc" id="L503" title="All 2 branches missed.">		if (stopped()) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			if (isConfused()) {</span>
<span class="nc" id="L505">				direction = direction.oppositeDirection();</span>
			}
<span class="nc bnc" id="L507" title="All 2 branches missed.">			if (!facing) {</span>
<span class="nc" id="L508">				double speed = speedPredictor.getSpeed();</span>
<span class="nc" id="L509">				setSpeed(direction.getdx() * speed, direction.getdy() * speed);</span>
<span class="nc" id="L510">				fireChange(PROP_SPEED);</span>
<span class="nc" id="L511">				speedPredictor.startPrediction();</span>
			}
			// setDirection fires the appropriate property for itself
<span class="nc" id="L514">			setDirection(direction);</span>
		}
<span class="nc" id="L516">	}</span>

	/**
	 * Convert a Direction to the corresponding key code.
	 * 
	 * @param direction
	 *        Direction to process
	 * @return
	 *         Corresponding key code, otherwise &lt;code&gt;null&lt;/code&gt;
	 */
	public Integer directionToKeyCode(final Direction direction) {
<span class="nc bnc" id="L527" title="All 5 branches missed.">		switch (direction) {</span>
		case LEFT:
<span class="nc" id="L529">			return KeyEvent.VK_LEFT;</span>
		case RIGHT:
<span class="nc" id="L531">			return KeyEvent.VK_RIGHT;</span>
		case UP:
<span class="nc" id="L533">			return KeyEvent.VK_UP;</span>
		case DOWN:
<span class="nc" id="L535">			return KeyEvent.VK_DOWN;</span>
		default:
<span class="nc" id="L537">			return null;</span>
		}
	}

	/**
	 * Stop the user's movement.
	 */
	public void stopMovement() {
<span class="nc" id="L545">		final RPAction stopAction = new RPAction();</span>

<span class="nc" id="L547">		stopAction.put(TYPE, WALK);</span>
<span class="nc" id="L548">		stopAction.put(MODE, &quot;stop&quot;);</span>

<span class="nc" id="L550">		ClientSingletonRepository.getClientFramework().send(stopAction);</span>
<span class="nc" id="L551">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>