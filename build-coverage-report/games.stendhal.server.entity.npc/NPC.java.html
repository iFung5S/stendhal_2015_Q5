<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NPC.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity.npc</a> &gt; <span class="el_source">NPC.java</span></div><h1>NPC.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *						(C) Copyright 2003 - Marauroa					   *
 ***************************************************************************
 ***************************************************************************
 *																		   *
 *	 This program is free software; you can redistribute it and/or modify  *
 *	 it under the terms of the GNU General Public License as published by  *
 *	 the Free Software Foundation; either version 2 of the License, or	   *
 *	 (at your option) any later version.								   *
 *																		   *
 ***************************************************************************/
package games.stendhal.server.entity.npc;

import games.stendhal.common.Direction;
import games.stendhal.common.Rand;
import games.stendhal.common.constants.Events;
import games.stendhal.common.constants.SoundLayer;
import games.stendhal.server.core.pathfinder.FixedPath;
import games.stendhal.server.core.pathfinder.Node;
import games.stendhal.server.core.pathfinder.Path;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.RPEntity;
import games.stendhal.server.entity.item.Corpse;
import games.stendhal.server.events.SoundEvent;

import java.util.ArrayList;
import java.util.List;

import marauroa.common.game.Definition;
import marauroa.common.game.Definition.Type;
import marauroa.common.game.RPClass;
import marauroa.common.game.RPEvent;
import marauroa.common.game.RPObject;
import marauroa.common.game.SyntaxException;

import org.apache.log4j.Logger;

public abstract class NPC extends RPEntity {
	/**
	 * Probability of generating a sound event at each turn, if the creature has
	 * specified sounds.
	 */
	private static final int SOUND_PROBABILITY = 20;
	/**
	 * Creature sound radius.
	 */
	protected static final int SOUND_RADIUS = 23;
	/**
	 * Minimum delay in milliseconds between playing creature sounds.
	 */
	private static final long SOUND_DEAD_TIME = 10000L;

	/** the logger instance. */
<span class="fc" id="L55">	private static final Logger logger = Logger.getLogger(NPC.class);</span>

	/**
	 * The NPC's current idea/thought.
	 */
	private String idea;

	/**
	 * The range in which the NPC will notice other subjects like players or enemies.
	 */
<span class="fc" id="L65">	private int perceptionRange = 5;</span>

	/**
	 * The range in which the NPC will search for movement paths.
	 */
<span class="fc" id="L70">	private int movementRange = 20;</span>

	/**
	 * Idling between path cycles
	 */
<span class="fc" id="L75">    protected int pauseTurns = 0;</span>
<span class="fc" id="L76">    public int pauseTurnsRemaining = 0;</span>
    protected Direction pauseDirection;

	/**
	 * Possible sound events.
	 */
	private List&lt;String&gt; sounds;
	/** The time stamp of previous sound event. */
	private long lastSoundTime;

	public static void generateRPClass() {
		try {
<span class="fc" id="L88">			final RPClass npc = new RPClass(&quot;npc&quot;);</span>
<span class="fc" id="L89">			npc.isA(&quot;rpentity&quot;);</span>
<span class="fc" id="L90">			npc.addAttribute(&quot;class&quot;, Type.STRING);</span>
<span class="fc" id="L91">			npc.addAttribute(&quot;subclass&quot;, Type.STRING);</span>
			//npc.addAttribute(&quot;text&quot;, Type.LONG_STRING, Definition.VOLATILE);
<span class="fc" id="L93">			npc.addAttribute(&quot;idea&quot;, Type.STRING, Definition.VOLATILE);</span>
<span class="fc" id="L94">			npc.addAttribute(&quot;outfit&quot;, Type.INT);</span>
<span class="nc" id="L95">		} catch (final SyntaxException e) {</span>
<span class="nc" id="L96">			logger.error(&quot;cannot generate RPClass&quot;, e);</span>
<span class="fc" id="L97">		}</span>
<span class="fc" id="L98">	}</span>

	public NPC(final RPObject object) {
<span class="fc" id="L101">		super(object);</span>
<span class="fc" id="L102">		setRPClass(&quot;npc&quot;);</span>
<span class="fc" id="L103">		update();</span>
<span class="fc" id="L104">	}</span>

<span class="fc" id="L106">	public NPC() {</span>
<span class="fc" id="L107">		setRPClass(&quot;npc&quot;);</span>
<span class="fc" id="L108">		put(&quot;type&quot;, &quot;npc&quot;);</span>
<span class="fc" id="L109">	}</span>

	/**
	 * Set the NPC's idea/thought.
	 *
	 * @param idea
	 *			  The idea mnemonic, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public void setIdea(final String idea) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">		if (idea != null) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">			if (!idea.equals(this.idea)) {</span>
<span class="fc" id="L120">				put(&quot;idea&quot;, idea);</span>
			}
<span class="fc bfc" id="L122" title="All 2 branches covered.">		} else if (has(&quot;idea&quot;)) {</span>
<span class="fc" id="L123">			remove(&quot;idea&quot;);</span>
		}

<span class="fc" id="L126">		this.idea = idea;</span>
<span class="fc" id="L127">	}</span>

	/**
	 * Set the possible sound events.
	 *
	 * @param sounds sound name list
	 */
	public void setSounds(List&lt;String&gt; sounds) {
<span class="fc" id="L135">		this.sounds = sounds;</span>
<span class="fc" id="L136">	}</span>

	/**
	 * Get the list of possible sound events.
	 *
	 * @return list of sound names
	 */
	protected List&lt;String&gt; getSounds() {
<span class="fc" id="L144">		return sounds;</span>
	}

	/**
	 * Get the NPC's idea/thought.
	 *
	 * @return The idea mnemonic, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public String getIdea() {
<span class="fc" id="L153">		return idea;</span>
	}

	public void say(final String text) {
<span class="fc" id="L157">		final RPEvent rpe = new RPEvent(Events.PUBLIC_TEXT);</span>
<span class="fc" id="L158">		rpe.put(&quot;text&quot;, text);</span>
<span class="fc" id="L159">		this.addEvent(rpe);</span>
<span class="fc" id="L160">		this.notifyWorldAboutChanges();</span>
<span class="fc" id="L161">	}</span>

	/**
	 * moves to the given entity. When the distance to the destination is
	 * between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; and this entity does
	 * not have a path already one is searched and saved.
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; When the distance to the destination is less than
	 * &lt;code&gt;min&lt;/code&gt; the path is removed. &lt;b&gt;Warning:&lt;/b&gt; The pathfinder
	 * is not asynchronous, so this thread is blocked until a path is found.
	 *
	 * @param destEntity
	 *			  the destination entity
	 * @param min
	 *			  minimum distance to the destination entity
	 * @param max
	 *			  maximum distance to the destination entity
	 * @param maxPathRadius
	 *			  the maximum radius in which a path is searched
	 */
	public void setMovement(final Entity destEntity, final double min, final double max,
			final double maxPathRadius) {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		if (nextTo(destEntity, min)) {</span>
<span class="nc" id="L184">			stop();</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">			if (hasPath()) {</span>
<span class="nc" id="L187">				logger.debug(&quot;Removing path because nextto(&quot;</span>
						+ destEntity.getX() + &quot;,&quot; + destEntity.getY() + &quot;,&quot;
						+ min + &quot;) of (&quot; + getX() + &quot;,&quot; + getY() + &quot;)&quot;);
<span class="nc" id="L190">				clearPath();</span>
			}
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">		} else if ((squaredDistance(destEntity) &gt; max)) {</span>
<span class="nc" id="L193">			logger.debug(&quot;Creating path because (&quot; + getX() + &quot;,&quot; + getY()</span>
					+ &quot;) distance(&quot; + destEntity.getX() + &quot;,&quot;
					+ destEntity.getY() + &quot;)&gt;&quot; + max);
<span class="nc" id="L196">			final List&lt;Node&gt; path = Path.searchPath(this, destEntity, maxPathRadius);</span>
<span class="nc" id="L197">			setPath(new FixedPath(path, false));</span>
		}
<span class="fc" id="L199">	}</span>

	/**
	 * Set a random destination as a path.
	 *
	 * @param distance
	 *			  The maximum axis distance to move.
	 * @param x
	 *			  The origin X coordinate for placement.
	 * @param y
	 *			  The origin Y coordinate for placement.
	 */
	public void setRandomPathFrom(final int x, final int y, final int distance) {
<span class="fc" id="L212">		setUsesRandomPath(true);</span>

<span class="fc" id="L214">		final int dist2_1 = distance + distance + 1;</span>
<span class="fc" id="L215">		final int dx = Rand.rand(dist2_1) - distance;</span>
<span class="fc" id="L216">		final int dy = Rand.rand(dist2_1) - distance;</span>

<span class="fc" id="L218">		final List&lt;Node&gt; path = new ArrayList&lt;Node&gt;(1);</span>
<span class="fc" id="L219">		path.add(new Node(x + dx, y + dy));</span>

<span class="fc" id="L221">		setPath(new FixedPath(path, false));</span>
<span class="fc" id="L222">	}</span>

	/**
	 * Query the range in which the NPC will notice other subjects like players or enemies.
	 * @return perception range
	 */
	public int getPerceptionRange() {
<span class="fc" id="L229">		return perceptionRange;</span>
	}

	/**
	 * Set the perception range.
	 * @param perceptionRange
	 */
	public void setPerceptionRange(int perceptionRange) {
<span class="fc" id="L237">		this.perceptionRange = perceptionRange;</span>
<span class="fc" id="L238">	}</span>

	/**
	 * Query the range in which the NPC will search for movement paths.
	 * @return movement range
	 */
	public int getMovementRange() {
<span class="fc" id="L245">		return movementRange;</span>
	}

	/**
	 * Set the movement range.
	 * @param movementRange
	 */
	public void setMovementRange(int movementRange) {
<span class="fc" id="L253">		this.movementRange = movementRange;</span>
<span class="fc" id="L254">	}</span>

	//
	// RPEntity
	//

	/**
	 * Returns true if this RPEntity is attackable.
	 */
	@Override
	public boolean isAttackable() {
<span class="nc" id="L265">		return false;</span>
	}

	@Override
	protected void dropItemsOn(final Corpse corpse) {
		// sub classes can implement this method
<span class="nc" id="L271">	}</span>

	/**
	 * Checks if the NPC should remain stationary or begin walking
	 */
	public void checkPause() {
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (pauseTurnsRemaining == 0) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (hasPath()) {</span>
<span class="nc" id="L279">                setSpeed(getBaseSpeed());</span>
            }

<span class="nc" id="L282">            applyMovement();</span>
        } else {
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (!stopped()) {</span>
<span class="nc" id="L285">                stop();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                if (pauseDirection != null) {</span>
<span class="nc" id="L287">					setDirection(pauseDirection);</span>
				}
            }

<span class="nc" id="L291">            pauseTurnsRemaining -= 1;</span>
        }
<span class="nc" id="L293">	}</span>

	@Override
	public void logic() {
<span class="nc bnc" id="L297" title="All 2 branches missed.">	    if (atMovementRadius()) {</span>
<span class="nc" id="L298">	        onOutsideMovementRadius();</span>
	    }
<span class="nc bnc" id="L300" title="All 2 branches missed.">		if (!hasPath()) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">		    if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L302">		        String title = getTitle();</span>
<span class="nc" id="L303">		        String zone = getZone().getName();</span>
<span class="nc" id="L304">		        String coords = Integer.toString(getX()) + &quot;, &quot; + Integer.toString(getY());</span>
<span class="nc" id="L305">		        logger.debug(&quot;Moving entity &quot; + title + &quot; at &quot; + zone + &quot; &quot; + coords + &quot; does not have a path&quot;);</span>
		    }
		}

<span class="nc" id="L309">		maybeMakeSound();</span>
<span class="nc" id="L310">		checkPause();</span>
<span class="nc" id="L311">        notifyWorldAboutChanges();</span>
<span class="nc" id="L312">	}</span>

    /**
     * Give NPC a random path
     */
    public void moveRandomly() {
<span class="fc" id="L318">        setRandomPathFrom(getX(), getY(), getMovementRange() / 2);</span>
<span class="fc" id="L319">    }</span>

    @Override
    public void onFinishedPath() {
<span class="fc" id="L323">        super.onFinishedPath();</span>

<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (usesRandomPath()) {</span>
            // FIXME: There is a pause when renewing path
<span class="fc" id="L327">            moveRandomly();</span>
        }

<span class="fc" id="L330">        pauseTurnsRemaining = pauseTurns;</span>
<span class="fc" id="L331">    }</span>

    /**
     * Pause the entity when path is completed.
     * Call setDirection() first to specify which
     * way entity should face during pause.
     *
     * @param pause
     *         Number of turns entity should stay paused
     */
    public void setPathCompletedPause(final int pause) {
        //setPathCompletedPause(pause, getDirection());
<span class="fc" id="L343">        this.pauseTurns = pause;</span>
<span class="fc" id="L344">    }</span>

    public void setPathCompletedPause(final int pause, final Direction dir) {
<span class="nc" id="L347">        this.pauseTurns = pause;</span>
<span class="nc" id="L348">        this.pauseDirection = dir;</span>
<span class="nc" id="L349">    }</span>

    /**
	 * Generate a sound event with the probability of SOUND_PROBABILITY, if
	 * the previous sound event happened long enough ago.
	 */
	protected void maybeMakeSound() {
<span class="fc" id="L356">		maybeMakeSound(SOUND_PROBABILITY);</span>
<span class="fc" id="L357">	}</span>

	/**
	 * Generate a sound event with the specified probability, if
	 * the previous sound event happened long enough ago.
	 *
	 * @param probablility sound probability
	 */
	protected void maybeMakeSound(int probablility) {
<span class="fc bfc" id="L366" title="All 6 branches covered.">		if ((sounds != null) &amp;&amp; !sounds.isEmpty() &amp;&amp; (Rand.rand(100) &lt; probablility)) {</span>
<span class="fc" id="L367">			long time = System.currentTimeMillis();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">			if (lastSoundTime + SOUND_DEAD_TIME &lt; time) {</span>
<span class="fc" id="L369">				lastSoundTime = time;</span>
<span class="fc" id="L370">				this.addEvent(new SoundEvent(Rand.rand(sounds), SOUND_RADIUS, 100, SoundLayer.CREATURE_NOISE));</span>
<span class="fc" id="L371">				this.notifyWorldAboutChanges();</span>
			}
		}
<span class="fc" id="L374">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>