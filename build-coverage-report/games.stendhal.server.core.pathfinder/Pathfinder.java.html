<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Pathfinder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.core.pathfinder</a> &gt; <span class="el_source">Pathfinder.java</span></div><h1>Pathfinder.java</h1><pre class="source lang-java linenums">/*
 * Based on:
 * 
 * AStarPathfinder.java
 * Created on 20 October 2004, 13:33
 *
 * Copyright 2004, Generation5. All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */

package games.stendhal.server.core.pathfinder;


import java.awt.geom.Rectangle2D;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Stack;

/**
 * Implements the A* algorithm. Pathing can be done on any class that implements
 * the &lt;code&gt;Navigable&lt;/code&gt; interface. See org.generation5.ai.Navigable.
 * 
 * @author James Matthews
 * 
 */
public abstract class Pathfinder {
	/**
	 * Returned by &lt;code&gt;getStatus&lt;/code&gt; if a path &lt;i&gt;cannot&lt;/i&gt; be found.
	 * 
	 * @see #getStatus
	 */
	public static final int PATH_NOT_FOUND = -1;

	/**
	 * Returned by &lt;code&gt;getStatus&lt;/code&gt; if a path has been found.
	 * 
	 * @see #getStatus
	 */
	public static final int PATH_FOUND = 1;

	/**
	 * Returned by &lt;code&gt;getStatus&lt;/code&gt; if the pathfinder is still running.
	 * 
	 * @see #getStatus
	 */
	public static final int IN_PROGRESS = 0;
	
	/**
	 * Node weight bonus for nodes that do not change the walking direction.
	 */
	protected static final double STRAIGHT_PATH_PREFERENCE_FACTOR = 0.2;

	/**
	 * The current status of the pathfinder.
	 * 
	 * @see #PATH_FOUND
	 * @see #PATH_NOT_FOUND
	 * @see #IN_PROGRESS
	 */
<span class="fc" id="L76">	private int pathStatus = IN_PROGRESS;</span>
	/**
	 * The open list.
	 */
<span class="fc" id="L80">	private final PriorityQueue&lt;TreeNode&gt; openList = new PriorityQueue&lt;TreeNode&gt;(16,</span>
<span class="fc" id="L81">			new Comparator&lt;TreeNode&gt;() {</span>
		@Override
		public int compare(final TreeNode o1, final TreeNode o2) {
<span class="fc" id="L84">			return (int) Math.signum(o1.weight - o2.weight);</span>
		}
	});

<span class="fc" id="L88">	private final HashMap&lt;Integer, TreeNode&gt; nodeRegistry = new HashMap&lt;Integer, TreeNode&gt;();</span>

	/**
	 * The goal node.
	 */
	protected TreeNode goalNode;

	/**
	 * The start node.
	 */
	protected TreeNode startNode;

	/**
	 * The current best node. The best node is taken from the open list after
	 * every iteration of &lt;code&gt;doStep&lt;/code&gt;.
	 */
	private TreeNode bestNode;
	
	/**
	 * The maximum distance for the path. It is compared with the f value of the
	 * node. The minimum for working pathfinding is
	 * heuristicFromStartNode + 1
	 */
	private double maxDistance;
	
	/**
	 * The goal.
	 */
	private final Rectangle2D goalArea;
	
	/** Initialization data */
	private final int startX, startY;
	/** Initialization data */
	private final Rectangle2D destination;
	/** Initialization data */
	private final double initMaxDist;

<span class="fc" id="L125">	protected Pathfinder(final int startX, final int startY, final Rectangle2D destination, final double maxDist) {</span>
<span class="fc" id="L126">		this.goalArea = destination;</span>

		// Setup the initialization data needed for node creation
<span class="fc" id="L129">		this.startX = startX;</span>
<span class="fc" id="L130">		this.startY = startY;</span>
<span class="fc" id="L131">		this.destination = destination;</span>
<span class="fc" id="L132">		this.initMaxDist = maxDist;</span>

<span class="fc" id="L134">		openList.clear(); </span>
<span class="fc" id="L135">		nodeRegistry.clear();</span>

<span class="fc" id="L137">		bestNode = null;</span>
<span class="fc" id="L138">		pathStatus = IN_PROGRESS;</span>
<span class="fc" id="L139">	}</span>
	
	/**
	 * Initialization that can not be done safely in the constructor.
	 */
	protected void init() {
		/*
		 * createNode is defined in child classes, so it may require
		 * work in the child's constructor. 
		 */
<span class="fc" id="L149">		startNode = createNode(startX, startY);</span>
<span class="fc" id="L150">		goalNode = createNode((int) (destination.getCenterX()),</span>
				(int) (destination.getCenterY()));
<span class="fc" id="L152">		openList.offer(startNode);</span>
<span class="fc" id="L153">		nodeRegistry.put(startNode.nodeNumber, startNode);</span>
		
		// calculate shortest distance and allow a variance of X percent
<span class="fc" id="L156">		final double startF = 1.1 * startNode.getHeuristic(goalNode) + 1;</span>
<span class="fc" id="L157">		this.maxDistance = Math.max(initMaxDist, startF);</span>
<span class="fc" id="L158">	}</span>
	
	/**
	 * Return the current status of the pathfinder.
	 * 
	 * @return the pathfinder status.
	 * @see #pathStatus
	 */
	protected int getStatus() {
<span class="nc" id="L167">		return pathStatus;</span>
	}
	
	public final List&lt;Node&gt; getPath() {
<span class="fc" id="L171">		init();</span>
<span class="fc" id="L172">		final List&lt;Node&gt; list = new LinkedList&lt;Node&gt;();</span>
		
<span class="fc bfc" id="L174" title="All 2 branches covered.">		if (unreachableGoal()) {</span>
<span class="fc" id="L175">			return list;</span>
		}

<span class="fc bfc" id="L178" title="All 2 branches covered.">		while (pathStatus == Pathfinder.IN_PROGRESS) {</span>
<span class="fc" id="L179">			doStep();</span>
		}

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		if (pathStatus == Pathfinder.PATH_FOUND) {</span>
<span class="fc" id="L183">			TreeNode node = bestNode;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">			while (node != null) {</span>
<span class="fc" id="L185">				list.add(0, new Node(node.getX(), node.getY()));</span>
<span class="fc" id="L186">				node = node.getParent();</span>
			}
		}
		/* */

<span class="fc" id="L191">		return list;</span>
	}
	
	/**
	 * Iterate the pathfinder through one step.
	 */
	private void doStep() {
<span class="fc" id="L198">		bestNode = getBest();</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">		if (bestNode == null) {</span>
<span class="nc" id="L200">			pathStatus = PATH_NOT_FOUND;</span>
<span class="nc" id="L201">			return;</span>
		}

<span class="fc bfc" id="L204" title="All 2 branches covered.">		if (reachedGoal(bestNode)) {</span>
<span class="fc" id="L205">			pathStatus = PATH_FOUND;</span>
<span class="fc" id="L206">			return;</span>
		}

<span class="fc" id="L209">		bestNode.createChildren();</span>
<span class="fc" id="L210">	}</span>
	
	/**
	 * Assigns the best node from the open list.
	 * 
	 * @return the best node.
	 */
	private TreeNode getBest() {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">		if (openList.isEmpty()) {</span>
<span class="nc" id="L219">			return null;</span>
		}

<span class="fc" id="L222">		final TreeNode first = openList.poll();</span>
<span class="fc" id="L223">		first.setOpen(false);</span>

<span class="fc" id="L225">		return first;</span>
	}
	
	/**
	 * Checks if the goal is reached.
	 * 
	 * @param nodeBest
	 *            the currently best node
	 * @return true if the goal is reached
	 */
	private boolean reachedGoal(final TreeNode nodeBest) {
<span class="fc" id="L236">		return goalArea.contains(nodeBest.getX(), nodeBest.getY());</span>
	}
	
	/**
	 * Checks if the goal is unreachable. Only the outer nodes of the goal are
	 * checked. There could be other reasons, why a goal is unreachable.
	 * 
	 * @return true checks if the goal is unreachable
	 */
	protected boolean unreachableGoal() {
<span class="fc" id="L246">		final int w = (int) goalArea.getWidth() - 1;</span>
<span class="fc" id="L247">		final int h = (int) goalArea.getHeight() - 1;</span>
<span class="fc" id="L248">		final int x = (int) goalArea.getX();</span>
<span class="fc" id="L249">		final int y = (int) goalArea.getY();</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">		for (int i = 0; i &lt;= w; i++) {</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">			for (int j = 0; j &lt;= h; j++) {</span>
<span class="fc bfc" id="L253" title="All 8 branches covered.">				if ((i == 0) || (j == 0) || (i == w) || (j == h)) {</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">					if (createNode(x + i, y + j).isValid()) {</span>
<span class="fc" id="L255">						return false;</span>
					}
				}
			}
		}

<span class="fc" id="L261">		return true;</span>
	}
	
	/**
	 * Create a new TreeNode
	 * 
	 * @param x x coordinate of the node
	 * @param y y coordinate of the node
	 * @return TreeNode
	 */
	// A workaround for java lacking proper generics
	public abstract TreeNode createNode(final int x, final int y);
	
	
	/**
	 * Calculates the manhattan distance between to positions.
	 * 
	 * @param x1
	 *            x value for position 1
	 * @param y1
	 *            y value for position 1
	 * @param x2
	 *            x value for position 2
	 * @param y2
	 *            y value for position 2
	 * @return manhattan distance between to positions
	 */
	private static int manhattanDistance(final int x1, final int y1, final int x2, final int y2) {
<span class="fc" id="L289">		return Math.abs(x1 - x2) + Math.abs(y1 - y2);</span>
	}

	/**
	 * Calculates the square distance between to positions.
	 * 
	 * @param x1
	 *            x value for position 1
	 * @param y1
	 *            y value for position 1
	 * @param x2
	 *            x value for position 2
	 * @param y2
	 *            y value for position 2
	 * @return square distance between to positions
	 */
	private static int squareDistance(final int x1, final int y1, final int x2, final int y2) {
<span class="fc" id="L306">		return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);</span>
	}

	
	/**
	 * The pathfinder node.
	 */
	protected abstract class TreeNode {

		/**
		 * The f-value.
		 */
		private double weight;

		/**
		 * The g-value.
		 */
		private double g;

		/**
		 * The x-position of the node.
		 */
		private final int x;

		/**
		 * The y-position of the node.
		 */
		private final int y;

		/**
		 * The number of children the node has.
		 */
		private int numChildren;

		/**
		 * The node identifier.
		 */
		private final Integer nodeNumber;

		/**
		 * The parent of the node.
		 */
		private TreeNode parent;

<span class="fc" id="L350">		private final TreeNode[] children = new TreeNode[4];</span>

<span class="fc" id="L352">		private boolean open = true;</span>

		/**
		 * The default constructor with positional information.
		 * 
		 * @param x
		 *            the x-position of the node.
		 * @param y
		 *            the y-position of the node.
		 */
<span class="fc" id="L362">		protected TreeNode(final int x, final int y) {</span>
<span class="fc" id="L363">			this.x = x;</span>
<span class="fc" id="L364">			this.y = y;</span>

<span class="fc" id="L366">			this.nodeNumber = createNodeID(x, y);</span>

<span class="fc" id="L368">			init();</span>
<span class="fc" id="L369">		}</span>

		/**
		 * Resets the node. This involves all f, g and h-values to 0 as well as
		 * removing all children.
		 */
		private void init() {
<span class="fc" id="L376">			this.weight = 0.0;</span>
<span class="fc" id="L377">			this.g = 0.0;</span>
<span class="fc" id="L378">			this.numChildren = 0;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">			for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L380">				this.children[i] = null;</span>
			}

<span class="fc" id="L383">			this.open = true;</span>
<span class="fc" id="L384">		}</span>

		/**
		 * Add a child to the node.
		 * 
		 * @param child
		 *            the child node.
		 */
		private void addChild(final TreeNode child) {
<span class="fc" id="L393">			this.children[numChildren++] = child;</span>

<span class="fc" id="L395">			updateChild(child);</span>
<span class="fc" id="L396">		}</span>

		/**
		 * Add a child to the node.
		 * 
		 * @param child
		 *            the child node.
		 */
		private void updateChild(final TreeNode child) {
<span class="fc" id="L405">			child.parent = this;</span>
<span class="fc" id="L406">			child.g = this.g + child.getCost();</span>
						
<span class="fc" id="L408">			child.weight = calculateChildWeight(child);</span>
<span class="fc" id="L409">		}</span>
		
		/**
		 * Calculate node weight for a child node.
		 * 
		 * @param child the child to be calculated
		 * @return weight for the child node 
		 */
		private double calculateChildWeight(final TreeNode child) {
<span class="fc" id="L418">			double childweight = child.g + child.getHeuristic(goalNode);</span>

			// Prefer nodes that do not result in direction change
<span class="fc bfc" id="L421" title="All 2 branches covered.">			if (parent != null) {</span>
<span class="fc" id="L422">				final int incx = parent.x - x;</span>
<span class="fc" id="L423">				final int incy = parent.y - y;</span>

<span class="fc" id="L425">				final int incx2 = x - child.x;</span>
<span class="fc" id="L426">				final int incy2 = y - child.y;</span>

<span class="pc bpc" id="L428" title="1 of 4 branches missed.">				if ((incx == incx2) &amp;&amp; (incy == incy2)) {</span>
<span class="fc" id="L429">					childweight -= STRAIGHT_PATH_PREFERENCE_FACTOR;</span>
				}
			}
			
<span class="fc" id="L433">			return childweight;</span>
		}

		/**
		 * Return the x-position of the node.
		 * 
		 * @return the x-position of the node.
		 */
		public int getX() {
<span class="fc" id="L442">			return x;</span>
		}

		/**
		 * Return the y-position of the node.
		 * 
		 * @return the y-position of the node.
		 */
		public int getY() {
<span class="fc" id="L451">			return y;</span>
		}

		/**
		 * Return the parent node.
		 * 
		 * @return the parent node.
		 */
		public TreeNode getParent() {
<span class="fc" id="L460">			return parent;</span>
		}
		
		/**
		 * The cost of moving to this node.
		 * 
		 * @return movement cost
		 */
		protected double getCost() {
<span class="fc" id="L469">			return 1.0;</span>
		}

		/**
		 * Calculates the heuristic for the move form node1 to node2. &lt;p&gt; The right
		 * heuristic is very important for A* - a over estimated heuristic will
		 * turn A* in to bsf - a under estimated heuristic will turn A* in to
		 * Dijkstra's so the manhattan distance seams to be the optimal
		 * heuristic here. But it has one disadvantage. It will expand to much.
		 * Several nodes will have the same f value It will search the area of
		 * the size (abs(startX - goalX) + 1) * (abs(startY - goalY) + 1) So a
		 * tie-breaker is needed. 1% square distace seems to work fine. A* will
		 * prefer nodes closer to the goal.
		 * @param nodeGoal 
		 * @return heuristic value for move
		 */
		public double getHeuristic(final TreeNode nodeGoal) {
<span class="fc" id="L486">			final double heuristic = manhattanDistance(x, y, nodeGoal.x, nodeGoal.y);</span>
<span class="fc" id="L487">			final double tieBreaking = 0.01 * squareDistance(x, y, nodeGoal.x,</span>
					nodeGoal.y);

<span class="fc" id="L490">			return heuristic + tieBreaking;</span>
		}

		/**
		 * Checks if the entity could stand on the position of this node.
		 * 
		 * @return true if the the entity could stand on the position
		 */
		public boolean isValid() {
<span class="fc" id="L499">			return isValid(x, y);</span>
		}

		/**
		 * Checks if the entity could stand on the given by the coordinates.
		 * @param x coordinate of the position to be checked
		 * @param y coordinate of the position to be checked
		 * 
		 * @return true if the the entity could stand on the position
		 */
		public abstract boolean isValid(int x, int y);
		
		/**
		 * Create a new &lt;code&gt;TreeNode&lt;/code&gt;.
		 * 
		 * @param x x coordinate of the created node
		 * @param y y coordinate of the created node
		 * @return a &lt;code&gt;TreeNode&lt;/code&gt;
		 */
		// A workaround for java lacking proper generics
		public abstract TreeNode createNode(int x, int y);

		/**
		 * Creates valid child nodes.
		 * &lt;p&gt;
		 * The child nodes have to be
		 * &lt;ul&gt;
		 * &lt;li&gt; a valid position
		 * &lt;li&gt; a f value less than maxDistance (checked against the given node)
		 * &lt;/ul&gt;
		 * 
		 */
		public void createChildren() {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">			if (g &lt; maxDistance) {</span>
<span class="fc" id="L533">				linkChild(x - 1, y + 0);</span>
<span class="fc" id="L534">				linkChild(x + 1, y + 0);</span>
<span class="fc" id="L535">				linkChild(x + 0, y - 1);</span>
<span class="fc" id="L536">				linkChild(x + 0, y + 1);</span>
			}
<span class="fc" id="L538">		}</span>

		/**
		 * Links the children to this parent node  and may also update the
		 * parent path, if a shorter path is found.
		 * @param x1 
		 * @param y1 
		 */
		private void linkChild(final int x1, final int y1) {
<span class="fc bfc" id="L547" title="All 2 branches covered.">			if (!isValid(x1, y1)) {</span>
<span class="fc" id="L548">				return;</span>
			}

			// search for original child node
<span class="fc" id="L552">			TreeNode child = nodeRegistry.get(createNodeID(x1, y1));</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">			if (child == null) {</span>
				// if not found original child node then create a new one
<span class="fc" id="L555">				child = createNode(x1, y1);</span>

<span class="fc" id="L557">				addChild(child);</span>

<span class="fc" id="L559">				openList.offer(child);</span>
<span class="fc" id="L560">				child.setOpen(true);</span>

<span class="fc" id="L562">				nodeRegistry.put(child.nodeNumber, child);</span>
			} else {
				// note:
				// - working on closed nodes is stopped but they may own a better
				// parent
				// so they will also be added to this node (parent)
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">				if (child.g &gt; (this.g + child.getCost())) {</span>
<span class="nc" id="L569">					updateChild(child);</span>
				}

				// update parents for closed nodes only
<span class="fc bfc" id="L573" title="All 2 branches covered.">				if (!child.isOpen()) {</span>
<span class="fc" id="L574">					updateSubTree(child);</span>
				}
			}
<span class="fc" id="L577">		}</span>

		/**
		 * Update the parents for the new route.
		 * 
		 * @param node
		 *            the root node.
		 */
		private void updateSubTree(final TreeNode node) {
<span class="fc" id="L586">			int c = node.numChildren;</span>
<span class="fc" id="L587">			final Stack&lt;TreeNode&gt; nodeStack = new Stack&lt;TreeNode&gt;();</span>

<span class="fc" id="L589">			nodeStack.push(node);</span>

			TreeNode parentTemp;
			TreeNode child;
<span class="fc bfc" id="L593" title="All 2 branches covered.">			while (nodeStack.size() &gt; 0) {</span>
<span class="fc" id="L594">				parentTemp = nodeStack.pop();</span>
<span class="fc" id="L595">				c = parentTemp.numChildren;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">				for (int i = 0; i &lt; c; i++) {</span>
<span class="fc" id="L597">					child = parentTemp.children[i];</span>

<span class="pc bpc" id="L599" title="1 of 2 branches missed.">					if (parentTemp.g + child.getCost() &lt; child.g) {</span>
<span class="nc" id="L600">						parentTemp.updateChild(child);</span>

<span class="nc" id="L602">						nodeStack.push(child);</span>
					}
				}
			}
<span class="fc" id="L606">		}</span>

		/**
		 * Calculates the node id.
		 * @param x of the node
		 * @param y of the node
		 * 
		 * @return the id of the node
		 */
		protected abstract int createNodeID(int x, int y);

		public final boolean isOpen() {
<span class="fc" id="L618">			return open;</span>
		}

		public final void setOpen(final boolean open) {
<span class="fc" id="L622">			this.open = open;</span>
<span class="fc" id="L623">		}</span>

		@Override
		public boolean equals(final Object obj) {
<span class="nc bnc" id="L627" title="All 2 branches missed.">			if (obj instanceof TreeNode) {</span>
<span class="nc" id="L628">				final TreeNode treeN = (TreeNode) obj;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">				return this.nodeNumber.intValue() == treeN.nodeNumber.intValue();</span>
			}
<span class="nc" id="L631">			return false;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L636">			return nodeNumber.hashCode();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>