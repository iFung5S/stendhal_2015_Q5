<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WeatherUpdater.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.core.rp</a> &gt; <span class="el_source">WeatherUpdater.java</span></div><h1>WeatherUpdater.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                (C) Copyright 2003-2014 - Faiumoni E.V.                  *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.core.rp;

import games.stendhal.common.MathHelper;
import games.stendhal.common.Rand;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.ZoneAttributes;
import games.stendhal.server.core.events.TurnListener;
import games.stendhal.server.entity.mapstuff.WeatherEntity;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import marauroa.common.Pair;

import org.apache.log4j.Logger;

/**
 * Manager for zones with changing weather.
 */
public class WeatherUpdater implements TurnListener {
	/** The keyword used by the weather adjustments parser. */
	public static final String WEATHER_KEYWORD = &quot;varying&quot;;
	
	/** Logger instance. */
<span class="nc" id="L40">	private static final Logger LOGGER = Logger.getLogger(WeatherUpdater.class);</span>
	/** Weather attribute string. */
	private static final String WEATHER = &quot;weather&quot;;
	/** Time between checking if the weather should be changed. Seconds. */
	private static final int CHECK_INTERVAL = 79;
	/**
	 * The tendency of weather attributes to keep their current value. Must be
	 * at least 1.
	 */
	private static final int WEATHER_STABILITY = 6;
	/** Upper limit of the temperature attribute. */
	private static final int TEMP_RANGE = 30;
	/** Prevalence of rain. Roughly the percentage of rainy time. */
	private static final double RAININESS = 10;
	/** Prevalence of fog. Roughly the percentage of foggy time. */
	private static final double FOGGINESS = 4;
	/**
	 * Rough percentage of rains that are thunderstorms. Note that triggering
	 * thunder also demands a warm temperature, and this percentage
	 * &lt;em&gt;only&lt;/em&gt; is in effect when the temperature is high enough.
	 */
	private static final double THUNDER_PREVALENCE = 5;
	
	/** Singleton instance. */
<span class="nc" id="L64">	private static final WeatherUpdater INSTANCE = new WeatherUpdater();</span>

	/** Data about managed zones. */
<span class="nc" id="L67">	private final Collection&lt;ZoneData&gt; zones = new ArrayList&lt;ZoneData&gt;();</span>
	
	/**
	 * Rain attribute. The descriptions are &lt;em&gt;modifiers&lt;/em&gt; to be appended
	 * after &quot;rain&quot; or &quot;snow&quot;
	 */
<span class="nc" id="L73">	private final WeatherAttribute rain = new WeatherAttribute((int) Math.round(3 * 100 / RAININESS - 1), &quot;_light&quot;, &quot;&quot;, &quot;_heavy&quot;);</span>
	/**
	 * Temperature. Just to be used as a modifier to decide between rain and
	 * snow.
	 */
<span class="nc" id="L78">	private final WeatherAttribute temperature = new WeatherAttribute(TEMP_RANGE);</span>
	/** Fogginess attribute. Foggy about 1/25 of time. */
<span class="nc" id="L80">	private final WeatherAttribute fog = new WeatherAttribute((int) Math.round(200 / FOGGINESS - 1) , &quot;fog&quot;, &quot;fog_heavy&quot;);</span>
	/**
	 * Thunder attribute. This is used to turn on and off the weather entities
	 * on managed zones. Roughly one in 20 rains will be thunders.
	 */
<span class="nc" id="L85">	private final WeatherAttribute thunder = new WeatherAttribute((int) Math.round(200 / THUNDER_PREVALENCE - 1), &quot;&quot;, &quot;&quot;);</span>

	/**
	 * Create a new WeaterUpdater instance. Do not use this.
	 */
<span class="nc" id="L90">	private WeatherUpdater() {</span>
<span class="nc" id="L91">		onTurnReached(0);</span>
<span class="nc" id="L92">	}</span>

	/**
	 * Get the WeatherUpdater instance.
	 *
	 * @return singleton instance
	 */
	public static WeatherUpdater get() {
<span class="nc" id="L100">		return INSTANCE;</span>
	}

	/**
	 * Make a zone weather managed by the weather updater. Modifiers to the
	 * default weather can be described in form
	 * &quot;varying(rain=value1, temperature=value2, fog=value3)&quot;, where any or all
	 * of the modifiers can be omitted, and their order does not matter.
	 * Description parameter &quot;varying&quot; is interpreted as &quot;varying()&quot;, that is,
	 * no weather modifiers.
	 * &lt;br/&gt;
	 * The values are interpreted so that:
	 * &lt;ul&gt;
	 * &lt;li&gt;One step of &lt;code&gt;rain&lt;/code&gt; corresponds to adding about 5% to rain
	 * 	probability&lt;/li&gt;
	 * &lt;li&gt;One step of &lt;code&gt;temperature&lt;/code&gt; corresponds roughly to one month
	 * 	of time difference (compared to coldest month).&lt;/li&gt;
	 * &lt;li&gt;One step of &lt;code&gt;fog&lt;/code&gt; corresponds to adding about 5%
	 *	to fog probability&lt;/li&gt;
	 * &lt;/ul&gt;
	 * Negative values are interpreted as corresponding decreases. Note that
	 * rain and especially fog have low probabilities to begin with, so they get
	 * easily turned off completely.
	 * &lt;br/&gt;
	 * If a modifier is specified more than once, the last one takes effect.
	 *
	 * @param attr Attributes of the zone
	 * @param desc The weather attribute value specified for the zone. This is
	 * 	used to determine any zone specific modifiers
	 */
	public void manageAttributes(ZoneAttributes attr, String desc) {
<span class="nc" id="L131">		Modifiers mods = Modifiers.getModifiers(desc);</span>
<span class="nc" id="L132">		WeatherEntity entity = new WeatherEntity();</span>
<span class="nc" id="L133">		ZoneData data = new ZoneData(attr, mods, entity);</span>
<span class="nc" id="L134">		zones.add(data);</span>
<span class="nc" id="L135">		attr.getZone().add(entity);</span>
		
<span class="nc" id="L137">		Pair&lt;String, Boolean&gt; weather = describeWeather(Calendar.getInstance(), mods);</span>
<span class="nc" id="L138">		updateAndNotify(data, weather);</span>
<span class="nc" id="L139">	}</span>

	@Override
	public final void onTurnReached(int currentTurn) {
<span class="nc" id="L143">		updateWeatherStates();</span>
<span class="nc" id="L144">		SingletonRepository.getTurnNotifier().notifyInSeconds(CHECK_INTERVAL, this);</span>
<span class="nc" id="L145">	}</span>

	/**
	 * Update the zone weather states.
	 */
	private void updateWeatherStates() {
<span class="nc" id="L151">		boolean changed = temperature.update();</span>
<span class="nc" id="L152">		changed |= rain.update();</span>
<span class="nc" id="L153">		changed |= fog.update();</span>
<span class="nc" id="L154">		changed |= thunder.update();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">		if (changed) {</span>
<span class="nc" id="L156">			updateZones();</span>
		}
<span class="nc" id="L158">	}</span>
	
	/**
	 * Describe the weather based on the current attribute states, time and
	 * zone's weather modifiers.
	 * 
	 * @param calendar determines the time used for  the description
	 * @param mods weather modifiers
	 * 
	 * @return A pair of weather description and a boolean for thunder. The
	 * 	description will be &lt;code&gt;null&lt;/code&gt; for clear skies
	 */
	private Pair&lt;String, Boolean&gt; describeWeather(Calendar calendar, Modifiers mods) {
		// Rain probability should get roughly a raise by 5% for each point,
		// as described for manageAttributes()
<span class="nc" id="L173">		int mod = (int) (mods.rain * 0.05 * rain.getMax());</span>
<span class="nc" id="L174">		String weather = rain.getDescription(mod);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">		if (weather != null) {</span>
<span class="nc" id="L176">			Pair&lt;String, Boolean&gt; rainDesc = describeRain(calendar, mods.temperature);</span>
<span class="nc" id="L177">			return new Pair&lt;String, Boolean&gt;(rainDesc.first() + weather, rainDesc.second());</span>
		} else {
			// Similarly 5% for fog
<span class="nc" id="L180">			mod = (int) (mods.fog * 0.05 * fog.getMax());</span>
<span class="nc" id="L181">			weather = fog.getDescription(mod);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">			if (weather != null) {</span>
<span class="nc" id="L183">				return new Pair&lt;String, Boolean&gt;(weather, Boolean.FALSE);</span>
			}
		}
<span class="nc" id="L186">		return new Pair&lt;String, Boolean&gt;(null, Boolean.FALSE);</span>
	}
	
	/**
	 * Describe either rain or snow, depending on the time, temperature and 
	 * temperature modifiers.
	 * 
	 * @param calendar calendar for checking current time
	 * @param temperatureMod zone's temperature modifier
	 * @return A pair of &quot;rain&quot; or &quot;snow&quot;, and a boolean marking if the rain is
	 * 	thunder
	 */
	private Pair&lt;String, Boolean&gt; describeRain(Calendar calendar, int temperatureMod) {
		// Year time modifier. January is the coldest with effect of -60
<span class="nc" id="L200">		int month = calendar.get(Calendar.MONTH);</span>
<span class="nc" id="L201">		month = 10 * Math.abs(month - 6);</span>
		// Day time modifier. Nights are slightly colder, 03 being the coldest
		// with effect of -6
<span class="nc" id="L204">		int hour = calendar.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L205">		hour = Math.abs((hour + 21) % 24 - 12) / 2;</span>
		// temperatureMod corresponds to a month, as described in
		// manageAttributes() documentation
<span class="nc" id="L208">		int temp = temperature.getValue() - hour - month + (temperatureMod * 10);</span>
<span class="nc" id="L209">		LOGGER.debug(&quot;Modified temp: &quot; + temp + &quot; zone modifier: &quot; + temperatureMod);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (temp &lt;= -30) {</span>
<span class="nc" id="L211">			return new Pair&lt;String, Boolean&gt;(&quot;snow&quot;, Boolean.FALSE);</span>
		}
		// Require warmth for thunder
<span class="nc bnc" id="L214" title="All 4 branches missed.">		return new Pair&lt;String, Boolean&gt;(&quot;rain&quot;, temp &gt;= -5 &amp;&amp; thunder.getDescription(0) != null);</span>
	}
	
	/**
	 * Update a zone's weather attribute, and notify players of the changes.
	 * 
	 * @param zone zone's data set
	 * @param weather Pair of new weather description string, and a Boolean
	 *	determining if thunder should be activated
	 */
	private void updateAndNotify(ZoneData zone, Pair&lt;String, Boolean&gt; weather) {
<span class="nc" id="L225">		ZoneAttributes attr = zone.getAttributes();</span>
<span class="nc" id="L226">		zone.getEntity().setThunder(weather.second());</span>
		
<span class="nc" id="L228">		String desc = weather.first();</span>
<span class="nc" id="L229">		String oldWeather = attr.get(WEATHER);</span>
		// Objects.equals()...
<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (!Objects.equals(desc, oldWeather)) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">			LOGGER.debug(&quot;Weather on &quot; + attr.getZone().describe() + &quot;: &quot;</span>
				+ desc + (weather.second() ? &quot;, thundering&quot; : &quot;&quot;));
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if (desc != null) {</span>
<span class="nc" id="L235">				attr.put(WEATHER, desc);</span>
			} else {
<span class="nc" id="L237">				attr.remove(WEATHER);</span>
			}
			// Notify resident players about the changed weather
<span class="nc" id="L240">			attr.getZone().notifyOnlinePlayers();</span>
		}
<span class="nc" id="L242">	}</span>
	
	/**
	 * Check and update all managed zones.
	 */
	private void updateZones() {
		/*
		 * The night time modifier on temperature would technically be a change,
		 * but it's rather useless to check zones just for that. One of the
		 * attributes will soon change anyway.
		 */
<span class="nc" id="L253">		Calendar calendar = Calendar.getInstance();</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L255">			LOGGER.debug(&quot;Weather change: rain=&quot; + rain.getValue() + &quot;/&quot; </span>
					+ rain.getMax() + &quot;, temp=&quot;	+ temperature.getValue() + &quot;/&quot;
					+ temperature.getMax() + &quot;, fog=&quot; + fog.getValue() + &quot;/&quot;
					+ fog.getMax() + &quot;, thunder=&quot; + thunder.getValue() + &quot;/&quot;
					+ thunder.getMax());
<span class="nc" id="L260">			LOGGER.debug(&quot;Weather on typical zone: &quot; + describeWeather(calendar, Modifiers.getModifiers(WEATHER_KEYWORD)));</span>
<span class="nc" id="L261">			LOGGER.debug(&quot;Rain would be:&quot; + describeRain(calendar, 0).first());</span>
		}
<span class="nc bnc" id="L263" title="All 2 branches missed.">		for (ZoneData zone : zones) {</span>
<span class="nc" id="L264">			updateAndNotify(zone, describeWeather(calendar, zone.getModifiers()));</span>
<span class="nc" id="L265">		}</span>
<span class="nc" id="L266">	}</span>
	
	/**
	 * Describes a zone's weather modifier parameters.
	 */
	private static class Modifiers {
		/** Shared instance for zones that do not need any modifiers. */
<span class="nc" id="L273">		private static final Modifiers NO_MODS = new Modifiers(0, 0, 0);</span>
		/**
		 * Regexp to match weather expressions with the content between
		 * parentheses as the first capturing group.&lt;br/&gt;
		 * 
		 * &lt;em&gt;Some people, when confronted with a problem, think &quot;I know,
		 * I'll use regular expressions.&quot; Now they have two problems.
		 * ­­&amp;mdash; J. Zawinski&lt;/em&gt; 
		 */
<span class="nc" id="L282">		private static final Pattern PATTERN = Pattern.compile(WEATHER_KEYWORD + &quot;(?:\\((.*)\\))?&quot;);</span>
		
		/** Raininess modifier. Added to global rain state. */
		final int rain;
		/** Temperature modifier. Added to global temperature state. */
		final int temperature;
		/** Fogginess modifier. Added to global fog state. */
		final int fog;
		
		/**
		 * Construct a modifier set.
		 * 
		 * @param rainMod rain state modifier
		 * @param tempMod temperature state modifier
		 * @param fogMod fog state modifier
		 */
<span class="nc" id="L298">		private Modifiers(int rainMod, int tempMod, int fogMod) {</span>
<span class="nc" id="L299">			rain = rainMod;</span>
<span class="nc" id="L300">			temperature = tempMod;</span>
<span class="nc" id="L301">			fog = fogMod;</span>
<span class="nc" id="L302">		}</span>
		
		/**
		 * Get a suitable set of modifiers based on a weather description.
		 * 
		 * @param weatherDesc zone's weather description string
		 * @return modifiers
		 */
		static Modifiers getModifiers(String weatherDesc) {
<span class="nc" id="L311">			weatherDesc = weatherDesc.trim();</span>
<span class="nc" id="L312">			Matcher matcher = PATTERN.matcher(weatherDesc);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if (!matcher.matches()) {</span>
<span class="nc" id="L314">				LOGGER.warn(&quot;Failed to parse weather expression: &quot; + weatherDesc + &quot; - fall back to default&quot;);</span>
<span class="nc" id="L315">				return NO_MODS;</span>
			}
			// stuff between parentheses
<span class="nc" id="L318">			String contents = matcher.group(1);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">			if (contents != null) {</span>
<span class="nc" id="L320">				contents = contents.trim();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">				if (!contents.isEmpty()) {</span>
<span class="nc" id="L322">					return getModifiersFromParams(contents);</span>
				}
			}
			// No params, use the default
<span class="nc" id="L326">			return NO_MODS;</span>
		}
		
		/**
		 * Get modifiers from a list of parameters.
		 * 
		 * @param paramContents contents of the parameter list
		 * @return modifiers
		 */
		private static Modifiers getModifiersFromParams(String paramContents) {
<span class="nc" id="L336">			int rain = 0;</span>
<span class="nc" id="L337">			int temperature = 0;</span>
<span class="nc" id="L338">			int fog = 0;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">			for (String param : paramContents.split(&quot;,&quot;)) {</span>
<span class="nc" id="L340">				String[] parts = param.split(&quot;=&quot;);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">				if (parts.length != 2) {</span>
<span class="nc" id="L342">					LOGGER.warn(&quot;Malformed weather parameter: '&quot; + param + &quot;'&quot;);</span>
<span class="nc" id="L343">					continue;</span>
				}
<span class="nc" id="L345">				int value = MathHelper.parseInt(parts[1].trim());</span>
<span class="nc" id="L346">				String modType = parts[0].trim();</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">				if (&quot;rain&quot;.equals(modType)) {</span>
<span class="nc" id="L348">					rain = value;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">				} else if (&quot;temperature&quot;.equals(modType)) {</span>
<span class="nc" id="L350">					temperature = value;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">				} else if (&quot;fog&quot;.equals(modType)) {</span>
<span class="nc" id="L352">					fog = value;</span>
				} else {
<span class="nc" id="L354">					LOGGER.warn(&quot;Unknown weather modifier: '&quot; + modType + &quot;'&quot;);</span>
				}
			}
<span class="nc bnc" id="L357" title="All 2 branches missed.">			if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L358">				LOGGER.debug(&quot;rain, temperature, fog = &quot; + rain + &quot; &quot; + temperature + &quot; &quot; + fog);</span>
			}
<span class="nc bnc" id="L360" title="All 6 branches missed.">			if (rain != 0 || temperature != 0 || fog != 0) {</span>
<span class="nc" id="L361">				return new Modifiers(rain, temperature, fog);</span>
			}
			// If the parameters were not non-zero, or no parameters
			// were successfully read, use the NO_MODS constant
<span class="nc" id="L365">			return NO_MODS;</span>
		}
	}
	
	/**
	 * Weather attribute with a range, and optionally a set of descriptions.
	 */
	private static class WeatherAttribute {
		/** Maximum value of the attribute. */
		private final int maxValue;
		/** State descriptions. */
		private final String[] desc;
		/** Current value of the attribute. */
		private int value;
		/** The change direction of the attribute. [-1, 1] */
		private int change;
		
		/**
		 * Create a WeatherAttribute with a maximum value and a set of
		 * descriptions.
		 * 
		 * @param max maximum value of the attribute
		 * @param desc descriptions. If there are fewer descriptions than
		 * 	possible values, then the descriptions correspond to the
		 * 	&lt;em&gt;high&lt;/em&gt; end values, and the description for the lower end
		 * 	values are &lt;code&gt;null&lt;/code&gt;
		 */
<span class="nc" id="L392">		WeatherAttribute(int max, String... desc) {</span>
<span class="nc" id="L393">			maxValue = max;</span>
<span class="nc" id="L394">			value = Rand.rand(max + 1);</span>
<span class="nc" id="L395">			this.desc = desc;</span>
<span class="nc" id="L396">		}</span>
		
		/**
		 * Update the attribute's internal state randomly.
		 * 
		 * @return &lt;code&gt;true&lt;/code&gt; if value of the attribute changed. Note
		 * 	that the corresponding &lt;em&gt;description&lt;/em&gt; did not necessarily
		 * 	change, and its changing may depend on the maps' weather modifiers.
		 */
		boolean update() {
<span class="nc" id="L406">			change += Rand.rand(2 * WEATHER_STABILITY + 1) - WEATHER_STABILITY;</span>
			// Favor stability. This also keeps the change rate at range [-1, 1] 
<span class="nc" id="L408">			change /= WEATHER_STABILITY;</span>
<span class="nc" id="L409">			int oldValue = value;</span>
<span class="nc" id="L410">			value = MathHelper.clamp(value + change, 0, maxValue);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">			return value != oldValue;</span>
		}
		
		/**
		 * Get the value of the attribute. The value is in range [0, max], where
		 * &lt;code&gt;max&lt;/code&gt; is the value given to the constructor.
		 * 
		 * @return attribute value
		 */
		int getValue() {
<span class="nc" id="L421">			return value;</span>
		}
		
		/**
		 * Get the maximum value of the attribute.
		 * 
		 * @return maximum value
		 */
		int getMax() {
<span class="nc" id="L430">			return maxValue;</span>
		}
		
		/**
		 * Get the description corresponding to the current value of the
		 * attribute, taking in account a weather modifier.
		 *  
		 * @param modifier weather modifier
		 * @return description, and &lt;code&gt;null&lt;/code&gt; if the corresponding
		 * 	weather state has no description.
		 */
		String getDescription(int modifier) {
<span class="nc" id="L442">			int adjusted = MathHelper.clamp(value + modifier, 0, maxValue);</span>
<span class="nc" id="L443">			int idx = adjusted - (maxValue - desc.length) - 1;</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">			if (idx &gt;= 0) {</span>
<span class="nc" id="L445">				return desc[idx];</span>
			}
<span class="nc" id="L447">			return null;</span>
		}
	}
	
	/**
	 * Container for weather related zone data.
	 */
	private static class ZoneData {
		/** Zone's attribute map. */
		private final ZoneAttributes attributes;
		/** Weather modifiers of the zone. */
		private final Modifiers modifiers;
		/** Weather entity of the zone. */
		private final WeatherEntity entity;
		
		/**
		 * Create a ZoneData.
		 * 
		 * @param attributes zone's attributes
		 * @param modifiers zone's weather modifiers
		 * @param entity weather entity of the zone
		 */
<span class="nc" id="L469">		ZoneData(ZoneAttributes attributes, Modifiers modifiers, WeatherEntity entity) {</span>
<span class="nc" id="L470">			this.attributes = attributes;</span>
<span class="nc" id="L471">			this.modifiers = modifiers;</span>
<span class="nc" id="L472">			this.entity = entity;</span>
<span class="nc" id="L473">		}</span>
		
		/**
		 * Get the zone's attribute map.
		 * 
		 * @return zone attributes
		 */
		ZoneAttributes getAttributes() {
<span class="nc" id="L481">			return attributes;</span>
		}
		
		/**
		 * Get the zone's weather modifiers.
		 * 
		 * @return modifiers
		 */
		Modifiers getModifiers() {
<span class="nc" id="L490">			return modifiers;</span>
		}
		
		/**
		 * Get the zone's weather entity.
		 * 
		 * @return weather entity
		 */
		WeatherEntity getEntity() {
<span class="nc" id="L499">			return entity;</span>
		}
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>