<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StendhalRPAction.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.core.rp</a> &gt; <span class="el_source">StendhalRPAction.java</span></div><h1>StendhalRPAction.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                      (C) Copyright 2003 - Marauroa                      *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.core.rp;

import games.stendhal.common.Rand;
import games.stendhal.common.constants.Testing;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.server.core.engine.DataProvider;
import games.stendhal.server.core.engine.GameEvent;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.core.engine.db.StendhalKillLogDAO;
import games.stendhal.server.core.events.TutorialNotifier;
import games.stendhal.server.core.events.ZoneNotifier;
import games.stendhal.server.core.pathfinder.Node;
import games.stendhal.server.core.pathfinder.Path;
import games.stendhal.server.core.rp.group.Group;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.RPEntity;
import games.stendhal.server.entity.creature.DomesticAnimal;
import games.stendhal.server.entity.creature.Pet;
import games.stendhal.server.entity.creature.Sheep;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.item.StackableItem;
import games.stendhal.server.entity.npc.SpeakerNPC;
import games.stendhal.server.entity.player.Player;
import games.stendhal.server.events.AttackEvent;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Shape;
import java.util.LinkedList;
import java.util.List;

import marauroa.common.net.message.TransferContent;
import marauroa.server.game.db.DAORegister;
import marauroa.server.game.rp.RPServerManager;

import org.apache.log4j.Logger;

/**
 * fighting and player teleport support
 */
<span class="nc" id="L54">public class StendhalRPAction {</span>
	/** the logger instance. */
<span class="fc" id="L56">	private static final Logger logger = Logger.getLogger(StendhalRPAction.class);</span>
	
	/**
	 * The amount to weight ATK and DEF in player strength calculation. Higher
	 * means more weight to stats vs level. Value 0.73 has been obtained from
	 * a least square fit of players equally strong to an actual player killer.
	 */
	private static final double STRENGTH_STATS_MULTIPLIER = 0.73;
	/**
	 * Maximum strength ratio where it is still acceptable to attack another
	 * player otherwise than in a self defense situation.
	 */
	private static final double ACCEPTABLE_STRENGTH_RATIO = 0.75;

	/** server manager. */
	private static RPServerManager rpman;

	/**
	 * initializes the StendhalRPAction
	 *
	 * @param rpMan RPServerManager
	 */
	public static void initialize(final RPServerManager rpMan) {
<span class="nc" id="L79">		StendhalRPAction.rpman = rpMan;</span>
<span class="nc" id="L80">	}</span>


	/**
	 * Do logic for starting an attack on an entity.
	 *
	 * @param player
	 *            The player wanting to attack.
	 * @param victim
	 *            The target of attack.
	 */
	public static void startAttack(final Player player, final RPEntity victim) {
		// Player's can't attack themselves
<span class="fc bfc" id="L93" title="All 2 branches covered.">		if (player.equals(victim)) {</span>
<span class="fc" id="L94">			return;</span>
		}

		// Disable attacking NPCS that are created as not attackable.
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">		if (!victim.isAttackable()) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">			if ((victim instanceof SpeakerNPC)) {</span>
<span class="nc" id="L100">				((SpeakerNPC) victim).say(player.getName() + &quot;, if you want my attention, just say #hi.&quot;);</span>
			}
<span class="nc" id="L102">			logger.info(&quot;REJECTED. &quot; + player.getName() + &quot; is attacking &quot; + victim.getName());</span>
<span class="nc" id="L103">			return;</span>
		}

		// Enabled PVP
<span class="fc bfc" id="L107" title="All 4 branches covered.">		if ((victim instanceof Player) || (victim instanceof DomesticAnimal)) {</span>
<span class="fc" id="L108">			final StendhalRPZone zone = player.getZone();</span>

			// Make sure that you can't attack players or sheep (even wild
			// sheep) who are inside a protection area. Also prevent attacking
			// from such an area, in name of fairness
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">			if (zone.isInProtectionArea(victim) || (zone.isInProtectionArea(player))) {</span>
<span class="fc" id="L114">				logger.info(&quot;REJECTED. &quot; + victim.getName()</span>
						+ &quot; is protected by zone&quot;);

<span class="fc" id="L117">				final String name = getNiceVictimName(victim);</span>

<span class="fc" id="L119">				player.sendPrivateText(&quot;The powerful protective aura in this place prevents you from attacking &quot;</span>
						+ name + &quot;.&quot;);
<span class="fc" id="L121">				return;</span>
			}

<span class="fc bfc" id="L124" title="All 2 branches covered.">			if (victim instanceof Player) {</span>
				// disable attacking much weaker players, except in/ self defense
<span class="fc bfc" id="L126" title="All 2 branches covered.">				if (!mayAttackPlayer(player, (Player) victim)) {</span>
<span class="fc" id="L127">					player.sendPrivateText(&quot;Your conscience would trouble you if you carried out this attack.&quot;);</span>
<span class="fc" id="L128">					return;</span>
				}
			} else {
				// Only allow owners, if there is one, to attack the pet
<span class="fc" id="L132">				final Player owner = ((DomesticAnimal) victim).getOwner();</span>
<span class="fc bfc" id="L133" title="All 4 branches covered.">				if ((owner != null) &amp;&amp; (owner != player)) {</span>
<span class="fc" id="L134">					player.sendPrivateText(&quot;You pity &quot; + getNiceVictimName(victim) + &quot; too much to kill it.&quot;);</span>

<span class="fc" id="L136">					return;</span>
				}
			}

<span class="fc" id="L140">			logger.info(player.getName() + &quot; is attacking &quot; + victim.getName());</span>
		}

<span class="fc" id="L143">		StendhalKillLogDAO killLog = DAORegister.get().get(StendhalKillLogDAO.class);</span>
<span class="fc" id="L144">		new GameEvent(player.getName(), &quot;attack&quot;, victim.getName(), killLog.entityToType(player), killLog.entityToType(victim)).raise();</span>

<span class="fc" id="L146">		player.setTarget(victim);</span>
<span class="fc" id="L147">		player.faceToward(victim);</span>
<span class="fc" id="L148">		player.applyClientDirection(false);</span>
<span class="fc" id="L149">		player.notifyWorldAboutChanges();</span>
<span class="fc" id="L150">	}</span>

	/**
	 * checks whether a player may attack another player
	 *
	 * @param attacker attacker
	 * @param victim   victim
	 * @return true, if the attack is acceptable
	 */
	private static boolean mayAttackPlayer(final Player attacker, final Player victim) {

		// is the victim is of similar strength
<span class="fc bfc" id="L162" title="All 2 branches covered.">		if (victimIsStrongEnough(attacker, victim)) {</span>
<span class="fc" id="L163">			return true;</span>
		}

		// allow self defence
<span class="fc" id="L167">		RPEntity victimsTarget = victim.getAttackTarget();</span>
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">		if ((victimsTarget == null) || !(victimsTarget instanceof Player)) {</span>
<span class="fc" id="L169">			return false;</span>
		}
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">		if (victimsTarget == attacker) {</span>
<span class="fc" id="L172">			return true;</span>
		}

		// allow defence of group members
<span class="nc" id="L176">		Group group = SingletonRepository.getGroupManager().getGroup(victimsTarget.getName());</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">		if (group == null) {</span>
<span class="nc" id="L178">			return false;</span>
		}

<span class="nc" id="L181">		return group.hasMember(attacker.getName());</span>
	}

	/**
	 * Check that the victim has high enough level compared to the attacker.
	 *
	 * @param player The player trying to attack
	 * @param victim The entity being attacked
	 * @return &lt;code&gt;true&lt;/code&gt; if the victim is strong enough to allow
	 *  the attack to happen, &lt;code&gt;false&lt;/code&gt; otherwise.
	 */
	private static boolean victimIsStrongEnough(final Player player, final Player victim) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">		return getPlayerStrength(victim) &gt;= ACCEPTABLE_STRENGTH_RATIO * getPlayerStrength(player);</span>
	}

	/**
	 * Get the relative strength of a player, ignoring equipment.
	 *
	 * @param player
	 * @return player strength
	 */
	private static double getPlayerStrength(final Player player) {
		int combatSum;
<span class="fc" id="L204">		combatSum = player.getAtk() + player.getDef();</span>
		
<span class="fc" id="L206">		return STRENGTH_STATS_MULTIPLIER * combatSum + player.getLevel();</span>
	}

	/**
	 * Get a nice target description string to be sent to the attacker in case
	 * the attacking action is forbidden.
	 *
	 * @param victim The attacked entity
	 * @return Description of the attacked pet or player
	 */
	private static String getNiceVictimName(final RPEntity victim) {
<span class="fc" id="L217">		String name = victim.getTitle();</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">		if (victim instanceof DomesticAnimal) {</span>
<span class="fc" id="L220">			final Player owner = ((DomesticAnimal) victim).getOwner();</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">			if (owner != null) {</span>
<span class="fc" id="L223">				name = Grammar.suffix_s(owner.getTitle()) + &quot; &quot; + name;</span>
			} else {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">				if (victim instanceof Sheep) {</span>
<span class="fc" id="L226">					name = &quot;that &quot; + name;</span>
				} else {
<span class="nc" id="L228">					name = &quot;that poor little &quot; + name;</span>
				}
			}
		}

<span class="fc" id="L233">		return name;</span>
	}

	/**
	 * Lets the attacker try to attack the defender.
	 * @param player
	 *
	 * @param defender
	 *            The defending RPEntity.
	 * @return true iff the attacker has done damage to the defender.
	 *
	 */
	public static boolean playerAttack(final Player player, final RPEntity defender) {
<span class="fc" id="L246">		boolean result = false;</span>

<span class="fc" id="L248">		final StendhalRPZone zone = player.getZone();</span>
<span class="pc bpc" id="L249" title="2 of 4 branches missed.">		if (!zone.has(defender.getID()) || (defender.getHP() == 0)) {</span>
<span class="nc" id="L250">			logger.debug(&quot;Attack from &quot; + player + &quot; to &quot; + defender</span>
					+ &quot; stopped because target was lost(&quot;
					+ zone.has(defender.getID()) + &quot;) or dead.&quot;);
<span class="nc" id="L253">			player.stopAttack();</span>

<span class="nc" id="L255">			return false;</span>
		}

<span class="fc" id="L258">		defender.rememberAttacker(player);</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">		if (defender instanceof Player) {</span>
<span class="nc" id="L260">			player.storeLastPVPActionTime();</span>

			// did the player or victim move into a protected area?
<span class="nc bnc" id="L263" title="All 4 branches missed.">			if(zone.isInProtectionArea(defender) || zone.isInProtectionArea(player)) {</span>
<span class="nc" id="L264">				logger.debug(&quot;Attack from &quot; + player + &quot; to &quot; + defender</span>
						+ &quot; stopped because &quot; + player + &quot; or &quot; + defender + &quot; moved into protected area.&quot;);
<span class="nc" id="L266">				player.stopAttack();</span>
<span class="nc" id="L267">				return false;</span>
			}
		}

<span class="fc" id="L271">		boolean isRanged = false;</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">		if (!player.nextTo(defender)) {</span>
			// The attacker is not directly standing next to the defender.
			// Find out if he can attack from the distance.
<span class="nc bnc" id="L275" title="All 2 branches missed.">			if (player.canDoRangeAttack(defender, player.getMaxRangeForArcher())) {</span>

				// Check line of view to see if there is any obstacle.
<span class="nc bnc" id="L278" title="All 2 branches missed.">				if (!player.hasLineOfSight(defender)) {</span>
<span class="nc" id="L279">					return false;</span>
				}

<span class="nc" id="L282">				isRanged = true;</span>
			} else {
<span class="nc" id="L284">				logger.debug(&quot;Attack from &quot; + player + &quot; to &quot; + defender</span>
						+ &quot; failed because target is not near.&quot;);
<span class="nc" id="L286">				return false;</span>
			}
		}
		
		// Weapon for the purpose of attack image
<span class="fc" id="L291">		Item attackWeapon = player.getWeapon();</span>
<span class="fc" id="L292">		String weaponClass = null;</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">		if (attackWeapon != null) {</span>
<span class="nc" id="L294">			weaponClass = attackWeapon.getWeaponType();</span>
		}
		
		// Throw dices to determine if the attacker has missed the defender
<span class="fc" id="L298">		final boolean beaten = player.canHit(defender);</span>

		/* TODO: Remove if alternate attack training method implemented in
		 *       game.
		 *
		 * Current ATK XP training system allows training ATK XP only if the
		 * player has recently received damage from the target. ATK experience
		 * increases even if attack is blocked.
		 */
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">		if (!Testing.COMBAT) {</span>
			// disabled attack xp for attacking NPC's
<span class="pc bpc" id="L309" title="2 of 4 branches missed.">			if (!(defender instanceof SpeakerNPC)</span>
					&amp;&amp; player.getsFightXpFrom(defender)) {
<span class="nc" id="L311">				player.incAtkXP();</span>
			}
		}

<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (beaten) {</span>
<span class="pc bpc" id="L316" title="3 of 4 branches missed.">			if ((defender instanceof Player)</span>
					&amp;&amp; defender.getsFightXpFrom(player)) {
<span class="nc" id="L318">				defender.incDefXP();</span>
			}

<span class="fc" id="L321">			final List&lt;Item&gt; weapons = player.getWeapons();</span>

<span class="fc" id="L323">			int damage = player.damageDone(defender, player.getItemAtk(), player.getDamageType());</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (damage &gt; 0) {</span>

				// limit damage to target HP
<span class="fc" id="L327">				damage = Math.min(damage, defender.getHP());</span>
<span class="fc" id="L328">				player.handleLifesteal(player, weapons, damage);</span>

<span class="fc" id="L330">				defender.onDamaged(player, damage);</span>
<span class="fc" id="L331">				logger.debug(&quot;attack from &quot; + player.getID() + &quot; to &quot;</span>
						+ defender.getID() + &quot;: Damage: &quot; + damage);

<span class="fc" id="L334">				result = true;</span>
				/* TODO: Remove condition for alternate attack training method
				 *       when implemented in game.
				 * TODO: Remove condition for ranged attack stat when
				 *       implemented in game.
				 */
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">				if (Testing.COMBAT) {</span>
					/* Alternate ATK XP training method raises player's ATK or
					 * RATK experience only when player has successfully hit
					 * the target regardless of whether player has recently
					 * taken damage.
					 */
<span class="nc bnc" id="L346" title="All 2 branches missed.">					if (!(defender instanceof SpeakerNPC)) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">						if (isRanged) {</span>
<span class="nc" id="L348">							player.incRatkXP();</span>
						} else {
<span class="nc" id="L350">							player.incAtkXP();</span>
						}
					}
				}
			} else {
				// The attack was too weak, it was blocked
<span class="fc" id="L356">				logger.debug(&quot;attack from &quot; + player.getID() + &quot; to &quot;</span>
						+ defender.getID() + &quot;: Damage: &quot; + 0);
			}
			//deteriorate weapons of attacker
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">			for (Item weapon : weapons) {</span>
<span class="nc" id="L361">				weapon.deteriorate();</span>
<span class="nc" id="L362">			}</span>
			//randomly choose one defensive item to deteriorate
<span class="fc" id="L364">			List&lt;Item&gt; defenseItems = defender.getDefenseItems();</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">			if(!defenseItems.isEmpty()) {</span>
<span class="nc" id="L366">				Rand.rand(defenseItems).deteriorate();</span>
			}
			
<span class="fc" id="L369">			player.addEvent(new AttackEvent(true, damage, player.getDamageType(), weaponClass, isRanged));</span>
<span class="fc" id="L370">			player.notifyWorldAboutChanges();</span>
<span class="fc" id="L371">		} else {</span>
			// Missed
<span class="fc" id="L373">			logger.debug(&quot;attack from &quot; + player.getID() + &quot; to &quot;</span>
					+ defender.getID() + &quot;: Missed&quot;);
<span class="fc" id="L375">			player.addEvent(new AttackEvent(false, 0, player.getDamageType(), weaponClass, isRanged));</span>
<span class="fc" id="L376">			player.notifyWorldAboutChanges();</span>
		}

<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if (isRanged) {</span>
			// Removing the missile is deferred here so that the weapon
			// information is available when calculating the damage.
<span class="nc" id="L382">			useMissile(player);</span>
		}

<span class="fc" id="L385">		player.notifyWorldAboutChanges();</span>

<span class="fc" id="L387">		return result;</span>
	}

	/**
	 * Remove an used up missile from an attacking player.
	 *
	 * @param player The player to remove the projectile from
	 */
	private static void useMissile(Player player) {
		// Get the projectile that will be thrown/shot.
<span class="nc" id="L397">		StackableItem projectilesItem = null;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">		if (player.getRangeWeapon() != null) {</span>
<span class="nc" id="L399">			projectilesItem = player.getAmmunition();</span>
		}
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (projectilesItem == null) {</span>
			// no arrows... but maybe a spear?
<span class="nc" id="L403">			projectilesItem = player.getMissileIfNotHoldingOtherWeapon();</span>
		}
		// Creatures can attack without having projectiles, but players
		// will lose a projectile for each shot.
<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (projectilesItem != null) {</span>
<span class="nc" id="L408">			projectilesItem.removeOne();</span>
		}
<span class="nc" id="L410">	}</span>

	/**
	 * send the content of the zone the player is in to the client.
	 *
	 * @param player player
	 */
	public static void transferContent(final Player player) {
<span class="fc" id="L418">		final StendhalRPZone zone = player.getZone();</span>
<span class="fc" id="L419">		transferContent(player, zone.getContents());</span>
<span class="fc" id="L420">	}</span>


<span class="fc" id="L423">	private static DataProvider dataProvider = new DataProvider();</span>
	/**
	 * transfers arbritary content
	 *
	 * @param player   player
	 * @param contents content
	 */
	public static void transferContent(Player player, List&lt;TransferContent&gt; contents) {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">		if (rpman != null) {</span>
<span class="nc" id="L432">			List&lt;TransferContent&gt; allContent = new LinkedList&lt;TransferContent&gt;(contents);</span>
<span class="nc" id="L433">			List&lt;TransferContent&gt; temp = dataProvider.getData(player.getClientVersion());</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">			if (temp != null) {</span>
<span class="nc" id="L435">				allContent.addAll(temp);</span>
			}
<span class="nc" id="L437">			rpman.transferContent(player, allContent);</span>
<span class="nc" id="L438">		} else {</span>
<span class="fc" id="L439">			logger.warn(&quot;rpmanager not found&quot;);</span>
		}
<span class="fc" id="L441">	}</span>

	/**
	 * Change an entity's zone based on it's global world coordinates.
	 *
	 * @param entity
	 *            The entity changing zones.
	 * @param x
	 *            The entity's old zone X coordinate.
	 * @param y
	 *            The entity's old zone Y coordinate.
	 */
	public static void decideChangeZone(final Entity entity, final int x, final int y) {
<span class="nc" id="L454">		final StendhalRPZone origin = entity.getZone();</span>

<span class="nc" id="L456">		final int entity_x = x + origin.getX();</span>
<span class="nc" id="L457">		final int entity_y = y + origin.getY();</span>

<span class="nc" id="L459">		final StendhalRPZone zone = SingletonRepository.getRPWorld().getZoneAt(</span>
				origin.getLevel(), entity_x, entity_y, entity);

<span class="nc bnc" id="L462" title="All 2 branches missed.">		if (zone != null) {</span>
<span class="nc" id="L463">			final int nx = entity_x - zone.getX();</span>
<span class="nc" id="L464">			final int ny = entity_y - zone.getY();</span>

<span class="nc bnc" id="L466" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L467">				logger.debug(&quot;Placing &quot; + entity.getTitle() + &quot; at &quot;</span>
						+ zone.getName() + &quot;[&quot; + nx + &quot;,&quot; + ny + &quot;]&quot;);
			}

<span class="nc bnc" id="L471" title="All 2 branches missed.">			if (!placeat(zone, entity, nx, ny)) {</span>
<span class="nc" id="L472">				logger.warn(&quot;Could not place &quot; + entity.getTitle() + &quot; at &quot;</span>
						+ zone.getName() + &quot;[&quot; + nx + &quot;,&quot; + ny + &quot;]&quot;);
			}
<span class="nc" id="L475">		} else {</span>
<span class="nc" id="L476">			logger.warn(&quot;Unable to choose a new zone for entity: &quot;</span>
					+ entity.getTitle() + &quot; at (&quot; + entity_x + &quot;,&quot; + entity_y
					+ &quot;) source was &quot; + origin.getName() + &quot; at (&quot; + x + &quot;, &quot;
					+ y + &quot;)&quot;);
		}
<span class="nc" id="L481">	}</span>

	/**
	 * Places an entity at a specified position in a specified zone. If this
	 * point is occupied the entity is moved slightly. This will remove the
	 * entity from any existing zone and add it to the target zone if needed.
	 *
	 * @param zone
	 *            zone to place the entity in
	 * @param entity
	 *            the entity to place
	 * @param x
	 *            x
	 * @param y
	 *            y
	 * @return true, if it was possible to place the entity, false otherwise
	 */
	public static boolean placeat(final StendhalRPZone zone, final Entity entity, final int x,
			final int y) {
<span class="fc" id="L500">		return placeat(zone, entity, x, y, null);</span>
	}


	/**
	 * maximum walking distance from the center, determines the area checked.
	 * the total area checked is 2n(n+1) + 1
	 * 36 =&gt; 2665 squares
	 */
	private static final int maxDisplacement = 36;

	/**
	 * Places an entity at a specified position in a specified zone. This will
	 * remove the entity from any existing zone and add it to the target zone if
	 * needed.
	 *
	 * @param zone
	 *            zone to place the entity in
	 * @param entity
	 *            the entity to place
	 * @param x
	 *            x
	 * @param y
	 *            y
	 * @param allowedArea
	 *            only search within this area for a possible new position
	 * @return true, if it was possible to place the entity, false otherwise
	 */
	public static boolean placeat(final StendhalRPZone zone, final Entity entity, int x,
			int y, final Shape allowedArea) {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">		if (zone == null) {</span>
<span class="nc" id="L531">			return false;</span>
		}

		// check in case of players that that they are still in game
		// because the entity is added to the world again otherwise.
<span class="fc bfc" id="L536" title="All 2 branches covered.">		if (entity instanceof Player) {</span>
<span class="fc" id="L537">			final Player player = (Player) entity;</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">			if (player.isDisconnected()) {</span>
<span class="nc" id="L539">				return true;</span>
			}
		}

<span class="fc bfc" id="L543" title="All 2 branches covered.">		if (zone.collides(entity, x, y)) {</span>
<span class="fc" id="L544">			boolean checkPath = true;</span>
<span class="fc bfc" id="L545" title="All 4 branches covered.">			if (zone.collides(entity, x, y, false) &amp;&amp; (entity instanceof Player)) {</span>
				// Trying to place a player on a spot with a real collision
				// (not caused by objects). Can happen with teleport.
				// Try to put him anywhere possible without checking the path.
<span class="fc" id="L549">				checkPath = false;</span>
			}

<span class="fc" id="L552">			final Point newLocation = findLocation(zone, entity, allowedArea, x, y, checkPath);</span>

<span class="fc bfc" id="L554" title="All 2 branches covered.">			if (newLocation == null) {</span>
<span class="fc" id="L555">				logger.info(&quot;Unable to place &quot; + entity.getTitle() + &quot; at &quot;</span>
						+ zone.getName() + &quot;[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);
<span class="fc" id="L557">				return false;</span>
			}

<span class="fc" id="L560">			x = newLocation.x;</span>
<span class="fc" id="L561">			y = newLocation.y;</span>
		}

<span class="fc" id="L564">		final StendhalRPZone oldZone = entity.getZone();</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">		final boolean zoneChanged = (oldZone != zone);</span>

<span class="fc bfc" id="L567" title="All 2 branches covered.">		if (entity instanceof RPEntity) {</span>
<span class="fc" id="L568">			final RPEntity rpentity = (RPEntity) entity;</span>

			/* XXX: Allow players to continue moving after zone change without
			 *      having to press direction again.
			 */
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">			if (!Testing.MOVEMENT) {</span>
<span class="fc" id="L574">				rpentity.stop();</span>
			}
<span class="fc" id="L576">			rpentity.stopAttack();</span>
<span class="fc" id="L577">			rpentity.clearPath();</span>
		}

<span class="fc" id="L580">		Sheep sheep = null;</span>
<span class="fc" id="L581">		Pet pet = null;</span>

		// Remove from old zone (if any) during zone change
<span class="fc bfc" id="L584" title="All 2 branches covered.">		if (oldZone != null) {</span>
			// Player specific pre-remove handling
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">			if (entity instanceof Player) {</span>
<span class="fc" id="L587">				final Player player = (Player) entity;</span>

				// Remove and remember dependents
<span class="fc" id="L590">				sheep = player.getSheep();</span>

<span class="pc bpc" id="L592" title="1 of 2 branches missed.">				if (sheep != null) {</span>
<span class="nc" id="L593">					sheep.clearPath();</span>
<span class="nc" id="L594">					sheep.stop();</span>

<span class="nc" id="L596">					player.removeSheep(sheep);</span>
				}

<span class="fc" id="L599">				pet = player.getPet();</span>

<span class="pc bpc" id="L601" title="1 of 2 branches missed.">				if (pet != null) {</span>
<span class="nc" id="L602">					pet.clearPath();</span>
<span class="nc" id="L603">					pet.stop();</span>

<span class="nc" id="L605">					player.removePet(pet);</span>
				}
			}

<span class="fc bfc" id="L609" title="All 2 branches covered.">			if (zoneChanged) {</span>
<span class="fc" id="L610">				oldZone.remove(entity);</span>
			}
		}

		// [Re]position (possibly while between zones)
<span class="fc" id="L615">		entity.setPosition(x, y);</span>

		// Place in new zone (if needed)
<span class="fc bfc" id="L618" title="All 2 branches covered.">		if (zoneChanged) {</span>
<span class="fc" id="L619">			zone.add(entity);</span>
		}

		// Player specific post-change handling
<span class="fc bfc" id="L623" title="All 2 branches covered.">		if (entity instanceof Player) {</span>
<span class="fc" id="L624">			final Player player = (Player) entity;</span>

			//  Move and re-add removed dependents
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">			if (sheep != null) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">				if (placePet(zone, player, sheep)) {</span>
<span class="nc" id="L629">					player.setSheep(sheep);</span>
<span class="nc" id="L630">					sheep.setOwner(player);</span>
				} else {
					// Didn't fit?
<span class="nc" id="L633">					player.sendPrivateText(&quot;You seemed to have lost your sheep while trying to squeeze in.&quot;);</span>
				}
			}

<span class="pc bpc" id="L637" title="1 of 2 branches missed.">			if (pet != null) {</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">				if (placePet(zone, player, pet)) {</span>
<span class="nc" id="L639">					player.setPet(pet);</span>
<span class="nc" id="L640">					pet.setOwner(player);</span>
				} else {
					// Didn't fit?
<span class="nc" id="L643">					player.sendPrivateText(&quot;You seemed to have lost your pet while trying to squeeze in.&quot;);</span>
				}
			}

<span class="fc bfc" id="L647" title="All 2 branches covered.">			if (zoneChanged) {</span>
				// Zone change notifications/updates
<span class="fc" id="L649">				transferContent(player);</span>

<span class="fc bfc" id="L651" title="All 2 branches covered.">				if (oldZone != null) {</span>
<span class="fc" id="L652">					final String source = oldZone.getName();</span>
<span class="fc" id="L653">					final String destination = zone.getName();</span>

<span class="fc" id="L655">					new GameEvent(player.getName(), &quot;change zone&quot;, destination).raise();</span>

<span class="fc" id="L657">					TutorialNotifier.zoneChange(player, source, destination);</span>
<span class="fc" id="L658">					ZoneNotifier.zoneChange(player, source, destination);</span>
				}
			}
		}

<span class="pc bpc" id="L663" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L664">			logger.debug(&quot;Placed &quot; + entity.getTitle() + &quot; at &quot;</span>
					+ zone.getName() + &quot;[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);
		}

<span class="fc" id="L668">		return true;</span>
	}

	/**
	 * Finds a new place for entity.
	 * @param zone zone to place the entity in
	 * @param entity the entity to place
	 * @param allowedArea only search within this area for a possible new position,
	 * 	or null if the whole normal search area should be used
	 * @param x the x coordinate of the search center
	 * @param y the y coordinate of the search center
	 * @param checkPath if true, check that there's a valid path to the center
	 *
	 * @return location of the new placement, or null if no suitable place was found
	 */
	private static Point findLocation(final StendhalRPZone zone, final Entity entity,
			final Shape allowedArea, final int x, final int y, final boolean checkPath) {

		// Minimum Euclidean distance within minimum walking distance
<span class="fc bfc" id="L687" title="All 2 branches covered.">		for (int totalShift = 1; totalShift &lt;= maxDisplacement; totalShift++) {</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">			for (int tilt = (totalShift + 1) / 2; tilt &gt; 0; tilt--) {</span>
<span class="fc" id="L689">				final int spread = totalShift - tilt;</span>

<span class="fc" id="L691">				int tmpx = x - tilt;</span>
<span class="fc" id="L692">				int tmpy = y - spread;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="fc" id="L694">					return new Point(tmpx, tmpy);</span>
				}
<span class="fc" id="L696">				tmpx = x + tilt;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="fc" id="L698">					return new Point(tmpx, tmpy);</span>
				}
<span class="fc" id="L700">				tmpy = y + spread;</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L702">					return new Point(tmpx, tmpy);</span>
				}
<span class="fc" id="L704">				tmpx = x - tilt;</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L706">					return new Point(tmpx, tmpy);</span>
				}

				// center spots of the equidistance rectangle.
<span class="fc bfc" id="L710" title="All 2 branches covered.">				if (spread == tilt) {</span>
<span class="fc" id="L711">					continue;</span>
				}

<span class="fc" id="L714">				tmpx = x - spread;</span>
<span class="fc" id="L715">				tmpy = y - tilt;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="fc" id="L717">					return new Point(tmpx, tmpy);</span>
				}
<span class="fc" id="L719">				tmpx = x + spread;</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L721">					return new Point(tmpx, tmpy);</span>
				}
<span class="fc" id="L723">				tmpy = y + tilt;</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="fc" id="L725">					return new Point(tmpx, tmpy);</span>
				}
<span class="fc" id="L727">				tmpx = x - spread;</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">				if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L729">					return new Point(tmpx, tmpy);</span>
				}
			}

			// Do tilt = 0 case here, since it takes only 4 checks
<span class="fc" id="L734">			int tmpx = x;</span>
<span class="fc" id="L735">			int tmpy = y - totalShift;</span>
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">			if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L737">				return new Point(tmpx, tmpy);</span>
			}
<span class="fc" id="L739">			tmpy = y + totalShift;</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">			if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L741">				return new Point(tmpx, tmpy);</span>
			}
<span class="fc" id="L743">			tmpy = y;</span>
<span class="fc" id="L744">			tmpx = x - totalShift;</span>
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">			if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L746">				return new Point(tmpx, tmpy);</span>
			}
<span class="fc" id="L748">			tmpx = x + totalShift;</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">			if (isValidPlacement(zone, entity, allowedArea, x, y, tmpx, tmpy, checkPath)) {</span>
<span class="nc" id="L750">				return new Point(tmpx, tmpy);</span>
			}
		}

<span class="fc" id="L754">		return null;</span>
	}

	/**
	 * Checks if a new placement for an entity is valid.
	 *
	 * @param zone the zone where the entity should be placed
	 * @param entity the entity to place
	 * @param allowedArea if specified, restrict placement within this area
	 * @param oldX the x coordinate from where the entity was displaced
	 * @param oldY the y coordinate from where the entity was displaced
	 * @param newX the x coordinate of the new placement
	 * @param newY the y coordinate of the new placement
	 * @param checkPath if true, check that there is a path from &lt;code&gt;(newX, newY)&lt;/code&gt;
	 * to &lt;code&gt;(oldX, oldY)&lt;/code&gt;
	 *
	 * @return true if placing is possible, false otherwise
	 */
	private static boolean isValidPlacement(final StendhalRPZone zone, final Entity entity,
			final Shape allowedArea, final int oldX, final int oldY,
			final int newX, final int newY, final boolean checkPath) {
<span class="fc bfc" id="L775" title="All 2 branches covered.">		if (!zone.collides(entity, newX, newY)) {</span>
			// Check the possibleArea now. This is a performance
			// optimization because the pathfinding is very expensive.
<span class="pc bpc" id="L778" title="3 of 4 branches missed.">			if ((allowedArea != null) &amp;&amp; (!allowedArea.contains(newX, newY))) {</span>
<span class="nc" id="L779">				return false;</span>
			}
<span class="fc bfc" id="L781" title="All 2 branches covered.">			if (!checkPath) {</span>
<span class="fc" id="L782">				return true;</span>
			}

			// We verify that there is a walkable path between the original
			// spot and the new destination. This is to prevent players to
			// enter not allowed places by logging in on top of other players.
			// Or monsters to spawn on the other side of a wall.
<span class="fc" id="L789">			final List&lt;Node&gt; path = Path.searchPath(entity, zone,</span>
					oldX, oldY, new Rectangle(newX, newY, 1, 1),
					400 /* maxDestination * maxDestination */, false);
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">			if (!path.isEmpty()) {</span>
				// We found a place!
<span class="fc" id="L794">				return true;</span>
			}
		}
<span class="fc" id="L797">		return false;</span>
	}

	/**
	 * Place a pet near player in such a way that it likely does not block the
	 * player at normal zone switch. The pet will be placed so that it has a
	 * path to the player.
	 *
	 * @param zone
	 * @param player
	 * @param pet
	 * @return &lt;code&gt;true&lt;/code&gt; if the pet could be placed properly, false
	 * 	otherwise
	 */
	private static boolean placePet(final StendhalRPZone zone, final Player player,
			final Entity pet) {
		// Shift the pet a bit, so that it does not usually end up exactly in
		// front of the player.
<span class="nc bnc" id="L815" title="All 2 branches missed.">		if (placeat(zone, pet, player.getX() + 1, player.getY() + 1)) {</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">			if (!Path.searchPath(pet, player, 20).isEmpty()) {</span>
<span class="nc" id="L817">				return true;</span>
			}
		}
		// Failed to find a path from the new location. Just try to find
		// some location with a path to the player
<span class="nc" id="L822">		Point p = findLocation(zone, pet, null, player.getX(), player.getY(), true);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">		if (p != null) {</span>
<span class="nc" id="L824">			return placeat(zone, pet, p.x, p.y);</span>
		}

<span class="nc" id="L827">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>