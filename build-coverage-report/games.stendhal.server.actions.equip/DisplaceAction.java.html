<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DisplaceAction.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.actions.equip</a> &gt; <span class="el_source">DisplaceAction.java</span></div><h1>DisplaceAction.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                   (C) Copyright 2003-2016 - Marauroa                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.actions.equip;

import static games.stendhal.common.constants.Actions.BASEITEM;
import static games.stendhal.common.constants.Actions.X;
import static games.stendhal.common.constants.Actions.Y;
import games.stendhal.server.actions.ActionListener;
import games.stendhal.server.actions.CommandCenter;
import games.stendhal.server.core.engine.GameEvent;
import games.stendhal.server.core.engine.ItemLogger;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.core.pathfinder.Node;
import games.stendhal.server.core.pathfinder.Path;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.PassiveEntity;
import games.stendhal.server.entity.item.Corpse;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.item.StackableItem;
import games.stendhal.server.entity.player.Player;
import games.stendhal.server.util.EntityHelper;

import java.awt.Rectangle;
import java.util.List;

import marauroa.common.game.RPAction;

import org.apache.log4j.Logger;

/**
 * Moving of items around on the ground.
 */
<span class="fc" id="L42">public class DisplaceAction implements ActionListener {</span>

<span class="fc" id="L44">	private static Logger logger = Logger.getLogger(DisplaceAction.class);</span>

	/**
	 * register this action.
	 */
	public static void register() {
<span class="fc" id="L50">		CommandCenter.register(&quot;displace&quot;, new DisplaceAction());</span>
<span class="fc" id="L51">	}</span>

	/**
	 * handle movement of items.
	 * @param player
	 * @param action
	 */
	@Override
	public void onAction(final Player player, final RPAction action) {

<span class="pc bpc" id="L61" title="3 of 6 branches missed.">		if (!action.has(BASEITEM) || !action.has(X) || !action.has(Y)) {</span>
<span class="nc" id="L62">			logger.error(&quot;Incomplete DisplaceAction: &quot; + action);</span>
<span class="nc" id="L63">			return;</span>
		}

<span class="fc" id="L66">		final int targetObject = action.getInt(BASEITEM);</span>
<span class="fc" id="L67">		int quantity = -1;</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">		if (action.has(&quot;quantity&quot;)) {</span>
<span class="fc" id="L69">			quantity = action.getInt(&quot;quantity&quot;);</span>
		}
<span class="fc" id="L71">		final StendhalRPZone zone = player.getZone();</span>

<span class="fc" id="L73">		final Entity object = EntityHelper.entityFromZoneByID(targetObject, zone);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (!(object instanceof PassiveEntity)) {</span>
<span class="fc" id="L75">			return;</span>
		}

<span class="fc" id="L78">		final int x = action.getInt(X);</span>
<span class="fc" id="L79">		final int y = action.getInt(Y);</span>

<span class="pc bpc" id="L81" title="1 of 4 branches missed.">		if ((x == object.getX()) &amp;&amp; (y == object.getY())) {</span>
			/*
			 * Not actually moving anything. Don't check access rights an
			 * possibly send confusing messages to the player who
			 * didn't really do anything.
			 */
<span class="nc" id="L87">			return;</span>
		}

<span class="fc" id="L90">		final PassiveEntity entity = (PassiveEntity) object;</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">		if (mayDisplace(player, zone, x, y, entity)) {</span>
<span class="fc" id="L93">			displace(player, zone, x, y, entity, quantity);</span>
		}
<span class="fc" id="L95">	}</span>

	/**
	 * Checks whether this entity may be moved around on the ground.
	 *
	 * @param player Player attempting the move
	 * @param zone   Zone
	 * @param x      x-position
	 * @param y      y-position
	 * @param entity entity to move
	 * @return true, iff allowed
	 */
	private boolean mayDisplace(final Player player, final StendhalRPZone zone, final int x, final int y, final PassiveEntity entity) {
<span class="pc bpc" id="L108" title="3 of 14 branches missed.">		return nextTo(player, entity)</span>
				&amp;&amp; (!isItemBelowOtherPlayer(player, entity))
				&amp;&amp; destInRange(player, entity, x, y)
				&amp;&amp; !entityCollides(player, zone, x, y, entity)
				&amp;&amp; (isGamblingZoneAndIsDice(entity, player) || pathToDest(player, zone, x, y, entity))
				&amp;&amp; !isNotOwnCorpseAndTooFar(entity, player, x, y);
	}

	/**
	 * Checks whether the player is next to the entity and provides feedback to player if not.
	 * 
	 * @param player
	 *            the player doing the displacement
	 * @param entity
	 *            the entity being displaced
	 * @return true, if next to; false otherwise
	 */

	private boolean nextTo(final Player player, final PassiveEntity entity) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">		if (!player.nextTo(entity)) {</span>
<span class="fc" id="L128">			player.sendPrivateText(&quot;You must be next to something you wish to move.&quot;);</span>
		}
<span class="fc" id="L130">		return player.nextTo(entity);</span>
	}

	/**
	 * Checks whether the item is below &lt;b&gt;another&lt;/b&gt; player and provides feedback to player.
	 * 
	 * @param player
	 *            the player doing the displacement
	 * @param entity
	 *            the entity being displaced
	 * @return true, if it cannot be taken; false otherwise
	 */
	private boolean isItemBelowOtherPlayer(final Player player, final Entity entity) {
		// prevent taking of items which are below other players
<span class="fc" id="L144">		final List&lt;Player&gt; players = player.getZone().getPlayers();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">		for (final Player otherPlayer : players) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">			if (player.equals(otherPlayer)) {</span>
<span class="fc" id="L147">				continue;</span>
			}
			// Allow players always pick up their own items
<span class="pc bpc" id="L150" title="1 of 4 branches missed.">			if ((entity instanceof Item) &amp;&amp; player.getName().equals(((Item) entity).getBoundTo())) {</span>
<span class="fc" id="L151">				return false;</span>
			}
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">			if (otherPlayer.getArea().intersects(entity.getArea())) {</span>
<span class="fc" id="L154">				player.sendPrivateText(&quot;You cannot take items which are below other players.&quot;);</span>
<span class="fc" id="L155">				return true;</span>
			}
<span class="nc" id="L157">		}</span>
<span class="fc" id="L158">		return false;</span>
	}

	/**
	 * Checks whether the destination is in range and provides feedback to player if not.
	 * 
	 * @param player
	 *            the player doing the displacement
	 * @param entity destination entity 
	 * @param x      x-position
	 * @param y      y-position
	 * @return true, if in range; false otherwise
	 */
	private boolean destInRange(final Player player, final Entity entity, final int x, final int y) {
		// Calculate from the center to make moving large items, like big corpses feel more natural
<span class="fc" id="L173">		int centerX = (int) (x + (entity.getArea().getWidth() / 2));</span>
<span class="fc" id="L174">		int centerY = (int) (y + (entity.getArea().getHeight() / 2));</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (!(player.squaredDistance(centerX, centerY) &lt; (EquipUtil.MAX_THROWING_DISTANCE * EquipUtil.MAX_THROWING_DISTANCE))) {</span>
<span class="fc" id="L177">			player.sendPrivateText(&quot;You cannot throw that far.&quot;);</span>
<span class="fc" id="L178">			return false;</span>
		} else {
<span class="fc" id="L180">			return true;</span>
		}
	}

	/**
	 * Checks whether the destination is a collision.
	 *
	 * @param player Player attempting the move
	 * @param zone   Zone
	 * @param x      x-position
	 * @param y      y-position
	 * @param entity entity to move
	 * @return true, iff allowed
	 */
	private boolean entityCollides(final Player player, final StendhalRPZone zone, final int x, final int y, final PassiveEntity entity) {
<span class="fc" id="L195">		boolean res = zone.simpleCollides(entity, x, y, entity.getWidth(), entity.getHeight());</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">		if (res) {</span>
<span class="fc" id="L197">			player.sendPrivateText(&quot;There is no space there.&quot;);</span>
		}
<span class="fc" id="L199">		return res;</span>
	}

	/**
	 * Checks whether there is a path from player to destination.
	 *
	 * @param player Player attempting the move
	 * @param zone   Zone
	 * @param x      x-position
	 * @param y      y-position
	 * @param entity entity to move
	 * @return true, iff allowed
	 */
	private boolean pathToDest(final Player player, final StendhalRPZone zone, final int x, final int y, final PassiveEntity entity) {
<span class="fc" id="L213">		final List&lt;Node&gt; path = Path.searchPath(entity, zone,</span>
				player.getX(), player.getY(), new Rectangle(x, y, 1, 1),
				64 /* maxDestination * maxDestination */, false);
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">		if (path.isEmpty()) {</span>
<span class="nc" id="L217">			player.sendPrivateText(&quot;There is no easy path to that place.&quot;);</span>
		}
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">		return !path.isEmpty();</span>
	}

	/* returns true if zone is semos tavern and entity is dice */
	private boolean isGamblingZoneAndIsDice(final Entity entity, final Player player) {
<span class="fc" id="L224">		final StendhalRPZone zone = player.getZone();</span>
<span class="pc bpc" id="L225" title="3 of 4 branches missed.">		return &quot;int_semos_tavern_0&quot;.equals(zone.getName()) &amp;&amp; (&quot;dice&quot;).equals(entity.getTitle());</span>
	}

	/* returns true if entity is a corpse, it's not owner by that player, and the distance is far */
	private boolean isNotOwnCorpseAndTooFar(final Entity entity, final Player player, final int x, final int y) {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">		if(entity instanceof Corpse) {</span>
<span class="nc" id="L231">			Corpse corpse = (Corpse) entity;</span>
<span class="nc" id="L232">			String owner = corpse.getCorpseOwner();</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">			if ((owner!= null) &amp;&amp; !player.getTitle().equals(owner)) {</span>
<span class="nc" id="L234">				int centerX = (int) (x + (entity.getArea().getWidth() / 2));</span>
<span class="nc" id="L235">				int centerY = (int) (y + (entity.getArea().getHeight() / 2));</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">				if (!(player.squaredDistance(centerX, centerY) &lt; (entity.getArea().getWidth() * entity.getArea().getHeight()))) {</span>
<span class="nc" id="L237">					player.sendPrivateText(&quot;You cannot throw that corpse so far while the protection of &quot; + owner + &quot; is heavy upon it.&quot;);</span>
<span class="nc" id="L238">					return true;</span>
				}
			}
		}
<span class="fc" id="L242">		return false;</span>
	}

	/**
	 * Moves an entity to a new location within the same zone.
	 *
	 * @param player the player doing the move
	 * @param zone   the zone
	 * @param x      new x-position
	 * @param y      new y-position
	 * @param entity entity to move
	 * @param quantity quantity of moved entities
	 */
	private void displace(final Player player, final StendhalRPZone zone, final int x, final int y, final PassiveEntity entity, final int quantity) {
<span class="fc" id="L256">		new GameEvent(player.getName(), &quot;displace&quot;, entity.get(&quot;type&quot;)).raise();</span>

<span class="fc" id="L258">		final int oldX = entity.getX();</span>
<span class="fc" id="L259">		final int oldY = entity.getY();</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">		if (entity instanceof Item) {</span>
<span class="fc" id="L262">			final Item item = (Item) entity;</span>
<span class="fc" id="L263">			StackableItem stackableItem = null;</span>

<span class="pc bpc" id="L265" title="1 of 2 branches missed.">			if (item instanceof StackableItem) {</span>
<span class="fc" id="L266">				stackableItem = (StackableItem) item;</span>
			}

			Item newItem;

<span class="pc bpc" id="L271" title="2 of 6 branches missed.">			if ((quantity &gt; 0) &amp;&amp; (stackableItem != null) &amp;&amp; (quantity &lt; stackableItem.getQuantity())) {</span>
<span class="fc" id="L272">				newItem = removeFromWorld(player, stackableItem, quantity);</span>
			} else {
<span class="fc" id="L274">				item.onRemoveFromGround();</span>
<span class="fc" id="L275">				newItem = item;</span>
			}

<span class="fc" id="L278">			newItem.setPosition(x, y);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">			if (newItem != item) {</span>
<span class="fc" id="L280">				zone.add(newItem);</span>
			}
<span class="fc" id="L282">			newItem.notifyWorldAboutChanges();</span>
<span class="fc" id="L283">			newItem.onPutOnGround(player);</span>

<span class="fc" id="L285">			new ItemLogger().displace(player, newItem, zone, oldX, oldY, x, y);</span>
<span class="fc" id="L286">		} else {</span>
<span class="fc" id="L287">			entity.setPosition(x, y);</span>
<span class="fc" id="L288">			entity.notifyWorldAboutChanges();</span>
		}
<span class="fc" id="L290">	}</span>

	/**
	 * Removes the entity from the world and returns it (so it may be added
	 * again). The splitted StackableItem is reduced and a new StackableItem
	 * with the splitted off amount is returned.
	 * 
	 * @param player player performing the action
	 * @param stackableItem splitted item stack
	 * @param quantity amount to split
	 * @return Entity to place somewhere else in the world
	 */
	private Item removeFromWorld(final Player player, final StackableItem stackableItem, final int quantity) {
<span class="fc" id="L303">		final StackableItem newItem = stackableItem.splitOff(quantity);</span>
<span class="fc" id="L304">		new ItemLogger().splitOff(player, stackableItem, newItem, quantity);</span>
<span class="fc" id="L305">		return newItem;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>