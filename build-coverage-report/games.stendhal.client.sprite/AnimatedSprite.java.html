<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AnimatedSprite.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.sprite</a> &gt; <span class="el_source">AnimatedSprite.java</span></div><h1>AnimatedSprite.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.sprite;


import java.awt.Graphics;
import java.util.Arrays;

import org.apache.log4j.Logger;

/**
 * This is a sprite that transparently animates itself when drawn.
 */
public class AnimatedSprite implements Sprite {
<span class="nc" id="L25">	private static Logger logger = Logger.getLogger(AnimatedSprite.class);</span>

	/**
	 * The identifier reference.
	 */
	private Object reference;

	/**
	 * Whether the sprite is currently animating.
	 */
	private boolean animating;

	/**
	 * The amount of time passed in the cycle.
	 */
	private int cycleTime;

	/**
	 * The [minimum] frame durations.
	 */
	protected int[] delays;

	/**
	 * The total duration of a cycle.
	 */
	private int duration;

	/**
	 * The current frame index.
	 */
	private int index;

	/**
	 * The frame sprites.
	 */
	protected Sprite[] frames;

	/**
	 * The sprite height.
	 */
	private int height;

	/**
	 * The time of the last update.
	 */
	protected long lastUpdate;

	/**
	 * Whether to loop after last frame.
	 */
	protected boolean loop;

	/**
	 * The current sprite.
	 */
	protected Sprite sprite;

	/**
	 * The sprite width.
	 */
	private int width;

	/**
	 * Create an animated sprite from a set of frame sprites.
	 * 
	 * &lt;strong&gt;NOTE: The array of frames passed is not copied, and must not be
	 * modified while this instance exists (unless you are sure you know what
	 * you are doing).&lt;/strong&gt;
	 * 
	 * @param frames
	 *            The frames to animate.
	 * @param delay
	 *            The minimum delay between frames (in ms).
	 * 
	 * @throws IllegalArgumentException
	 *             If less than one frame is given, or the delay is &lt; 0.
	 */
	AnimatedSprite(final Sprite[] frames, final int delay) {
<span class="nc" id="L103">		this(frames, delay, true);</span>
<span class="nc" id="L104">	}</span>

	/**
	 * Create an animated sprite from a set of frame sprites.
	 * 
	 * &lt;strong&gt;NOTE: The array of frames passed is not copied, and must not be
	 * modified while this instance exists (unless you are sure you know what
	 * you are doing).&lt;/strong&gt;
	 * 
	 * @param frames
	 *            The frames to animate.
	 * @param delay
	 *            The minimum delay between frames (in ms).
	 * @param animating
	 *            If animation is enabled.
	 * 
	 * @throws IllegalArgumentException
	 *             If less than one frame is given, or the delay is &lt; 0.
	 */
	public AnimatedSprite(final Sprite[] frames, final int delay,
			final boolean animating) {
<span class="nc" id="L125">		this(frames, delay, animating, null);</span>
<span class="nc" id="L126">	}</span>

	/**
	 * Create an animated sprite from a set of frame sprites.
	 * 
	 * &lt;strong&gt;NOTE: The array of frames passed is not copied, and must not be
	 * modified while this instance exists (unless you are sure you know what
	 * you are doing).&lt;/strong&gt;
	 * 
	 * @param frames
	 *            The frames to animate.
	 * @param delay
	 *            The minimum delay between frames (in ms).
	 * @param animating
	 *            If animation is enabled.
	 * @param reference
	 *            The sprite identifier reference.
	 * 
	 * @throws IllegalArgumentException
	 *             If less than one frame is given, or the delay is &lt; 0.
	 */
	private AnimatedSprite(final Sprite[] frames, final int delay,
			final boolean animating, final Object reference) {
<span class="nc" id="L149">		this(frames, createDelays(delay, frames.length), animating, reference);</span>
<span class="nc" id="L150">	}</span>

	/**
	 * Create an animated sprite from a set of frame sprites.
	 * 
	 * &lt;strong&gt;NOTE: The array of frames/delays passed is not copied, and must
	 * not be modified while this instance exists (unless you are sure you know
	 * what you are doing).&lt;/strong&gt;
	 * 
	 * @param frames
	 *            The frames to animate.
	 * @param delays
	 *            The minimum duration for each frame (in ms).
	 * @param animating
	 *            If animation is enabled.
	 * @param reference
	 *            The sprite identifier reference.
	 * 
	 * @throws IllegalArgumentException
	 *             If less than one frame is given, or the delay is &lt; 0.
	 */
	AnimatedSprite(final Sprite[] frames, final int[] delays,
<span class="nc" id="L172">			final boolean animating, final Object reference) {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (frames.length == 0) {</span>
<span class="nc" id="L174">			logger.warn(&quot;AnimatedSprite needs at least one frame&quot;);</span>
		}

<span class="nc bnc" id="L177" title="All 2 branches missed.">		if (delays.length != frames.length) {</span>
<span class="nc" id="L178">			throw new IllegalArgumentException(</span>
					&quot;Mismatch between number of frame sprites and delays&quot;);
		}

		/*
		 * Validate delay values. Calculate total cycle duration.
		 */
<span class="nc" id="L185">		duration = 0;</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">		for (int i = 0; i &lt; delays.length; i++) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			if (delays[i] &lt; 0) {</span>
<span class="nc" id="L189">				throw new IllegalArgumentException(&quot;Delay &lt; 0&quot;);</span>
			}

<span class="nc" id="L192">			duration += delays[i];</span>
		}

<span class="nc" id="L195">		this.frames = frames;</span>
<span class="nc" id="L196">		this.delays = delays;</span>
<span class="nc" id="L197">		this.animating = animating;</span>
<span class="nc" id="L198">		this.reference = reference;</span>

<span class="nc" id="L200">		loop = true;</span>

<span class="nc" id="L202">		height = 0;</span>
<span class="nc" id="L203">		width = 0;</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">		for (final Sprite frame : frames) {</span>
<span class="nc" id="L206">			height = Math.max(height, frame.getHeight());</span>
<span class="nc" id="L207">			width = Math.max(width, frame.getWidth());</span>
		}

<span class="nc" id="L210">		index = 0;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">		if (frames.length &gt; 0) {</span>
<span class="nc" id="L212">			sprite = frames[0];</span>
		} else {
<span class="nc" id="L214">			sprite = null;</span>
		}

<span class="nc" id="L217">		cycleTime = 0;</span>

<span class="nc" id="L219">		long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">		if (loop) {</span>
			/*
			 * Make all looped animations look like they were started at time 0.
			 * Keeps the map sprites nicely in sync.
			 */
<span class="nc" id="L225">			lastUpdate = now - (now % duration);</span>
		} else {
<span class="nc" id="L227">			lastUpdate = now;</span>
		}
<span class="nc" id="L229">	}</span>

	//
	// AnimatedSprite
	//

	/**
	 * Utility method to convert a single delay to an array of delays having
	 * that value.
	 * 
	 * @param delay
	 *            The delay value.
	 * @param count
	 *            The size of the array to create.
	 * 
	 * @return An array of delays.
	 */
	private static int[] createDelays(final int delay, final int count) {
<span class="nc" id="L247">		final int[] delays = new int[count];</span>
<span class="nc" id="L248">		Arrays.fill(delays, delay);</span>

<span class="nc" id="L250">		return delays;</span>
	}

	/**
	 * Reset the animation back to specified frame, and reset the next frame
	 * time.
	 * 
	 * @param index the default index 
	 */
	public void reset(int index) {
<span class="nc" id="L260">		setIndex(index);</span>
<span class="nc" id="L261">	}</span>
	
	/**
	 * Set the frame index to a specific value.
	 * 
	 * @param index
	 *            The index to use.
	 * 
	 * @throws ArrayIndexOutOfBoundsException
	 *             If the index is less than 0 or greater than or equal to the
	 *             number of frames.
	 */
	private void setIndex(final int index) {
<span class="nc bnc" id="L274" title="All 4 branches missed.">		if ((index &lt; 0) || (index &gt;= frames.length)) {</span>
<span class="nc" id="L275">			throw new ArrayIndexOutOfBoundsException(&quot;Invalid index: &quot; + index);</span>
		}

<span class="nc" id="L278">		this.index = index;</span>
<span class="nc" id="L279">		sprite = frames[index];</span>

		/*
		 * Calculate the time into this frame
		 */
<span class="nc" id="L284">		cycleTime = 0;</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">		for (int i = 0; i &lt; index; i++) {</span>
<span class="nc" id="L287">			cycleTime += delays[i];</span>
		}

<span class="nc" id="L290">		lastUpdate = System.currentTimeMillis();</span>
<span class="nc" id="L291">	}</span>

	/**
	 * Start the sprite animating.
	 * 
	 * @see #stop()
	 */
	public void start() {
<span class="nc" id="L299">		animating = true;</span>
<span class="nc" id="L300">	}</span>

	/**
	 * Stop the sprite animating. This does not change the current frame.
	 * 
	 * @see #start()
	 */
	public void stop() {
<span class="nc" id="L308">		animating = false;</span>
<span class="nc" id="L309">	}</span>

	/**
	 * Update the current frame sprite.
	 */
	private void update() {
<span class="nc" id="L315">		final long now = System.currentTimeMillis();</span>
<span class="nc" id="L316">		update((int) (now - lastUpdate));</span>
<span class="nc" id="L317">		lastUpdate = now;</span>
<span class="nc" id="L318">	}</span>

	//
	// Sprite
	//
	/**
	 * Create a sub-region of this sprite. &lt;strong&gt;NOTE: This does not use
	 * caching.&lt;/strong&gt;
	 * 
	 * @param x
	 *            The starting X coordinate.
	 * @param y
	 *            The starting Y coordinate.
	 * @param width
	 *            The region width.
	 * @param height
	 *            The region height.
	 * @param ref
	 *            The sprite reference.
	 * 
	 * @return A new sprite.
	 */
	@Override
	public Sprite createRegion(final int x, final int y, final int width,
			final int height, final Object ref) {
<span class="nc" id="L343">		return new TileSprite(this, x, y, width, height, ref);</span>
	}

	/**
	 * Draw the sprite onto the graphics context provided.
	 * 
	 * @param g
	 *            The graphics context on which to draw the sprite
	 * @param x
	 *            The x location at which to draw the sprite
	 * @param y
	 *            The y location at which to draw the sprite
	 */
	@Override
	public void draw(final Graphics g, final int x, final int y) {
<span class="nc" id="L358">		update();</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">		if (sprite != null) {</span>
<span class="nc" id="L361">			sprite.draw(g, x, y);</span>
		}
<span class="nc" id="L363">	}</span>

	/**
	 * Draws the image.
	 * 
	 * @param g
	 *            the graphics context where to draw to
	 * @param destx
	 *            destination x
	 * @param desty
	 *            destination y
	 * @param x
	 *            the source x
	 * @param y
	 *            the source y
	 * @param w
	 *            the width
	 * @param h
	 *            the height
	 */
	@Override
	public void draw(final Graphics g, final int destx, final int desty,
			final int x, final int y, final int w, final int h) {
<span class="nc" id="L386">		update();</span>

<span class="nc bnc" id="L388" title="All 2 branches missed.">		if (sprite != null) {</span>
<span class="nc" id="L389">			sprite.draw(g, destx, desty, x, y, w, h);</span>
		}
<span class="nc" id="L391">	}</span>

	/**
	 * Get the height of the drawn sprite.
	 * 
	 * @return The height in pixels of this sprite.
	 */
	@Override
	public int getHeight() {
<span class="nc" id="L400">		return height;</span>
	}

	/**
	 * Get the sprite reference. This identifier is an externally opaque object
	 * that implements equals() and hashCode() to uniquely/repeatably reference
	 * a keyed sprite.
	 * 
	 * @return The reference identifier, or &lt;code&gt;null&lt;/code&gt; if not
	 *         referencable.
	 */
	@Override
	public Object getReference() {
<span class="nc" id="L413">		return reference;</span>
	}

	/**
	 * Get the width of the drawn sprite.
	 * 
	 * @return The width in pixels of this sprite.
	 */
	@Override
	public int getWidth() {
<span class="nc" id="L423">		return width;</span>
	}

	/**
	 * Update the current frame sprite.
	 * &lt;em&gt;Idealy this would be called from a central time manager,
	 * instead of draw() like now.&lt;/em&gt;
	 * 
	 * @param delta
	 *            The time since last update (in ms).
	 */
	private void update(final int delta) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (animating) {</span>
<span class="nc" id="L436">			cycleTime += delta;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">			if (loop) {</span>
				// let the non-looping sprites overflow, so that they get
				// properly stopped
<span class="nc" id="L440">				cycleTime %= duration;</span>
			}
			
<span class="nc bnc" id="L443" title="All 2 branches missed.">			while (cycleTime &gt;= delays[index]) {</span>
<span class="nc" id="L444">				cycleTime -= delays[index];</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">				if (++index == frames.length) {</span>
<span class="nc" id="L447">					index = 0;</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">					if (!loop) {</span>
<span class="nc" id="L450">						sprite = null;</span>
<span class="nc" id="L451">						animating = false;</span>
<span class="nc" id="L452">						return;</span>
					}
				}
			}

<span class="nc" id="L457">			sprite = frames[index];</span>
		}
<span class="nc" id="L459">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>