<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ActiveEntity.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.entity</a> &gt; <span class="el_source">ActiveEntity.java</span></div><h1>ActiveEntity.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2012 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.entity;

import games.stendhal.client.GameObjects;
import games.stendhal.common.Direction;
import marauroa.common.game.RPObject;

/**
 * An entity that has movement and direction.
 */
public abstract class ActiveEntity extends Entity {
	/** Epsilon value used for coordinate change checks. */
	private static final double EPSILON = 0.001;
	/**
	 * Direction property.
	 */
<span class="fc" id="L28">	public static final Property PROP_DIRECTION = new Property();</span>

	/**
	 * Speed property.
	 */
<span class="fc" id="L33">	public static final Property PROP_SPEED = new Property();</span>

	/**
	 * The current [facing] direction.
	 */
	private Direction direction;

	/** The current speed of this entity horizontally (tiles?/sec). */
	private double dx;

	/** The current speed of this entity vertically (tiles?/sec) . */
	private double dy;

	/**
	 * Create an active (moving) entity.
	 */
<span class="fc" id="L49">	ActiveEntity() {</span>
<span class="fc" id="L50">		direction = Direction.DOWN;</span>
<span class="fc" id="L51">		setSpeed(0.0, 0.0);</span>
<span class="fc" id="L52">	}</span>

	//
	// ActiveEntity
	//

	/**
	 * Get the direction.
	 * 
	 * @return The direction.
	 */
	public Direction getDirection() {
<span class="nc" id="L64">		return direction;</span>
	}

	/**
	 * Set the direction.
	 * 
	 * @param direction
	 *            The direction.
	 */
	void setDirection(final Direction direction) {
<span class="nc bnc" id="L74" title="All 2 branches missed.">		boolean changed = this.direction != direction;</span>
<span class="nc" id="L75">		this.direction = direction;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">		if (changed) {</span>
			/*
			 * Movement prediction can result in the client entities (User)
			 * sometimes having the wrong direction, so we do the changed check
			 * here instead of firing the property only when the RPObject
			 * changes warrant so.
			 */
<span class="nc" id="L83">			fireChange(PROP_DIRECTION);</span>
		}
<span class="nc" id="L85">	}</span>

	/**
	 * Determine if this entity is not moving.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if not moving.
	 */
	public boolean stopped() {
<span class="nc bnc" id="L93" title="All 4 branches missed.">		return (dx == 0.0) &amp;&amp; (dy == 0.0);</span>
	}

	/**
	 * Compares to floating point values.
	 * 
	 * @param d1
	 *            first value
	 * @param d2
	 *            second value
	 * @param diff
	 *            acceptable diff
	 * @return true if they are within diff
	 */
	private static boolean compareDouble(final double d1, final double d2,
			final double diff) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">		return Math.abs(d1 - d2) &lt; diff;</span>
	}

	/**
	 * calculates the movement if the server an client are out of sync. for some
	 * milliseconds. (server turns are not exactly 300 ms) Most times this will
	 * slow down the client movement
	 * 
	 * @param clientPos
	 *            the position the client has calculated
	 * @param serverPos
	 *            the position the server has reported
	 * @param delta
	 *            the movement based on direction
	 * @return the new delta to correct the movement error
	 */
	private static double calcDeltaMovement(final double clientPos,
			final double serverPos, final double delta) {
<span class="nc" id="L127">		final double moveErr = clientPos - serverPos;</span>
<span class="nc" id="L128">		final double moveCorrection = (delta - moveErr) / delta;</span>
<span class="nc" id="L129">		return (delta + delta * moveCorrection) / 2;</span>
	}

	/**
	 * When entity moves, it will be called with the data.
	 * 
	 * @param x new x coordinate
	 * @param y new y coordinate
	 * @param direction new direction
	 * @param speed new speed
	 */
	private void onMove(final int x, final int y, final Direction direction,
			final double speed) {

<span class="fc" id="L143">		double oldx = this.x;</span>
<span class="fc" id="L144">		double oldy = this.y;</span>
<span class="fc" id="L145">		setSpeed(direction.getdx() * speed, direction.getdy() * speed);</span>

<span class="pc bpc" id="L147" title="2 of 4 branches missed.">		if ((Direction.LEFT == direction)</span>
				|| (Direction.RIGHT == direction)) {
<span class="nc" id="L149">			this.y = y;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">			if (compareDouble(this.x, x, 1.0)) {</span>
				// make the movement look more nicely: + this.dx * 0.1
<span class="nc" id="L152">				this.dx = calcDeltaMovement(this.x + this.dx * 0.1, x,</span>
						direction.getdx())
						* speed;
			} else {
<span class="nc" id="L156">				this.x = x;</span>
			}
<span class="nc" id="L158">			this.dy = 0;</span>
<span class="pc bpc" id="L159" title="2 of 4 branches missed.">		} else if ((Direction.UP == direction)</span>
				|| (Direction.DOWN == direction)) {
<span class="nc" id="L161">			this.x = x;</span>
<span class="nc" id="L162">			this.dx = 0;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">			if (compareDouble(this.y, y, 1.0)) {</span>
				// make the movement look more nicely: + this.dy * 0.1
<span class="nc" id="L165">				this.dy = calcDeltaMovement(this.y + this.dy * 0.1, y,</span>
						direction.getdy())
						* speed;
			} else {
<span class="nc" id="L169">				this.y = y;</span>
			}
		} else {
			// placing entities
<span class="fc" id="L173">			this.x = x;</span>
<span class="fc" id="L174">			this.y = y;</span>
		}

		// Call onPosition only if the entity actually moved. Also always call
		// on partial coordinates - those are always predicted rather than real
		// and thus should always be a result of prediction. However, the
		// client collision detection does not always agree with that of the
		// server, so relying on just the coordinate change checks can miss
		// entities stopping when they collide with each other.
<span class="pc bpc" id="L183" title="3 of 8 branches missed.">		if (!compareDouble(this.x, oldx, EPSILON) || !compareDouble(this.y, oldy, EPSILON)</span>
				|| !compareDouble(oldx, (int) oldx, EPSILON)
				|| !compareDouble(oldy, (int) oldy, EPSILON)) {
<span class="fc" id="L186">			onPosition(x, y);</span>
		}
<span class="fc" id="L188">	}</span>

	//
	// Entity
	//

	/**
	 * Initialize this entity for an object.
	 * 
	 * @param base
	 *            The object.
	 * 
	 * @see #release()
	 */
	@Override
	public void initialize(final RPObject base) {
		double speed;

<span class="fc" id="L206">		super.initialize(base);</span>

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">		if (base.has(&quot;dir&quot;)) {</span>
<span class="nc" id="L209">			setDirection(Direction.build(base.getInt(&quot;dir&quot;)));</span>
		}

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">		if (base.has(&quot;speed&quot;)) {</span>
<span class="nc" id="L213">			speed = base.getDouble(&quot;speed&quot;);</span>
		} else {
<span class="fc" id="L215">			speed = 0.0;</span>
		}

<span class="fc" id="L218">		dx = direction.getdx() * speed;</span>
<span class="fc" id="L219">		dy = direction.getdy() * speed;</span>
<span class="fc" id="L220">	}</span>

	/**
	 * Update cycle.
	 * 
	 * @param delta
	 *            The time (in ms) since last call.
	 */
	@Override
	public void update(final int delta) {
<span class="nc" id="L230">		super.update(delta);</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">		if (!stopped()) {</span>
<span class="nc" id="L233">			final double step = (delta / 300.0);</span>

<span class="nc" id="L235">			final double oldX = x;</span>
<span class="nc" id="L236">			final double oldY = y;</span>

			// update the location of the entity based on speeds
<span class="nc" id="L239">			x += (dx * step);</span>
<span class="nc" id="L240">			y += (dy * step);</span>

<span class="nc bnc" id="L242" title="All 2 branches missed.">			if (GameObjects.getInstance().collides(this)) {</span>
<span class="nc" id="L243">				x = oldX;</span>
<span class="nc" id="L244">				y = oldY;</span>
			} else {
<span class="nc" id="L246">				onPosition(x, y);</span>
			}
		}
<span class="nc" id="L249">	}</span>

	/**
	 * Process attribute changes that may affect positioning. This is needed
	 * because different entities may want to process coordinate changes more
	 * gracefully.
	 * 
	 * @param base
	 *            The previous values.
	 * @param diff
	 *            The changes.
	 */
	@Override
	protected void processPositioning(final RPObject base, final RPObject diff) {
		// Real movement case
<span class="fc" id="L264">		final int oldx = base.getInt(&quot;x&quot;);</span>
<span class="fc" id="L265">		final int oldy = base.getInt(&quot;y&quot;);</span>

<span class="fc" id="L267">		int newX = oldx;</span>
<span class="fc" id="L268">		int newY = oldy;</span>

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">		if (diff.has(&quot;x&quot;)) {</span>
<span class="nc" id="L271">			newX = diff.getInt(&quot;x&quot;);</span>
		}
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">		if (diff.has(&quot;y&quot;)) {</span>
<span class="nc" id="L274">			newY = diff.getInt(&quot;y&quot;);</span>
		}

		Direction tempDirection;

<span class="pc bpc" id="L279" title="1 of 2 branches missed.">		if (diff.has(&quot;dir&quot;)) {</span>
<span class="nc" id="L280">			tempDirection = Direction.build(diff.getInt(&quot;dir&quot;));</span>
<span class="nc" id="L281">			setDirection(tempDirection);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">		} else if (base.has(&quot;dir&quot;)) {</span>
<span class="nc" id="L283">			tempDirection = Direction.build(base.getInt(&quot;dir&quot;));</span>
<span class="nc" id="L284">			setDirection(tempDirection);</span>
		} else {
<span class="fc" id="L286">			tempDirection = Direction.STOP;</span>
		}

		double speed;

		/*
		 * Speed change must be fired only after the new speed has been stored
		 * (done in onMove())
		 */
<span class="fc" id="L295">		boolean speedChanged = false;</span>
		
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">		if (diff.has(&quot;speed&quot;)) {</span>
<span class="nc" id="L298">			speed = diff.getDouble(&quot;speed&quot;);</span>
<span class="nc" id="L299">			speedChanged = true;</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">		} else if (base.has(&quot;speed&quot;)) {</span>
<span class="nc" id="L301">			speed = base.getDouble(&quot;speed&quot;);</span>
		} else {
<span class="fc" id="L303">			speed = 0;</span>
		}
		
<span class="fc" id="L306">		onMove(newX, newY, tempDirection, speed);</span>
		
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">		if (speedChanged) {</span>
<span class="nc" id="L309">			fireChange(PROP_SPEED);</span>
		}

<span class="fc" id="L312">		boolean positionChanged = false;</span>
<span class="pc bpc" id="L313" title="3 of 4 branches missed.">		if ((Direction.STOP == tempDirection) || (speed == 0)) {</span>
<span class="fc" id="L314">			setSpeed(0.0, 0.0);</span>
			
			/*
			 * Try to ensure relocation in the case the client and server were
			 * in disagreement about the position at the moment of stopping.
			 */
<span class="pc bpc" id="L320" title="2 of 4 branches missed.">			if (!(compareDouble(y, newY, EPSILON) &amp;&amp; compareDouble(x, newX, EPSILON))) {</span>
<span class="nc" id="L321">				positionChanged = true;</span>
			}

			// Store the new position before signaling it with onPosition().
<span class="fc" id="L325">			x = newX;</span>
<span class="fc" id="L326">			y = newY;</span>
		}

		/*
		 * Change in position?
		 */
<span class="pc bpc" id="L332" title="4 of 6 branches missed.">		if (positionChanged || ((oldx != newX) &amp;&amp; (oldy != newY))) {</span>
<span class="nc" id="L333">			onPosition(newX, newY);</span>
		}
<span class="fc" id="L335">	}</span>
	
	/**
	 * Set the current client side speed. This is used by the movement
	 * prediction at key press. &lt;b&gt;Do not call unless you know what you're
	 * doing. &lt;/b&gt;
	 * 
	 * @param dx horizontal speed
	 * @param dy vertical speed
	 */
	final void setSpeed(double dx, double dy) {
<span class="fc" id="L346">		this.dx = dx;</span>
<span class="fc" id="L347">		this.dy = dy;</span>
<span class="fc" id="L348">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>