<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InternalWindow.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui</a> &gt; <span class="el_source">InternalWindow.java</span></div><h1>InternalWindow.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui;

import games.stendhal.client.ClientSingletonRepository;
import games.stendhal.client.gui.layout.SBoxLayout;
import games.stendhal.client.gui.styled.Style;
import games.stendhal.client.gui.styled.StyleUtil;
import games.stendhal.common.constants.SoundLayer;

import java.awt.AlphaComposite;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.Image;
import java.awt.Insets;
import java.awt.Transparency;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.util.LinkedList;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.Border;

/**
 * A window like panel component with a title bar and optional close and
 * minimize buttons.
 */
public class InternalWindow extends JPanel implements ComponentPaintCache.Cacheable {
	/**
	 * serial version uid.
	 */
	private static final long serialVersionUID = 7086677981083580331L;
	private static final int TITLEBAR_HEIGHT = 13;
	/** Space between titlebar components and before the title. */
	private static final int TITLEBAR_PADDING = 2;
	
	private static Icon closeIcon, minimizeIcon;

	// Draw the buttons over static background to avoid overhead from constantly
	// painting translucent
	static {
<span class="fc" id="L66">		createIcons();</span>
<span class="fc" id="L67">	}</span>
	
	private final TitleBar titleBar;
	final JButton minimizeButton;
	final JButton closeButton;
	/** Title text label. */
	final JLabel titleLabel;
	
	private JComponent content;
<span class="fc" id="L76">	private boolean hideOnClose = false;</span>
	
<span class="fc" id="L78">	private String openSound = &quot;click-10&quot;;</span>
<span class="fc" id="L79">	private String minimizeSound = &quot;click-8&quot;;</span>
<span class="fc" id="L80">	private String closeSound = &quot;click-6&quot;;</span>
	
<span class="fc" id="L82">	private final List&lt;CloseListener&gt; closeListeners = new LinkedList&lt;CloseListener&gt;();</span>
	
	private final ComponentPaintCache cache;
	
	/**
	 * Create a new InternalWindow.
	 * 
	 * @param title title text
	 */
<span class="fc" id="L91">	InternalWindow(String title) {</span>
<span class="fc" id="L92">		setLayout(new BorderLayout());</span>
		
<span class="fc" id="L94">		titleBar = new TitleBar();</span>
<span class="fc" id="L95">		add(titleBar, BorderLayout.NORTH);</span>
<span class="fc" id="L96">		titleBar.setLayout(new SBoxLayout(SBoxLayout.HORIZONTAL, TITLEBAR_PADDING));</span>
<span class="fc" id="L97">		titleLabel = new JLabel();</span>
<span class="fc" id="L98">		setTitle(title);</span>
		// Squeeze the label if there's not enough space
<span class="fc" id="L100">		titleLabel.setMinimumSize(new Dimension(0, 0));</span>
<span class="fc" id="L101">		titleBar.add(titleLabel);</span>
<span class="fc" id="L102">		SBoxLayout.addSpring(titleBar);</span>
		
		// Add the close and minimize buttons
<span class="fc" id="L105">		minimizeButton = new JButton(minimizeIcon);</span>
<span class="fc" id="L106">		minimizeButton.setMargin(new Insets(0, 0, 0, 0));</span>
<span class="fc" id="L107">		minimizeButton.setBorder(BorderFactory.createEmptyBorder());</span>
<span class="fc" id="L108">		minimizeButton.setFocusable(false);</span>
<span class="fc" id="L109">		minimizeButton.addActionListener(new MinimizeListener());</span>
<span class="fc" id="L110">		titleBar.add(minimizeButton);</span>
		
<span class="fc" id="L112">		closeButton = new JButton(closeIcon);</span>
<span class="fc" id="L113">		closeButton.setMargin(new Insets(0, 0, 0, 0));</span>
<span class="fc" id="L114">		closeButton.setBorder(BorderFactory.createEmptyBorder());</span>
<span class="fc" id="L115">		closeButton.setFocusable(false);</span>
<span class="fc" id="L116">		closeButton.addActionListener(new CloseActionListener());</span>
<span class="fc" id="L117">		titleBar.add(closeButton);</span>
		
<span class="fc" id="L119">		cache = new ComponentPaintCache(this);</span>
<span class="fc" id="L120">	}</span>
	
	/**
	 * Add a close listener to the window. All the listeners will be notified
	 * when this window is closed.
	 * 
	 * @param listener new listener
	 */
	public void addCloseListener(CloseListener listener) {
<span class="nc" id="L129">		closeListeners.add(listener);</span>
<span class="nc" id="L130">	}</span>
	
	/**
	 * Set the content of the window. The minimum width of the title bar
	 * is determined at this stage, so usually you should defer setting
	 * the window contents until the content component has been fully 
	 * constructed.
	 * 
	 * @param content window content
	 */
	public void setContent(JComponent content) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">		if (this.content != null) {</span>
<span class="nc" id="L142">			remove(this.content);</span>
		}
<span class="fc" id="L144">		add(content, BorderLayout.CENTER);</span>
<span class="fc" id="L145">		this.content = content;</span>
		/*
		 * Keep the preferred width even if the content is minimized
		 */
<span class="fc" id="L149">		titleBar.setPreferredWidth(content.getPreferredSize().width);</span>
<span class="fc" id="L150">	}</span>
	
	/**
	 * Make the window closeable by the user by showing or hiding the close
	 * button.
	 * 
	 * @param closeable &lt;code&gt;true&lt;/code&gt; if the window should have a close
	 * 	button, otherwise &lt;code&gt;false&lt;/code&gt;
	 */
	public void setCloseable(boolean closeable) {
<span class="fc" id="L160">		closeButton.setVisible(closeable);</span>
<span class="fc" id="L161">	}</span>
	
	/**
	 * Set closing policy. Normally windows delete themselves on close, but
	 * setting the policy to hiding just makes it invisible.
	 * 
	 * @param hide if &lt;code&gt;true&lt;/code&gt;, the window will hide itself when the
	 * 	user closes it, otherwise the window is deleted on close
	 */
	public void setHideOnClose(boolean hide) {
<span class="fc" id="L171">		hideOnClose = hide;</span>
<span class="fc" id="L172">	}</span>
	
	/**
	 * Make the window minimizable by the user by showing or hiding the
	 * minimize button.
	 * 
	 * @param minimizable &lt;code&gt;true&lt;/code&gt; if the window should have a minimize
	 * 	button, otherwise &lt;code&gt;false&lt;/code&gt;
	 */
	public void setMinimizable(boolean minimizable) {
<span class="fc" id="L182">		minimizeButton.setVisible(minimizable);</span>
<span class="fc" id="L183">	}</span>
	
	/**
	 * Get the minimization status of the window.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the window is minimized, &lt;code&gt;false&lt;/code&gt;
	 * otherwise
	 */
	public boolean isMinimized() {
<span class="fc bfc" id="L192" title="All 2 branches covered.">		return !content.isVisible();</span>
	}
	
	/**
	 * Set the minimization status of the window.
	 * 
	 * @param minimized &lt;code&gt;true&lt;/code&gt; to minimize the window,
	 * 	&lt;code&gt;false&lt;/code&gt; to restore it
	 */
	public void setMinimized(boolean minimized) {
		// Cosmetics. Hide the borders of the title bar while the window is
		// minimized
<span class="fc bfc" id="L204" title="All 2 branches covered.">		if (minimized) {</span>
<span class="fc" id="L205">			titleBar.hideBorder();</span>
		} else {
<span class="fc" id="L207">			titleBar.restoreBorder();</span>
		}
<span class="fc bfc" id="L209" title="All 2 branches covered.">		content.setVisible(!minimized);</span>
<span class="fc" id="L210">	}</span>
	
	/**
	 * Get the title bar component.
	 * @return title bar
	 */
	protected JComponent getTitlebar() {
<span class="nc" id="L217">		return titleBar;</span>
	}
	
	/**
	 * Set the window title.
	 * 
	 * @param title title text
	 */
	public final void setTitle(String title) {
		/*
		 * Work around JLabel drawing ellipsis when it's short of space. To
		 * avoid titles like &quot;cor...&quot; for corpses. Html labels do not get the
		 * ellipsis.
		 * 
		 * Use no-break space to avoid the title overflowing to the
		 * next line when using html.
		 */
<span class="fc" id="L234">		title = title.replaceAll(&quot; +&quot;, &quot;&amp;nbsp;&quot;);</span>
<span class="fc" id="L235">		title = &quot;&lt;html&gt;&quot; + title + &quot;&lt;/html&gt;&quot;;</span>
<span class="fc" id="L236">		titleLabel.setText(title);</span>
<span class="fc" id="L237">	}</span>
	
	/**
	 * Close the window. Either deletes or hides it, according to the policy
	 * set with {@link #setHideOnClose}.
	 */
	public void close() {
<span class="fc bfc" id="L244" title="All 2 branches covered.">		if (hideOnClose) {</span>
<span class="fc" id="L245">			setVisible(false);</span>
		} else {
<span class="fc" id="L247">			Container parent = InternalWindow.this.getParent();</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">			if (parent != null) {</span>
<span class="fc" id="L249">				parent.remove(InternalWindow.this);</span>
<span class="fc" id="L250">				parent.validate();</span>
<span class="fc" id="L251">				parent.repaint();</span>
			}
		}
		// notify listeners
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">		for (CloseListener listener : closeListeners) {</span>
<span class="nc" id="L256">			listener.windowClosed(this);</span>
<span class="nc" id="L257">		}</span>
<span class="fc" id="L258">	}</span>
	
	/**
	 * Play a user interface sound.
	 * 
	 * @param sound the sound to be played
	 */
	private void playSound(String sound) {
<span class="fc" id="L266">		ClientSingletonRepository.getSound().getGroup(SoundLayer.USER_INTERFACE.groupName).play(sound, 0, null, null, false, true);</span>
<span class="fc" id="L267">	}</span>
	
	/**
	 * Create the close and minimize icons.
	 */
	private static void createIcons() {
<span class="fc" id="L273">		GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();</span>
<span class="fc" id="L274">		Image bg = createIconBackground(gc);</span>
		
		// copy bg for drawing
<span class="fc" id="L277">		Image image = gc.createCompatibleImage(TITLEBAR_HEIGHT, TITLEBAR_HEIGHT, Transparency.OPAQUE);</span>
<span class="fc" id="L278">		Graphics g = image.getGraphics();</span>
<span class="fc" id="L279">		g.drawImage(bg, 0, 0, null);</span>
<span class="fc" id="L280">		closeIcon = createCloseIcon(image);</span>
		
		// now we can draw over the background image
<span class="fc" id="L283">		minimizeIcon = createMinimizeIcon(bg);</span>
<span class="fc" id="L284">	}</span>
	
	/**
	 * Create image background for the title bar buttons. Tries using the
	 * style of the theme if available.
	 * 
	 * @param gc graphics configuration for creating the image
	 * 
	 * @return image background image
	 */
	private static Image createIconBackground(GraphicsConfiguration gc) {
<span class="fc" id="L295">		BufferedImage image = gc.createCompatibleImage(TITLEBAR_HEIGHT, TITLEBAR_HEIGHT, Transparency.OPAQUE);</span>
<span class="fc" id="L296">		Graphics2D g = image.createGraphics();</span>
		/*
		 * Use proper style if defined. If someone's using a different theme we
		 * don't have a nice background, but the client should not crash anyway.
		 * Those get just a white background.
		 */
<span class="fc" id="L302">		Style style = StyleUtil.getStyle();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if (style != null) {</span>
<span class="nc" id="L304">			style.getBackground().draw(g, 0, 0);</span>
<span class="nc" id="L305">			g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));</span>
		}
<span class="fc" id="L307">		g.setColor(Color.WHITE);</span>
<span class="fc" id="L308">		g.fillRect(0, 0, TITLEBAR_HEIGHT, TITLEBAR_HEIGHT);</span>
<span class="fc" id="L309">		g.dispose();</span>
		
<span class="fc" id="L311">		return image;</span>
	}
	
	/**
	 * Draw the close button icon.
	 * 
	 * @param image background image. The button image is drawn over this,
	 * 	without making a local copy first
	 * @return icon for close button
	 */
	private static Icon createCloseIcon(Image image) {
<span class="fc" id="L322">		Graphics g = image.getGraphics();</span>

<span class="fc" id="L324">		g.setColor(Color.BLACK);</span>
		/* \\\ */
<span class="fc" id="L326">		g.drawLine(1, 2, TITLEBAR_HEIGHT - 3, TITLEBAR_HEIGHT - 2);</span>
<span class="fc" id="L327">		g.drawLine(1, 1, TITLEBAR_HEIGHT - 2, TITLEBAR_HEIGHT - 2);</span>
<span class="fc" id="L328">		g.drawLine(2, 1, TITLEBAR_HEIGHT - 2, TITLEBAR_HEIGHT - 3);</span>
		
		/* /// */
<span class="fc" id="L331">		g.drawLine(TITLEBAR_HEIGHT - 3, 1, 1, TITLEBAR_HEIGHT - 3);</span>
<span class="fc" id="L332">		g.drawLine(TITLEBAR_HEIGHT - 2, 1, 1, TITLEBAR_HEIGHT - 2);</span>
<span class="fc" id="L333">		g.drawLine(TITLEBAR_HEIGHT - 2, 2, 2, TITLEBAR_HEIGHT - 2);</span>

<span class="fc" id="L335">		g.dispose();</span>
<span class="fc" id="L336">		return new ImageIcon(image);</span>
	}
	
	/**
	 * Draw the minimize button icon.
	 * 
	 * @param image background image. The button image is drawn over this,
	 * 	without making a local copy first
	 * @return icon for minimize button
	 */
	private static Icon createMinimizeIcon(Image image) {
<span class="fc" id="L347">		Graphics g = image.getGraphics();</span>

<span class="fc" id="L349">		g.setColor(Color.BLACK);</span>
<span class="fc" id="L350">		g.fillRect(1, TITLEBAR_HEIGHT - 3, TITLEBAR_HEIGHT - 2, 2);</span>
		
<span class="fc" id="L352">		return new ImageIcon(image);</span>
	}
	
	/* ********************************************************************
	 * Speed up the drawing by caching the image of the window. This is done
	 * because repeatedly drawing the borders makes a noticeable performance
	 * hit.
	 */
	@Override
	public void paint(Graphics g) {
<span class="nc" id="L362">		cache.paintComponent(g);</span>
<span class="nc" id="L363">		paintChildren(g);</span>
<span class="nc" id="L364">	}</span>
	
	@Override
	public void paintComponent(Graphics g) {
<span class="nc" id="L368">		super.paintComponent(g);</span>
<span class="nc" id="L369">	}</span>
	
	@Override
	public void paintBorder(Graphics g) {
<span class="nc" id="L373">		super.paintBorder(g);</span>
<span class="nc" id="L374">	}</span>
	
	@Override
	public void paintChildren(Graphics g) {
<span class="nc" id="L378">		super.paintChildren(g);</span>
<span class="nc" id="L379">	}</span>
	
	/**
	 * Listener interface for window close events.
	 */
	public interface CloseListener {
		/**
		 * Called when the window is closed.
		 * 
		 * @param window the closed window
		 */
		void windowClosed(InternalWindow window);
	}
	
	/**
	 * Handle close button.
	 */
<span class="fc" id="L396">	private class CloseActionListener implements ActionListener {</span>
		@Override
		public void actionPerformed(final ActionEvent ev) {
<span class="fc" id="L399">			close();</span>
<span class="fc" id="L400">			playSound(closeSound);</span>
<span class="fc" id="L401">		}</span>
	}

	/**
	 * Handle minimization button.
	 */
<span class="fc" id="L407">	private class MinimizeListener implements ActionListener {</span>
		@Override
		public void actionPerformed(final ActionEvent ev) {
<span class="fc bfc" id="L410" title="All 2 branches covered.">			setMinimized(!isMinimized());</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">			if (isMinimized()) {</span>
<span class="fc" id="L412">				playSound(openSound);</span>
			} else {
<span class="fc" id="L414">				playSound(minimizeSound);</span>
			}
<span class="fc" id="L416">		}</span>
	}
	
	/**
	 * A JPanel that draws only the lower part of the border.
	 */
	private static class TitleBar extends JPanel implements ComponentPaintCache.Cacheable {
		/**
		 * serial version uid.
		 */
		private static final long serialVersionUID = -6859560118307192124L;
		/** Original, unmodified insets. */
		private Insets insets;
		private final Border border;
		private final ComponentPaintCache cache;
		/**
		 * Width of the window content. The title bar should not request a
		 * larger width.
		 */
<span class="fc" id="L435">		private int preferredWidth = -1;</span>
		
		/**
		 * Create a TitleBar.
		 */
<span class="fc" id="L440">		TitleBar() {</span>
			/*
			 * Compensate with negative empty border the borders that are not
			 * drawn anyway. Left and right borders are useful as padding so 
			 * they are kept.
			 */
<span class="fc" id="L446">			insets = getInsets();</span>
<span class="fc" id="L447">			border = BorderFactory.createCompoundBorder(getBorder(), </span>
					BorderFactory.createEmptyBorder(-insets.top, 0, 0, 0));
<span class="fc" id="L449">			setBorder(border);</span>
<span class="fc" id="L450">			cache = new ComponentPaintCache(this);</span>
<span class="fc" id="L451">		}</span>
		
		/**
		 * Hide the special border of the title bar.
		 */
		void hideBorder() {
			/*
			 * Create an empty border that corresponds exactly to the normal
			 * borders.
			 */
<span class="fc" id="L461">			Insets insets = getInsets();</span>
<span class="fc" id="L462">			setBorder(BorderFactory.createEmptyBorder(insets.top, insets.left, insets.bottom, insets.right));</span>
<span class="fc" id="L463">		}</span>
		
		/**
		 * Restore the special border of the title bar.
		 */
		void restoreBorder() {
<span class="fc" id="L469">			setBorder(border);</span>
<span class="fc" id="L470">		}</span>
		
		/**
		 * Set what the title should report as its preferred width.
		 * 
		 * @param width preferred width
		 */
		void setPreferredWidth(int width) {
<span class="fc" id="L478">			preferredWidth = width;</span>
<span class="fc" id="L479">		}</span>
		
		@Override
		public Dimension getPreferredSize() {
<span class="nc" id="L483">			Dimension tmp = super.getPreferredSize();</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">			if (preferredWidth != -1) {</span>
<span class="nc" id="L485">				tmp.width = preferredWidth;</span>
			}
			
<span class="nc" id="L488">			return tmp;</span>
		}
		
		@Override
		public void paintBorder(Graphics g) {
<span class="nc" id="L493">			Graphics graphics = g.create();</span>
<span class="nc" id="L494">			graphics.clipRect(0, getHeight() - insets.bottom, getWidth(), getHeight());</span>
			/*
			 * Adjust the width, so that the drawn border does not get corners
			 * that may look ugly
			 */
<span class="nc" id="L499">			getBorder().paintBorder(this, graphics, -insets.left, 0, </span>
					getWidth() + insets.left + insets.right, getHeight());
<span class="nc" id="L501">			graphics.dispose();</span>
<span class="nc" id="L502">		}</span>
		
		@Override
		public void paint(Graphics g) {
<span class="nc" id="L506">			cache.paintComponent(g);</span>
<span class="nc" id="L507">			paintChildren(g);</span>
<span class="nc" id="L508">		}</span>
		
		// *** for cached painting ***
		
		@Override
		public void paintComponent(Graphics g) {
<span class="nc" id="L514">			super.paintComponent(g);</span>
<span class="nc" id="L515">		}</span>
		
		@Override
		public void paintChildren(Graphics g) {
<span class="nc" id="L519">			super.paintChildren(g);</span>
<span class="nc" id="L520">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>