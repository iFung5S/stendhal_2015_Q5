<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TurnNotifier.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.core.events</a> &gt; <span class="el_source">TurnNotifier.java</span></div><h1>TurnNotifier.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.core.events;

import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.StendhalRPWorld;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

/**
 * Other classes can register here to be notified at some time in the future.
 * 
 * @author hendrik, daniel
 */
public final class TurnNotifier {

<span class="fc" id="L35">	private static Logger logger = Logger.getLogger(TurnNotifier.class);</span>

	/** The Singleton instance. */
<span class="fc" id="L38">	private static final TurnNotifier INSTANCE = new TurnNotifier();</span>

<span class="fc" id="L40">	private int currentTurn = -1;</span>

	/**
	 * This Map maps each turn to the set of all events that will take place at
	 * this turn. Turns at which no event should take place needn't be
	 * registered here.
	 */
<span class="fc" id="L47">	private final Map&lt;Integer, Set&lt;TurnListener&gt;&gt; register = new HashMap&lt;Integer, Set&lt;TurnListener&gt;&gt;();</span>

	/** Used for multi-threading synchronization. * */
<span class="fc" id="L50">	private final Object sync = new Object();</span>

<span class="fc" id="L52">	private TurnNotifier() {</span>
		// singleton
<span class="fc" id="L54">	}</span>

	/**
	 * Return the TurnNotifier instance.
	 * 
	 * @return TurnNotifier the Singleton instance
	 */
	public static TurnNotifier get() {
<span class="fc" id="L62">		return INSTANCE;</span>
	}

	/**
	 * This method is invoked by StendhalRPRuleProcessor.endTurn().
	 * 
	 * @param currentTurn
	 *            currentTurn
	 */

	public void logic(final int currentTurn) {
		// Note: It is OK to only synchronise the remove part
		// because notifyAtTurn will not allow registrations
		// for the current turn. So it is important to
		// adjust currentTurn before the loop.

<span class="fc" id="L78">		this.currentTurn = currentTurn;</span>

		// get and remove the set for this turn
<span class="fc" id="L81">		Set&lt;TurnListener&gt; set = null;</span>
<span class="fc" id="L82">		synchronized (sync) {</span>
<span class="fc" id="L83">			set = register.remove(Integer.valueOf(currentTurn));</span>
<span class="pc" id="L84">		}</span>

<span class="pc bpc" id="L86" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L87">			final StringBuilder os = new StringBuilder();</span>
<span class="nc" id="L88">			os.append(&quot;register: &quot; + register.size() + &quot;\n&quot;);</span>
			int setSize;
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (set != null) {</span>
<span class="nc" id="L91">				setSize = set.size();</span>
			} else {
<span class="nc" id="L93">				setSize = 0;</span>
			}
<span class="nc" id="L95">			os.append(&quot;set: &quot; + setSize + &quot;\n&quot;);</span>
<span class="nc" id="L96">			logger.info(os);</span>
		}

<span class="fc bfc" id="L99" title="All 2 branches covered.">		if (set != null) {</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">			for (final TurnListener turnListener : set) {</span>
				
				try {
<span class="fc" id="L103">					turnListener.onTurnReached(currentTurn);</span>
<span class="fc" id="L104">				} catch (final RuntimeException e) {</span>
<span class="fc" id="L105">					logger.error(&quot;Exception in &quot; + turnListener, e);</span>
<span class="fc" id="L106">				}</span>
<span class="fc" id="L107">			}</span>
		}
<span class="fc" id="L109">	}</span>

	/**
	 * Notifies the &lt;i&gt;turnListener&lt;/i&gt; in &lt;i&gt;diff&lt;/i&gt; turns.
	 * 
	 * @param diff
	 *            the number of turns to wait before notifying
	 * @param turnListener
	 *            the object to notify
	 */

	public void notifyInTurns(final int diff, final TurnListener turnListener) {
<span class="fc" id="L121">		notifyAtTurn(currentTurn + diff + 1, turnListener);</span>
<span class="fc" id="L122">	}</span>

	/**
	 * Notifies the &lt;i&gt;turnListener&lt;/i&gt; in &lt;i&gt;sec&lt;/i&gt; seconds.
	 * 
	 * @param sec
	 *            the number of seconds to wait before notifying
	 * @param turnListener
	 *            the object to notify
	 */
	public void notifyInSeconds(final int sec, final TurnListener turnListener) {
<span class="fc" id="L133">		notifyInTurns(SingletonRepository.getRPWorld().getTurnsInSeconds(sec),</span>
				turnListener);
<span class="fc" id="L135">	}</span>

	/**
	 * Notifies the &lt;i&gt;turnListener&lt;/i&gt; at turn number &lt;i&gt;turn&lt;/i&gt;.
	 * 
	 * @param turn
	 *            the number of the turn
	 * @param turnListener
	 *            the object to notify
	 */

	public void notifyAtTurn(final int turn, final TurnListener turnListener) {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">		if (turnListener == null) {</span>
<span class="nc" id="L148">			logger.error(&quot;Trying to notify null-object&quot;, new Throwable());</span>
<span class="nc" id="L149">			return;</span>
		}

<span class="pc bpc" id="L152" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L153">			logger.info(&quot;Notify at &quot; + turn + &quot; by &quot; + turnListener);</span>
<span class="nc" id="L154">			final StringBuilder st = new StringBuilder();</span>

<span class="nc bnc" id="L156" title="All 2 branches missed.">			for (final StackTraceElement e : Thread.currentThread().getStackTrace()) {</span>
<span class="nc" id="L157">				st.append(e);</span>
<span class="nc" id="L158">				st.append(&quot;\n&quot;);</span>
			}

<span class="nc" id="L161">			logger.info(st);</span>
		}

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">		if (turn &lt;= currentTurn) {</span>
<span class="nc" id="L165">			logger.error(&quot;requested turn &quot; + turn</span>
					+ &quot; is in the past. Current turn is &quot; + currentTurn,
					new IllegalArgumentException(&quot;turn&quot;));
<span class="nc" id="L168">			return;</span>
		}

<span class="fc" id="L171">		synchronized (sync) {</span>
			// do we have other events for this turn?
<span class="fc" id="L173">			final Integer turnInt = Integer.valueOf(turn);</span>
<span class="fc" id="L174">			Set&lt;TurnListener&gt; set = register.get(turnInt);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">			if (set == null) {</span>
<span class="fc" id="L176">				set = new HashSet&lt;TurnListener&gt;();</span>
<span class="fc" id="L177">				register.put(turnInt, set);</span>
			}
			// add it to the list
<span class="fc" id="L180">			set.add(turnListener);</span>
<span class="pc" id="L181">		}</span>
<span class="fc" id="L182">	}</span>

	/**
	 * Forgets all registered notification entries for the given TurnListener
	 * where the entry's message equals the given one.
	 * 
	 * @param turnListener
	 */

	public void dontNotify(final TurnListener turnListener) {
		// all events that are equal to this one should be forgotten.
		// TurnEvent turnEvent = new TurnEvent(turnListener);
<span class="fc bfc" id="L194" title="All 2 branches covered.">		for (final Map.Entry&lt;Integer, Set&lt;TurnListener&gt;&gt; mapEntry : register.entrySet()) {</span>
<span class="fc" id="L195">			final Set&lt;TurnListener&gt; set = mapEntry.getValue();</span>
			// We don't remove directly, but first store in this
			// set. This is to avoid ConcurrentModificationExceptions.
<span class="fc" id="L198">			final Set&lt;TurnListener&gt; toBeRemoved = new HashSet&lt;TurnListener&gt;();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">			if (set.contains(turnListener)) {</span>
<span class="fc" id="L200">					toBeRemoved.add(turnListener);</span>
			}
<span class="fc bfc" id="L202" title="All 2 branches covered.">			for (final TurnListener event : toBeRemoved) {</span>
<span class="fc" id="L203">				set.remove(event);</span>
<span class="fc" id="L204">			}</span>
<span class="fc" id="L205">		}</span>
<span class="fc" id="L206">	}</span>

	/**
	 * Finds out how many turns will pass until the given TurnListener will be
	 * notified with the given message.
	 * 
	 * @param turnListener
	 * @return the number of remaining turns, or -1 if the given TurnListener
	 *         will not be notified with the given message.
	 */

	public int getRemainingTurns(final TurnListener turnListener) {
		// all events match that are equal to this.
		// TurnEvent turnEvent = new TurnEvent(turnListener);
		// the HashMap is unsorted, so we need to run through
		// all of it.
<span class="fc" id="L222">		final List&lt;Integer&gt; matchingTurns = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">		for (final Map.Entry&lt;Integer, Set&lt;TurnListener&gt;&gt; mapEntry : register.entrySet()) {</span>
<span class="fc" id="L224">			final Set&lt;TurnListener&gt; set = mapEntry.getValue();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">			for (final TurnListener currentEvent : set) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">				if (currentEvent.equals(turnListener)) {</span>
<span class="fc" id="L227">					matchingTurns.add(mapEntry.getKey());</span>
				}
<span class="fc" id="L229">			}</span>
<span class="fc" id="L230">		}</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">		if (matchingTurns.size() &gt; 0) {</span>
<span class="fc" id="L232">			Collections.sort(matchingTurns);</span>
<span class="fc" id="L233">			return matchingTurns.get(0).intValue() - currentTurn;</span>
		} else {
<span class="fc" id="L235">			return -1;</span>
		}
	}

	/**
	 * Finds out how many seconds will pass until the given TurnListener will be
	 * notified with the given message.
	 * 
	 * @param turnListener
	 * @return the number of remaining seconds, or -1 if the given TurnListener
	 *         will not be notified with the given message.
	 */

	public int getRemainingSeconds(final TurnListener turnListener) {

<span class="nc" id="L250">		return (getRemainingTurns(turnListener) * StendhalRPWorld.MILLISECONDS_PER_TURN) / 1000;</span>
	}

	/**
	 * Returns the list of events. Note this is only for debugging the
	 * TurnNotifier
	 * 
	 * @return eventList
	 */
	public Map&lt;Integer, Set&lt;TurnListener&gt;&gt; getEventListForDebugging() {
<span class="fc" id="L260">		return register;</span>
	}

	/**
	 * Returns the current turn. Note this is only for debugging TurnNotifier
	 * 
	 * @return current turn
	 */
	public int getCurrentTurnForDebugging() {
<span class="fc" id="L269">		return currentTurn;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>