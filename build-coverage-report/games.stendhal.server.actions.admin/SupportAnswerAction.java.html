<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SupportAnswerAction.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.actions.admin</a> &gt; <span class="el_source">SupportAnswerAction.java</span></div><h1>SupportAnswerAction.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                   (C) Copyright 2003-2016 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.actions.admin;

import static games.stendhal.common.constants.Actions.SUPPORTANSWER;
import static games.stendhal.common.constants.Actions.TARGET;
import static games.stendhal.common.constants.Actions.TEXT;
import games.stendhal.common.MathHelper;
import games.stendhal.common.NotificationType;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.common.messages.SupportMessageTemplatesFactory;
import games.stendhal.server.actions.CommandCenter;
import games.stendhal.server.core.engine.GameEvent;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.dbcommand.StoreMessageCommand;
import games.stendhal.server.core.events.TurnListener;
import games.stendhal.server.core.events.TurnListenerDecorator;
import games.stendhal.server.core.events.TurnNotifier;
import games.stendhal.server.entity.player.Player;

import java.util.HashMap;
import java.util.Map;

import marauroa.common.Pair;
import marauroa.common.game.RPAction;
import marauroa.server.db.command.DBCommand;
import marauroa.server.db.command.DBCommandQueue;
import marauroa.server.db.command.ResultHandle;

/**
 * answers a support question
 */
<span class="fc" id="L42">public class SupportAnswerAction extends AdministrationAction implements TurnListener  {</span>

<span class="fc" id="L44">	private static final Map&lt;String, String&gt; messageTemplates = new SupportMessageTemplatesFactory().getTemplates();</span>

	/**
	 * Keeps track of the anonymised admin names and when they were last used
	 */
<span class="fc" id="L49">	private final Map&lt;String, Pair&lt;String, Long&gt;&gt; adminNames = new HashMap&lt;String, Pair&lt;String, Long&gt;&gt; ();</span>

	/**
	 * Amount of time after which an admin name 'anonymiser' will be replaced
	 */
	private static final int DELAY = 3 * MathHelper.SECONDS_IN_ONE_HOUR;

	/**
	 * increments as new names are added to the admin list.
	 * not really bothered as it grows, and that we aren't re-using numbers,
	 * just easier than checking the list to see what the next number should be
	 *
	 */
<span class="fc" id="L62">	private int nameCounter = 0;</span>

	/**
	 * the admin who sent the message (needed as a class variable for postman messages)
	 */
	private String sender;

<span class="fc" id="L69">	private final ResultHandle handle = new ResultHandle();</span>

	public static void register() {
<span class="fc" id="L72">		CommandCenter.register(SUPPORTANSWER, new SupportAnswerAction(), 50);</span>
<span class="fc" id="L73">	}</span>

	@Override
	public void perform(final Player player, final RPAction action) {
<span class="pc bpc" id="L77" title="2 of 4 branches missed.">		if (!action.has(TARGET) || !action.has(TEXT)) {</span>
<span class="nc" id="L78">			return;</span>
		}
<span class="fc" id="L80">		String reply = action.get(TEXT);</span>

<span class="pc bpc" id="L82" title="1 of 2 branches missed.">		if (!player.getChatBucket().checkAndAdd(reply.length())) {</span>
<span class="nc" id="L83">			return;</span>
		}
<span class="fc" id="L85">		sender = player.getName();</span>
<span class="pc bpc" id="L86" title="3 of 4 branches missed.">		if (action.has(&quot;sender&quot;) &amp;&amp; (player.getName().equals(&quot;postman&quot;))) {</span>
<span class="nc" id="L87">			sender = action.get(&quot;sender&quot;);</span>
		}

		// test for use of standard response shortcut, and replace the reply message if so
		// if you alter these please update client/actions/GMHelpAction (or put the string replies in a common file if you like)
<span class="fc" id="L92">		final Player supported = SingletonRepository.getRuleProcessor().getPlayer(action.get(TARGET));</span>

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">		if (reply.startsWith(&quot;$&quot;)) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">			if (messageTemplates.containsKey(reply)) {</span>
<span class="nc" id="L96">				reply = messageTemplates.get(reply);</span>
<span class="nc" id="L97">				reply = String.format(reply, action.get(TARGET));</span>
			} else {
<span class="nc" id="L99">				player.sendPrivateText(reply + &quot; is not a recognised shortcut. Please check #/gmhelp #support for a list.&quot;);</span>
				// send no support answer message if the shortcut wasn't understood
<span class="nc" id="L101">				return;</span>
			}
		}

<span class="fc" id="L105">		final String message = sender + &quot; answers &quot; + Grammar.suffix_s(action.get(TARGET))</span>
				+ &quot; support question: &quot; + reply;

<span class="fc" id="L108">		new GameEvent(sender, SUPPORTANSWER, action.get(TARGET), reply).raise();</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (supported != null) {</span>

<span class="fc" id="L111">			supported.sendPrivateText(NotificationType.SUPPORT, &quot;Support (&quot; + getAnonymisedAdminName(sender) + &quot;) tells you: &quot; + reply + &quot; \nIf you wish to reply, use /support.&quot;);</span>
<span class="fc" id="L112">			supported.notifyWorldAboutChanges();</span>
<span class="fc" id="L113">			SingletonRepository.getRuleProcessor().sendMessageToSupporters(message);</span>

		} else {
			// that player is not logged in. Do they exist at all or are they just offline? Try sending a message with postman.
<span class="nc" id="L117">			DBCommand command = new StoreMessageCommand(getAnonymisedAdminName(sender), action.get(TARGET), &quot;In answer to your support question:\n&quot; + reply + &quot; \nIf you wish to reply, use /support.&quot;, &quot;S&quot;);</span>
<span class="nc" id="L118">			DBCommandQueue.get().enqueueAndAwaitResult(command, handle);</span>
<span class="nc" id="L119">			TurnNotifier.get().notifyInTurns(0, new TurnListenerDecorator(this));</span>
		}
<span class="fc" id="L121">	}</span>

	/**
	 * Completes handling the supportanswer action.
	 *
	 * @param currentTurn ignored
	 */
	@Override
	public void onTurnReached(int currentTurn) {
<span class="nc" id="L130">		StoreMessageCommand checkcommand = DBCommandQueue.get().getOneResult(StoreMessageCommand.class, handle);</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (checkcommand == null) {</span>
<span class="nc" id="L133">			TurnNotifier.get().notifyInTurns(0, new TurnListenerDecorator(this));</span>
<span class="nc" id="L134">			return;</span>
		}

<span class="nc" id="L137">		boolean characterExists = checkcommand.targetCharacterExists();</span>
<span class="nc" id="L138">		String target = checkcommand.getTarget();</span>
<span class="nc" id="L139">		String supportmessage = checkcommand.getMessage();</span>

<span class="nc" id="L141">		final Player admin = SingletonRepository.getRuleProcessor().getPlayer(sender);</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">		if(!characterExists) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">			if (admin != null) {</span>
				// incase admin logged out while waiting we want to avoid NPE
<span class="nc" id="L146">				admin.sendPrivateText(NotificationType.ERROR, &quot;Sorry, &quot; + target + &quot; could not be found.&quot;);</span>
			}
<span class="nc" id="L148">			return;</span>
		}

<span class="nc" id="L151">		final String message = sender + &quot; answers &quot; + Grammar.suffix_s(target)</span>
				+ &quot; support question using postman: &quot; + supportmessage;

<span class="nc" id="L154">		SingletonRepository.getRuleProcessor().sendMessageToSupporters(message);</span>
<span class="nc" id="L155">	}</span>


	/**
	 * Gets anonymised admin name from map and updates timestamp,
	 * or sets new anonymised name if some time has passed since last use of supportanswer
	 * 
	 * @param adminName adminstrator name
	 * @return anonymized name for the adminstarator
	 */
	private String getAnonymisedAdminName(String adminName) {
		String anonymisedAdminName;
		// is the name already listed?
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">		if(adminNames.containsKey(adminName)) {</span>
<span class="nc" id="L169">			Long lastTime = adminNames.get(adminName).second();</span>
			// time has passed, use a new name in place of the last anonymised name
<span class="nc bnc" id="L171" title="All 2 branches missed.">			if ((System.currentTimeMillis() - lastTime) &gt; (DELAY * 1000L)) {</span>
<span class="nc" id="L172">				nameCounter++;</span>
<span class="nc" id="L173">				anonymisedAdminName = &quot;admin&quot;+nameCounter;</span>
			} else {
				// just get the name to use from the existing map without changing it
<span class="nc" id="L176">				anonymisedAdminName = adminNames.get(adminName).first();</span>
			}
<span class="nc" id="L178">		} else {</span>
			// name wasn't listed yet, set up the next name to use
<span class="fc" id="L180">			nameCounter++;</span>
<span class="fc" id="L181">			anonymisedAdminName = &quot;admin&quot;+nameCounter;</span>
		}
		// whether we changed the name to use or not, update the last used timestamp
<span class="fc" id="L184">		adminNames.put(adminName, new Pair&lt;String,Long&gt;(anonymisedAdminName, System.currentTimeMillis()));</span>
<span class="fc" id="L185">		return anonymisedAdminName;</span>
	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>