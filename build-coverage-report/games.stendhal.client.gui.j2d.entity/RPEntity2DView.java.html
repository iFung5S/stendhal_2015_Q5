<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RPEntity2DView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui.j2d.entity</a> &gt; <span class="el_source">RPEntity2DView.java</span></div><h1>RPEntity2DView.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui.j2d.entity;


import games.stendhal.client.IGameScreen;
import games.stendhal.client.entity.ActionType;
import games.stendhal.client.entity.Entity;
import games.stendhal.client.entity.IEntity;
import games.stendhal.client.entity.Player;
import games.stendhal.client.entity.RPEntity;
import games.stendhal.client.entity.StatusID;
import games.stendhal.client.entity.TextIndicator;
import games.stendhal.client.entity.User;
import games.stendhal.client.gui.j2d.entity.helpers.AttackPainter;
import games.stendhal.client.gui.j2d.entity.helpers.HorizontalAlignment;
import games.stendhal.client.gui.j2d.entity.helpers.VerticalAlignment;
import games.stendhal.client.sprite.AnimatedSprite;
import games.stendhal.client.sprite.Sprite;
import games.stendhal.client.sprite.SpriteStore;
import games.stendhal.client.sprite.TextSprite;
import games.stendhal.common.Debug;
import games.stendhal.common.Direction;
import games.stendhal.common.constants.Nature;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import marauroa.common.game.RPAction;

/**
 * The 2D view of an RP entity.
 * 
 * @param &lt;T&gt; type of RPEntity
 */
abstract class RPEntity2DView&lt;T extends RPEntity&gt; extends ActiveEntity2DView&lt;T&gt; {
	
	private static final int ICON_OFFSET = 8;
	private static final int HEALTH_BAR_HEIGHT = 4;

	// Battle icons
	private static final Sprite blockedSprite;
	private static final Sprite hitSprite;
	private static final Sprite missedSprite;
	
	// Job icons
	private static final Sprite healerSprite;
	private static final Sprite merchantSprite;
	
	// Status icons
	private static final Sprite chokingSprite;
	private static final Sprite confusedSprite;
	private static final Sprite eatingSprite;
	private static final Sprite poisonedSprite;
	private static final Sprite shockedSprite;
	private static final Sprite heavySprite;
	
	/** Colors of the ring/circle around the player while attacking or being attacked. */
<span class="nc" id="L77">	private static final Color RING_COLOR_RED = new Color(230, 10, 10);</span>
<span class="nc" id="L78">	private static final Color RING_COLOR_DARK_RED = new Color(74, 0, 0);</span>
<span class="nc" id="L79">	private static final Color RING_COLOR_ORANGE = new Color(255, 200, 0);</span>
	
	private static final double SQRT2 = 1.414213562;
	
	/** Temporary text sprites, like HP and XP changes. */
<span class="nc" id="L84">	private Map&lt;TextIndicator, Sprite&gt; floaters = new HashMap&lt;TextIndicator, Sprite&gt;();</span>

	/**
	 * Model attributes effecting the title changed.
	 */
	private boolean titleChanged;
	/** &lt;code&gt;true&lt;/code&gt; if the view should show the entity title. */
	private boolean showTitle;
	/** &lt;code&gt;true&lt;/code&gt; if the view should show the HP bar. */
	private boolean showHP;

	/**
	 * The title image sprite.
	 */
	private Sprite titleSprite;

	/** The drawn height. */
	protected int height;

	/** The drawn width. */
	protected int width;
	/** Status icon managers. */
<span class="nc" id="L106">	private final List&lt;AbstractStatusIconManager&gt; iconManagers = new ArrayList&lt;AbstractStatusIconManager&gt;();</span>
	private HealthBar healthBar; 

	/** 
	 * Flag for detecting if any of the icon manager managed icons have
	 * changed.
	 */
	private volatile boolean iconsChanged;
	/**
	 * Flag for checking if the entity is attacking. Can be modified by both
	 * the EDT and the game loop.
	 */
	private volatile boolean isAttacking;
	/** &lt;code&gt;true&lt;/code&gt; if the current attack is ranged. */
	private boolean rangedAttack;

	/** Object for drawing the attack. */
	private AttackPainter attackPainter;
	
	static {
<span class="nc" id="L126">		final SpriteStore st = SpriteStore.get();</span>

		// Battle icons
<span class="nc" id="L129">		hitSprite = st.getCombatSprite(&quot;hitted.png&quot;);</span>
<span class="nc" id="L130">		blockedSprite = st.getCombatSprite(&quot;blocked.png&quot;);</span>
<span class="nc" id="L131">		missedSprite = st.getCombatSprite(&quot;missed.png&quot;);</span>
		
		// Job icons
<span class="nc" id="L134">		healerSprite = st.getStatusSprite(&quot;healer.png&quot;);</span>
<span class="nc" id="L135">		merchantSprite = st.getStatusSprite(&quot;merchant.png&quot;);</span>
		
		// Status icons
<span class="nc" id="L138">		confusedSprite = st.getAnimatedSprite(st.getStatusSprite(&quot;confuse.png&quot;), 200);</span>
<span class="nc" id="L139">		eatingSprite = st.getSprite(&quot;data/sprites/ideas/eat.png&quot;);</span>
<span class="nc" id="L140">		poisonedSprite = st.getAnimatedSprite(st.getStatusSprite(&quot;poison.png&quot;), 100);</span>
<span class="nc" id="L141">		chokingSprite = st.getSprite(&quot;data/sprites/ideas/choking.png&quot;);</span>
<span class="nc" id="L142">		shockedSprite = st.getAnimatedSprite(st.getStatusSprite(&quot;shock.png&quot;), 38, 200);</span>
<span class="nc" id="L143">		heavySprite = st.getAnimatedSprite(st.getStatusSprite(&quot;heavy.png&quot;), 200);</span>
<span class="nc" id="L144">	}</span>

	/**
	 * Create a new RPEntity2DView.
	 */
<span class="nc" id="L149">	public RPEntity2DView() {</span>
		// Job icons
<span class="nc" id="L151">		addIconManager(new StatusIconManager(Player.PROP_HEALER, healerSprite,</span>
				HorizontalAlignment.LEFT, VerticalAlignment.BOTTOM, StatusID.HEALER));
<span class="nc" id="L153">		addIconManager(new StatusIconManager(Player.PROP_MERCHANT, merchantSprite,</span>
				HorizontalAlignment.LEFT, VerticalAlignment.BOTTOM, StatusID.MERCHANT));

		// Status icons
		/* choking status */
<span class="nc" id="L158">		addIconManager(new AbstractStatusIconManager(Player.PROP_EATING, chokingSprite,</span>
<span class="nc" id="L159">				HorizontalAlignment.LEFT, VerticalAlignment.BOTTOM) {</span>
			@Override
			boolean show(T rpentity) {
<span class="nc" id="L162">				return rpentity.isChoking();</span>
			}
		});

		/* confused status */
<span class="nc" id="L167">		addIconManager(new StatusIconManager(Player.PROP_CONFUSED, confusedSprite,</span>
				HorizontalAlignment.RIGHT, VerticalAlignment.MIDDLE, StatusID.CONFUSE));

		/* eating status */
<span class="nc" id="L171">		addIconManager(new AbstractStatusIconManager(Player.PROP_EATING, eatingSprite,</span>
<span class="nc" id="L172">				HorizontalAlignment.LEFT, VerticalAlignment.BOTTOM) {</span>
			@Override
			boolean show(T rpentity) {
<span class="nc bnc" id="L175" title="All 4 branches missed.">				return rpentity.isEating() &amp;&amp; !rpentity.isChoking();</span>
			}
		});

		/* poison status */
<span class="nc" id="L180">		StatusIconManager poisonManager = new StatusIconManager(Player.PROP_POISONED, poisonedSprite,</span>
				HorizontalAlignment.CENTER, VerticalAlignment.MIDDLE, StatusID.POISON);
<span class="nc" id="L182">		poisonManager.setOffsets(10, -13);</span>
<span class="nc" id="L183">		addIconManager(poisonManager);</span>

		/* shock status */
<span class="nc" id="L186">		addIconManager(new StatusIconManager(Player.PROP_SHOCK, shockedSprite,</span>
				HorizontalAlignment.CENTER, VerticalAlignment.BOTTOM, StatusID.SHOCK));

		/* heavy status */
<span class="nc" id="L190">		StatusIconManager heavyManager = new StatusIconManager(Player.PROP_HEAVY,</span>
				heavySprite, HorizontalAlignment.CENTER, VerticalAlignment.MIDDLE,
				StatusID.HEAVY);
<span class="nc" id="L193">		heavyManager.setOffsets(0, 32);</span>
<span class="nc" id="L194">		addIconManager(heavyManager);</span>

<span class="nc" id="L196">		setSpriteAlignment(HorizontalAlignment.CENTER, VerticalAlignment.BOTTOM);</span>
<span class="nc" id="L197">	}</span>

	@Override
	public void initialize(final T entity) {
<span class="nc" id="L201">		super.initialize(entity);</span>
<span class="nc" id="L202">		showTitle = entity.showTitle();</span>
<span class="nc" id="L203">		showHP = entity.showHPBar();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">		if (showTitle) {</span>
<span class="nc" id="L205">			titleSprite = createTitleSprite();</span>
		}
<span class="nc" id="L207">		titleChanged = false;</span>
<span class="nc" id="L208">		iconsChanged = true;</span>
<span class="nc" id="L209">	}</span>
	
	//
	// RPEntity2DView
	//

	/**
	 * Populate keyed state sprites.
	 * 
	 * @param map
	 *            The map to populate.
	 * @param tiles
	 *            The master sprite.
	 * @param width
	 *            The tile width (in pixels).
	 * @param height
	 *            The tile height (in pixels).
	 */
	protected void buildSprites(final Map&lt;Object, Sprite&gt; map,
			final Sprite tiles, final int width, final int height) {
<span class="nc" id="L229">		int y = 0;</span>
<span class="nc" id="L230">		map.put(Direction.UP, createWalkSprite(tiles, y, width, height));</span>

<span class="nc" id="L232">		y += height;</span>
<span class="nc" id="L233">		map.put(Direction.RIGHT, createWalkSprite(tiles, y, width, height));</span>

<span class="nc" id="L235">		y += height;</span>
<span class="nc" id="L236">		map.put(Direction.DOWN, createWalkSprite(tiles, y, width, height));</span>

<span class="nc" id="L238">		y += height;</span>
<span class="nc" id="L239">		map.put(Direction.LEFT, createWalkSprite(tiles, y, width, height));</span>
<span class="nc" id="L240">	}</span>

	/**
	 * Create the title sprite.
	 * 
	 * @return The title sprite.
	 */
	private Sprite createTitleSprite() {
<span class="nc" id="L248">		final String titleType = entity.getTitleType();</span>
<span class="nc" id="L249">		final int adminlevel = entity.getAdminLevel();</span>
<span class="nc" id="L250">		Color nameColor = null;</span>

<span class="nc bnc" id="L252" title="All 2 branches missed.">		if (titleType != null) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">			if (titleType.equals(&quot;npc&quot;)) {</span>
<span class="nc" id="L254">				nameColor = new Color(200, 200, 255);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">			} else if (titleType.equals(&quot;enemy&quot;)) {</span>
<span class="nc" id="L256">				nameColor = new Color(255, 200, 200);</span>
			}
		}

<span class="nc bnc" id="L260" title="All 2 branches missed.">		if (nameColor == null) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			if (adminlevel &gt;= 800) {</span>
<span class="nc" id="L262">				nameColor = new Color(200, 200, 0);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">			} else if (adminlevel &gt;= 400) {</span>
<span class="nc" id="L264">				nameColor = Color.yellow;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">			} else if (adminlevel &gt; 0) {</span>
<span class="nc" id="L266">				nameColor = new Color(255, 255, 172);</span>
			} else {
<span class="nc" id="L268">				nameColor = Color.white;</span>
			}
		}

<span class="nc" id="L272">		return TextSprite.createTextSprite(entity.getTitle(), nameColor);</span>
	}

	/**
	 * Extract a walking animation for a specific row. The source sprite
	 * contains 3 animation tiles, but this is converted to 4 frames.
	 * 
	 * @param tiles
	 *            The tile image.
	 * @param y
	 *            The base Y coordinate.
	 * @param width
	 *            The frame width.
	 * @param height
	 *            The frame height.
	 * 
	 * @return A sprite.
	 */
	protected Sprite createWalkSprite(final Sprite tiles, final int y,
			final int width, final int height) {
<span class="nc" id="L292">		final SpriteStore store = SpriteStore.get();</span>

<span class="nc" id="L294">		final Sprite[] frames = new Sprite[4];</span>

<span class="nc" id="L296">		int x = 0;</span>
<span class="nc" id="L297">		frames[0] = store.getTile(tiles, x, y, width, height);</span>

<span class="nc" id="L299">		x += width;</span>
<span class="nc" id="L300">		frames[1] = store.getTile(tiles, x, y, width, height);</span>

<span class="nc" id="L302">		x += width;</span>
<span class="nc" id="L303">		frames[2] = store.getTile(tiles, x, y, width, height);</span>

<span class="nc" id="L305">		frames[3] = frames[1];</span>

<span class="nc" id="L307">		return new AnimatedSprite(frames, 100, false);</span>
	}
	
	/**
	 * Add a new status icon manager.
	 * 
	 * @param manager
	 */
	final void addIconManager(AbstractStatusIconManager manager) {
<span class="nc" id="L316">		iconManagers.add(manager);</span>
<span class="nc" id="L317">	}</span>

	/**
	 * Draw the floating text indicators (floaters).
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn width.
	 */
	private void drawFloaters(final Graphics2D g2d, final int x, final int y,
			final int width) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">		for (Map.Entry&lt;TextIndicator, Sprite&gt; floater : floaters.entrySet()) {</span>
<span class="nc" id="L334">			final TextIndicator indicator = floater.getKey();</span>
<span class="nc" id="L335">			final Sprite sprite = floater.getValue();</span>
<span class="nc" id="L336">			final int age = indicator.getAge();</span>
			
<span class="nc" id="L338">			final int tx = x + (width - sprite.getWidth()) / 2;</span>
<span class="nc" id="L339">			final int ty = y - (int) (age * 5L / 300L);</span>
<span class="nc" id="L340">			sprite.draw(g2d, tx, ty);</span>
<span class="nc" id="L341">		}</span>
<span class="nc" id="L342">	}</span>

	/**
	 * Draw the entity HP bar.
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn width.
	 */
	protected void drawHPbar(final Graphics2D g2d, final int x, final int y,
			final int width) {
<span class="nc" id="L358">		int dx = (width - healthBar.getWidth()) / 2;</span>
<span class="nc" id="L359">		healthBar.draw(g2d, x + dx, y - healthBar.getHeight());</span>
<span class="nc" id="L360">	}</span>

	/**
	 * Draw the entity status bar. The status bar show the title and HP bar.
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn width.
	 */
	protected void drawStatusBar(final Graphics2D g2d, final int x,
			final int y, final int width) {
<span class="nc bnc" id="L376" title="All 2 branches missed.">		if (showTitle) {</span>
<span class="nc" id="L377">			drawTitle(g2d, x, y, width);</span>
		}
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (showHP) {</span>
<span class="nc" id="L380">			drawHPbar(g2d, x, y, width);</span>
		}
<span class="nc" id="L382">	}</span>

	/**
	 * Draw the entity title.
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn width.
	 */
	protected void drawTitle(final Graphics2D g2d, final int x, final int y, final int width) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">		if (titleSprite != null) {</span>
<span class="nc" id="L398">			final int tx = x + ((width - titleSprite.getWidth()) / 2);</span>
<span class="nc" id="L399">			final int ty = y - 3 - titleSprite.getHeight();</span>

<span class="nc" id="L401">			titleSprite.draw(g2d, tx, ty);</span>
		}
<span class="nc" id="L403">	}</span>

	/**
	 * Draw the combat indicators. 
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn entity width.
	 * @param height
	 *            The drawn entity height.
	 */
	private void drawCombat(final Graphics2D g2d, final int x,
							  final int y, final int width, final int height) {
<span class="nc" id="L421">		Rectangle2D wrect = entity.getArea();</span>
<span class="nc" id="L422">		final Rectangle srect = new Rectangle(</span>
				(int) (wrect.getX() * IGameScreen.SIZE_UNIT_PIXELS),
				(int) (wrect.getY() * IGameScreen.SIZE_UNIT_PIXELS), 
				(int) (wrect.getWidth() * IGameScreen.SIZE_UNIT_PIXELS),
				(int) (wrect.getHeight() * IGameScreen.SIZE_UNIT_PIXELS)
		);
		
		// Calculating the circle's height
<span class="nc" id="L430">		int circleHeight = (int) ((srect.height - 2) / SQRT2);</span>
<span class="nc" id="L431">		circleHeight = Math.max(circleHeight, srect.height - IGameScreen.SIZE_UNIT_PIXELS / 2);</span>
		
		// When the entity is attacking the user give him a orange ring
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if (entity.isAttacking(User.get())) {</span>
<span class="nc" id="L435">			g2d.setColor(RING_COLOR_ORANGE); </span>
<span class="nc" id="L436">			g2d.drawOval(srect.x - 1, srect.y + srect.height - circleHeight, srect.width, circleHeight);</span>
<span class="nc" id="L437">			g2d.drawOval(srect.x, srect.y + srect.height - circleHeight, srect.width, circleHeight);</span>
<span class="nc" id="L438">			g2d.drawOval(srect.x + 1, srect.y + srect.height - circleHeight, srect.width, circleHeight);</span>
<span class="nc" id="L439">			drawShadedOval(g2d, srect.x + 1, srect.y + srect.height - circleHeight + 1, srect.width - 2, circleHeight - 2, RING_COLOR_ORANGE, true, false);</span>
		}
		
		// When the entity is attacked by another entity
<span class="nc bnc" id="L443" title="All 2 branches missed.">		if (entity.isBeingAttacked()) {</span>
			Color lineColor;
<span class="nc" id="L445">			g2d.setColor(RING_COLOR_RED);</span>
			
			// When it is also attacking the user give him only a red outline
<span class="nc bnc" id="L448" title="All 2 branches missed.">			if (entity.isAttacking(User.get())) {</span>
<span class="nc" id="L449">				lineColor = RING_COLOR_RED;</span>
<span class="nc" id="L450">				drawShadedOval(g2d, srect.x - 1, srect.y + srect.height - circleHeight - 1, srect.width + 2, circleHeight + 2, RING_COLOR_RED, false, true);</span>
			} else {
				// Otherwise make his complete ring red
<span class="nc" id="L453">				lineColor = RING_COLOR_DARK_RED;</span>
<span class="nc" id="L454">				g2d.drawOval(srect.x - 1, srect.y + srect.height - circleHeight, srect.width, circleHeight);</span>
<span class="nc" id="L455">				g2d.drawOval(srect.x, srect.y + srect.height - circleHeight, srect.width, circleHeight);</span>
<span class="nc" id="L456">				g2d.drawOval(srect.x + 1, srect.y + srect.height - circleHeight, srect.width, circleHeight);</span>
<span class="nc" id="L457">				drawShadedOval(g2d, srect.x + 1, srect.y + srect.height - circleHeight + 1, srect.width - 2, circleHeight - 2, RING_COLOR_RED, true, false);</span>
<span class="nc" id="L458">				drawShadedOval(g2d, srect.x - 1, srect.y + srect.height - circleHeight - 1, srect.width + 2, circleHeight + 2, RING_COLOR_ORANGE, false, false);</span>
			}
			
			// Get the direction of his opponents and draw an arrow to those
<span class="nc" id="L462">			EnumSet&lt;Direction&gt; directions = EnumSet.noneOf(Direction.class);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">			for (Entity attacker : entity.getAttackers()) {</span>
<span class="nc" id="L464">				directions.add(Direction.getAreaDirectionTowardsArea(entity.getArea(), attacker.getArea()));	</span>
<span class="nc" id="L465">			}</span>
<span class="nc" id="L466">			drawArrows(g2d, srect.x - 1, srect.y + srect.height - circleHeight - 1, srect.width + 2, circleHeight + 2, directions, lineColor);</span>
		
		// When the entity is attacked by the user, but still is attacking the user, give him a dark orange outline
<span class="nc bnc" id="L469" title="All 2 branches missed.">		} else if (entity.isAttacking(User.get())) {</span>
<span class="nc" id="L470">			drawShadedOval(g2d, srect.x - 1, srect.y + srect.height - circleHeight - 1, srect.width + 2, circleHeight + 2, RING_COLOR_ORANGE, false, false);</span>
		}
		
<span class="nc" id="L473">		drawAttack(g2d, x, y, width, height);</span>
		
<span class="nc bnc" id="L475" title="All 2 branches missed.">		if (entity.isDefending()) {</span>
			// Draw bottom right combat icon
<span class="nc" id="L477">			final int sx = srect.x + srect.width - ICON_OFFSET;</span>
<span class="nc" id="L478">			final int sy = y + height - 2 * ICON_OFFSET;</span>

<span class="nc bnc" id="L480" title="All 4 branches missed.">			switch (entity.getResolution()) {</span>
			case BLOCKED:
<span class="nc" id="L482">				blockedSprite.draw(g2d, sx, sy);</span>
<span class="nc" id="L483">				break;</span>

			case MISSED:
<span class="nc" id="L486">				missedSprite.draw(g2d, sx, sy);</span>
<span class="nc" id="L487">				break;</span>

			case HIT:
<span class="nc" id="L490">				hitSprite.draw(g2d, sx, sy);</span>
<span class="nc" id="L491">				break;</span>
			default:
				// cannot happen we are switching on enum
			}
		}
<span class="nc" id="L496">	}</span>
	
	/**
	 * Function to draw the arrows on the attack/being attacked ring.
	 * 
	 * @param g2d The graphic context
	 * @param x The x-center of the arrows
	 * @param y The y-center of the arrows
	 * @param width ring width
	 * @param height ring height
	 * @param directions The directions an arrow should be drawn
	 * @param lineColor The color of the outline of the arrow
	 */
	private void drawArrows(final Graphics2D g2d, final int x, final int y, final int width, final int height, final EnumSet&lt;Direction&gt; directions, final Color lineColor) {
<span class="nc" id="L510">		int arrowHeight = 6 + 2 * (height / 23 - 1);</span>
<span class="nc" id="L511">		int arrowWidth = 3 + (width / 34 - 1);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">		if (directions.contains(Direction.LEFT)) {</span>
<span class="nc" id="L513">			g2d.setColor(Color.RED);</span>
<span class="nc" id="L514">			g2d.fillPolygon(</span>
					new int[] {x+1, x-arrowWidth, x+1},
					new int[]{y+(height/2)-(arrowHeight/2), y+(height/2),y+(height/2)+(arrowHeight/2)},
					3);
<span class="nc" id="L518">			g2d.setColor(lineColor);</span>
<span class="nc" id="L519">			g2d.drawPolyline(</span>
					new int[]{x, x-arrowWidth, x},
					new int[]{y+(height/2)-(arrowHeight/2), y+(height/2), y+(height/2)+(arrowHeight/2)},
					3);
		}
<span class="nc bnc" id="L524" title="All 2 branches missed.">		if (directions.contains(Direction.RIGHT)) {</span>
<span class="nc" id="L525">			g2d.setColor(Color.RED);</span>
<span class="nc" id="L526">			g2d.fillPolygon(</span>
					new int[]{x+width, x+width+arrowWidth, x+width},
					new int[]{y+(height/2)-(arrowHeight/2), y+(height/2), y+(height/2)+(arrowHeight/2)},
					3);
<span class="nc" id="L530">			g2d.setColor(lineColor);</span>
<span class="nc" id="L531">			g2d.drawPolyline(</span>
					new int[]{x+width, x+width+arrowWidth, x+width},
					new int[]{y+(height/2)-(arrowHeight/2), y+(height/2), y+(height/2)+(arrowHeight/2)},
					3);
		}
<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (directions.contains(Direction.UP)) {</span>
<span class="nc" id="L537">			g2d.setColor(Color.RED);</span>
<span class="nc" id="L538">			g2d.fillPolygon(</span>
					new int[]{x+(width/2)-(arrowHeight/2), x+(width/2), x+(width/2)+(arrowHeight/2)},
					new int[]{y+1, y-arrowWidth, y+1},
					3);
<span class="nc" id="L542">			g2d.setColor(lineColor);</span>
<span class="nc" id="L543">			g2d.drawPolyline(</span>
					new int[]{x+(width/2)-(arrowHeight/2), x+(width/2), x+(width/2)+(arrowHeight/2)},
					new int[]{y, y-arrowWidth, y},
					3);
		}
<span class="nc bnc" id="L548" title="All 2 branches missed.">		if (directions.contains(Direction.DOWN)) {</span>
<span class="nc" id="L549">			g2d.setColor(Color.RED);</span>
<span class="nc" id="L550">			g2d.fillPolygon(</span>
					new int[]{x+(width/2)-(arrowHeight/2), x+(width/2), x+(width/2)+(arrowHeight/2)},
					new int[]{y+height, y+height+arrowWidth, y+height},
					3);
<span class="nc" id="L554">			g2d.setColor(lineColor);</span>
<span class="nc" id="L555">			g2d.drawPolyline(</span>
					new int[]{x+(width/2)-(arrowHeight/2), x+(width/2), x+(width/2)+(arrowHeight/2)},
					new int[]{y+height, y+height+arrowWidth, y+height},
					3);
		}
<span class="nc" id="L560">	}</span>
	
	/**
	 * @param g2d The graphic context
	 * @param x The x-position of the upperleft of the oval
	 * @param y The y-position of the upperleft of the oval
	 * @param width The widht of the oval
	 * @param height The height of the oval
	 * @param color The base color of the oval, shadow still needs to be applied
	 * @param reversed Whether the bottom part, or the upper part should be dark (true is upper part)
	 * @param light
	 */
	private void drawShadedOval(final Graphics2D g2d, final int x, final int y, final int width, final int height, final Color color, final boolean reversed, final boolean light) {
		
		// Calculate how much darker the ring must be made (depends on the boolean 'light')
		float multi1;
		float multi2;
<span class="nc bnc" id="L577" title="All 2 branches missed.">		if (light) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">			multi1 = reversed ? 1f : 0.8f;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			multi2 = reversed ? 0.8f : 1f;</span>
		} else {
<span class="nc bnc" id="L581" title="All 2 branches missed.">			multi1 = reversed ? 0.24f : 0.39f;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			multi2 = reversed ? 0.39f : 0.24f;</span>
		}
		
		// Darken the colors by the given multiplier
<span class="nc" id="L586">		Color color1 = new Color((int) (color.getRed() * multi1), (int) (color.getGreen() * multi1), (int) (color.getBlue() * multi1));</span>
<span class="nc" id="L587">		Color color2 = new Color((int) (color.getRed() * multi2), (int) (color.getGreen() * multi2), (int) (color.getBlue() * multi2));</span>
		
		// Draw with two arcs a oval
<span class="nc" id="L590">		g2d.setColor(color1);</span>
<span class="nc" id="L591">		g2d.drawArc(x, y, width, height, 0, 180);</span>
<span class="nc" id="L592">		g2d.setColor(color2);</span>
<span class="nc" id="L593">		g2d.drawArc(x, y, width, height, 180, 180);</span>
<span class="nc" id="L594">	}</span>
	
	/**
	 * Draw the attacking effect.
	 * 
	 * @param g2d The graphics context 
	 * @param x x coordinate of the attacker
	 * @param y y coordinate of the attacker
	 * @param width width of the attacker
	 * @param height height of the attacker
	 */
	private void drawAttack(final Graphics2D g2d, final int x, final int y, final int width, final int height) {
<span class="nc bnc" id="L606" title="All 2 branches missed.">		if (isAttacking) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">			if (!attackPainter.isDoneAttacking()) {</span>
<span class="nc" id="L608">				RPEntity target = entity.getAttackTarget();</span>
				
<span class="nc bnc" id="L610" title="All 2 branches missed.">				if (target != null) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">					if (rangedAttack) {</span>
<span class="nc" id="L612">						attackPainter.drawDistanceAttack(g2d, entity, target, x, y, width, height);</span>
					} else {
<span class="nc" id="L614">						attackPainter.draw(g2d, entity.getDirection(), x, y, width, height);</span>
					}
				}
<span class="nc" id="L617">			} else {</span>
<span class="nc" id="L618">				isAttacking = false;</span>
			}
		}
<span class="nc" id="L621">	}	</span>

	/**
	 * Get the full directional animation tile set for this entity.
	 * 
	 * @return A tile sprite containing all animation images.
	 */
	protected abstract Sprite getAnimationSprite();

	/**
	 * Get the number of tiles in the X axis of the base sprite.
	 * 
	 * @return The number of tiles.
	 */
	protected int getTilesX() {
<span class="nc" id="L636">		return 3;</span>
	}

	/**
	 * Get the number of tiles in the Y axis of the base sprite.
	 * 
	 * @return The number of tiles.
	 */
	protected int getTilesY() {
<span class="nc" id="L645">		return 4;</span>
	}

	/**
	 * Determine is the user can see this entity while in ghostmode.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the client user can see this entity while in
	 *         ghostmode.
	 */
	protected boolean isVisibleGhost() {
<span class="nc" id="L655">		return false;</span>
	}

	//
	// StateEntity2DView
	//

	/**
	 * Populate keyed state sprites.
	 * 
	 * @param entity the entity to build sprites for
	 * @param map
	 *            The map to populate.
	 */
	@Override
	protected void buildSprites(T entity, final Map&lt;Object, Sprite&gt; map) {
<span class="nc" id="L671">		final Sprite tiles = getAnimationSprite();</span>

<span class="nc" id="L673">		width = tiles.getWidth() / getTilesX();</span>
<span class="nc" id="L674">		height = tiles.getHeight() / getTilesY();</span>

<span class="nc" id="L676">		buildSprites(map, tiles, width, height);</span>
<span class="nc" id="L677">		calculateOffset(entity, width, height);</span>
		
		/*
		 * Set icons for a newly created entity.
		 */
<span class="nc" id="L682">		checkIcons();</span>
		
		// Prepare the health bar
<span class="nc" id="L685">		int barWidth = Math.max(width * 2 / 3, IGameScreen.SIZE_UNIT_PIXELS);</span>
<span class="nc" id="L686">		healthBar = new HealthBar(barWidth, HEALTH_BAR_HEIGHT);</span>
<span class="nc" id="L687">		healthBar.setHPRatio(entity.getHpRatio());</span>
<span class="nc" id="L688">	}</span>
	
	/**
	 * Check if icon states have changed.
	 */
	private void checkIcons() {
<span class="nc bnc" id="L694" title="All 2 branches missed.">		for (AbstractStatusIconManager handler : iconManagers) {</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">			if (handler.check(entity)) {</span>
<span class="nc" id="L696">				iconsChanged = true;</span>
			}
<span class="nc" id="L698">		}</span>
<span class="nc" id="L699">	}</span>
	
	/**
	 * Check if icon states have changed.
	 * 
	 * @param property the changed property 
	 */
	private void checkIcons(Object property) {
<span class="nc bnc" id="L707" title="All 2 branches missed.">		for (AbstractStatusIconManager handler : iconManagers) {</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">			if (handler.check(property, entity)) {</span>
<span class="nc" id="L709">				iconsChanged = true;</span>
			}
<span class="nc" id="L711">		}</span>
<span class="nc" id="L712">	}</span>

	//
	// Entity2DView
	//

	/**
	 * Build a list of entity specific actions. &lt;strong&gt;NOTE: The first entry
	 * should be the default.&lt;/strong&gt;
	 * 
	 * @param list
	 *            The list to populate.
	 */
	@Override
	protected void buildActions(final List&lt;String&gt; list) {
<span class="nc" id="L727">		super.buildActions(list);</span>

		/*
		 * Menu is used to provide an alternate action for some entities (like
		 * puppies - and they should not be attackable).
		 * 
		 * For now normally attackable entities get a menu only in Capture The
		 * Flag, and then they don't need attack. If that changes, this code
		 * will need to be adjusted.
		 */
<span class="nc bnc" id="L737" title="All 2 branches missed.">		if (!entity.getRPObject().has(&quot;menu&quot;)) {</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">			if (entity.isAttackedBy(User.get())) {</span>
<span class="nc" id="L739">				list.add(ActionType.STOP_ATTACK.getRepresentation());</span>
			} else {
<span class="nc" id="L741">				list.add(ActionType.ATTACK.getRepresentation());</span>
			}
		}

<span class="nc" id="L745">		list.add(ActionType.PUSH.getRepresentation());</span>
<span class="nc" id="L746">	}</span>

	/**
	 * Draw the entity.
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn entity width.
	 * @param height
	 *            The drawn entity height.
	 */
	@Override
	protected void draw(final Graphics2D g2d, final int x, final int y,
			final int width, final int height) {
<span class="nc" id="L765">		drawCombat(g2d, x, y, width, height);</span>
<span class="nc" id="L766">		super.draw(g2d, x, y, width, height);</span>

		if (Debug.SHOW_ENTITY_VIEW_AREA) {
			g2d.setColor(Color.cyan);
			g2d.drawRect(x, y, width, height);
		}

<span class="nc" id="L773">		drawFloaters(g2d, x, y, width);</span>
<span class="nc" id="L774">	}</span>

	/**
	 * Draw the top layer parts of an entity. This will be on down after all
	 * other game layers are rendered.
	 * 
	 * @param g2d
	 *            The graphics context.
	 * @param x
	 *            The drawn X coordinate.
	 * @param y
	 *            The drawn Y coordinate.
	 * @param width
	 *            The drawn entity width.
	 * @param height
	 *            The drawn entity height.
	 */
	@Override
	protected void drawTop(final Graphics2D g2d, final int x, final int y,
			final int width, final int height) {
<span class="nc" id="L794">		drawStatusBar(g2d, x, y, width);</span>
<span class="nc" id="L795">	}</span>

	/**
	 * Get the height.
	 * 
	 * @return The height (in pixels).
	 */
	@Override
	public int getHeight() {
<span class="nc" id="L804">		return height;</span>
	}

	/**
	 * Get the entity's visibility.
	 * 
	 * @return The visibility value (0-100).
	 */
	@Override
	protected int getVisibility() {
		/*
		 * Hide while in ghostmode.
		 */
<span class="nc bnc" id="L817" title="All 2 branches missed.">		if (entity.isGhostMode()) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">			if (isVisibleGhost()) {</span>
<span class="nc" id="L819">				return super.getVisibility() / 2;</span>
			} else {
<span class="nc" id="L821">				return 0;</span>
			}
		} else {
<span class="nc" id="L824">			return super.getVisibility();</span>
		}
	}

	/**
	 * Get the width.
	 * 
	 * @return The width (in pixels).
	 */
	@Override
	public int getWidth() {
<span class="nc" id="L835">		return width;</span>
	}

	/**
	 * Determines on top of which other entities this entity should be drawn.
	 * Entities with a high Z index will be drawn on top of ones with a lower Z
	 * index.
	 * 
	 * Also, players can only interact with the topmost entity.
	 * 
	 * @return The drawing index.
	 */
	@Override
	public int getZIndex() {
<span class="nc" id="L849">		return 8000;</span>
	}

	@Override
	protected void update() {
<span class="nc" id="L854">		super.update();</span>

<span class="nc bnc" id="L856" title="All 2 branches missed.">		if (titleChanged) {</span>
<span class="nc" id="L857">			titleChanged = false;</span>
<span class="nc" id="L858">			showTitle = entity.showTitle();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">			if (showTitle) {</span>
<span class="nc" id="L860">				titleSprite = createTitleSprite();</span>
			} else {
<span class="nc" id="L862">				titleSprite = null;</span>
			}
		}
		
<span class="nc bnc" id="L866" title="All 2 branches missed.">		if (iconsChanged) {</span>
<span class="nc" id="L867">			iconsChanged = false;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">			for (AbstractStatusIconManager handler : iconManagers) {</span>
<span class="nc" id="L869">				handler.apply();</span>
<span class="nc" id="L870">			}</span>
		}
<span class="nc" id="L872">	}</span>

	@Override
	void entityChanged(final Object property) {
<span class="nc" id="L876">		super.entityChanged(property);</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">		if (property == RPEntity.PROP_ADMIN_LEVEL) {</span>
<span class="nc" id="L879">			titleChanged = true;</span>
<span class="nc" id="L880">			visibilityChanged = true;</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">		} else if (property == RPEntity.PROP_GHOSTMODE) {</span>
<span class="nc" id="L882">			visibilityChanged = true;</span>
<span class="nc bnc" id="L883" title="All 4 branches missed.">		} else if (property == RPEntity.PROP_OUTFIT</span>
				|| property == RPEntity.PROP_ZOMBIE) {
<span class="nc" id="L885">			representationChanged = true;</span>
<span class="nc bnc" id="L886" title="All 4 branches missed.">		} else if (property == IEntity.PROP_TITLE</span>
				|| property == RPEntity.PROP_TITLE_TYPE) {
<span class="nc" id="L888">			titleChanged = true;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">		} else if (property == RPEntity.PROP_TEXT_INDICATORS) {</span>
<span class="nc" id="L890">			onFloatersChanged();</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">		} else if (property == RPEntity.PROP_HP_RATIO) {</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">			if (healthBar != null) {</span>
<span class="nc" id="L893">				healthBar.setHPRatio(entity.getHpRatio());</span>
			}
<span class="nc bnc" id="L895" title="All 2 branches missed.">		} else if (property == RPEntity.PROP_HP_DISPLAY) {</span>
<span class="nc" id="L896">			showHP = entity.showHPBar();</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">		} else if (property == RPEntity.PROP_ATTACK) {</span>
<span class="nc" id="L898">			Nature nature = entity.getShownDamageType();</span>
<span class="nc" id="L899">			String weapon = entity.getShownWeapon();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">			if (nature == null) {</span>
<span class="nc" id="L901">				isAttacking = false;</span>
			} else {
<span class="nc" id="L903">				rangedAttack = entity.isDoingRangedAttack();</span>
<span class="nc bnc" id="L904" title="All 4 branches missed.">				if (attackPainter == null || !attackPainter.hasNatureAndWeapon(nature, weapon)) {</span>
<span class="nc" id="L905">					attackPainter = AttackPainter.get(nature, weapon, (int) Math.min(entity.getWidth(), entity.getHeight()));</span>
				}
<span class="nc" id="L907">				attackPainter.prepare(getState(entity));</span>
<span class="nc" id="L908">				isAttacking = true;</span>
			}
		}
		
<span class="nc" id="L912">		checkIcons(property);</span>
<span class="nc" id="L913">	}</span>

	/**
	 * Called when the floating text indicators change.
	 */
	private void onFloatersChanged() {
<span class="nc" id="L919">		Iterator&lt;TextIndicator&gt; it = entity.getTextIndicators();</span>
<span class="nc" id="L920">		Map&lt;TextIndicator, Sprite&gt; newFloaters = new HashMap&lt;TextIndicator, Sprite&gt;();</span>
		
<span class="nc bnc" id="L922" title="All 2 branches missed.">		while (it.hasNext()) {</span>
<span class="nc" id="L923">			TextIndicator floater = it.next();</span>
<span class="nc" id="L924">			Sprite sprite = floaters.get(floater);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">			if (sprite == null) {</span>
<span class="nc" id="L926">				sprite = TextSprite.createTextSprite(floater.getText(), floater.getType().getColor());</span>
			}
			
<span class="nc" id="L929">			newFloaters.put(floater, sprite);</span>
<span class="nc" id="L930">		}</span>
		
<span class="nc" id="L932">		floaters = newFloaters;</span>
<span class="nc" id="L933">	}</span>

	/**
	 * Perform the default action.
	 */
	@Override
	public void onAction() {
<span class="nc bnc" id="L940" title="All 2 branches missed.">		if (entity.getRPObject().has(&quot;menu&quot;)) {</span>
<span class="nc" id="L941">			onAction(ActionType.USE);</span>
		} else {
<span class="nc" id="L943">			super.onAction();</span>
		}
<span class="nc" id="L945">	}</span>

	/**
	 * Perform an action.
	 * 
	 * @param action
	 *            The action.
	 */
	@Override
	public void onAction(ActionType action) {
<span class="nc" id="L955">		ActionType at = action;</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">		if (at == null) {</span>
<span class="nc" id="L957">			at = ActionType.USE;</span>
		}
<span class="nc bnc" id="L959" title="All 2 branches missed.">		if (isReleased()) {</span>
<span class="nc" id="L960">			return;</span>
		}
		RPAction rpaction;

<span class="nc bnc" id="L964" title="All 3 branches missed.">		switch (at) {</span>
		case ATTACK:
		case PUSH:
		case USE:
<span class="nc" id="L968">			at.send(at.fillTargetInfo(entity));</span>
<span class="nc" id="L969">			break;</span>

		case STOP_ATTACK:
<span class="nc" id="L972">			rpaction = new RPAction();</span>

<span class="nc" id="L974">			rpaction.put(&quot;type&quot;, at.toString());</span>
<span class="nc" id="L975">			rpaction.put(&quot;attack&quot;, &quot;&quot;);</span>

<span class="nc" id="L977">			at.send(rpaction);</span>
<span class="nc" id="L978">			break;</span>

		default:
<span class="nc" id="L981">			super.onAction(at);</span>
			break;
		}
<span class="nc" id="L984">	}</span>
	
	/**
	 * An icon manager whose visibility check is just checking a status of the
	 * entity.
	 */
	private class StatusIconManager extends AbstractStatusIconManager {
		/** The followed status. */
		private final StatusID status;
		
		/**
		 * Create a StatusIconManager.
		 *
 		 * @param property observed property
		 * @param sprite icon sprite
		 * @param xAlign horizontal alignment of the sprite
		 * @param yAlign vertical alignment of the sprite
		 * @param status status corresponding to the visibility of the icon
		 */
		StatusIconManager(Object property, Sprite sprite, HorizontalAlignment xAlign,
<span class="nc" id="L1004">				VerticalAlignment yAlign, StatusID status) {</span>
<span class="nc" id="L1005">			super(property, sprite, xAlign, yAlign);</span>
<span class="nc" id="L1006">			this.status = status;</span>
<span class="nc" id="L1007">		}</span>

		@Override
		boolean show(T entity) {
<span class="nc" id="L1011">			return entity.hasStatus(status);</span>
		}
	}
	
	/**
	 * A manager for a status icon. Observes property changes and shows and
	 * hides the icon as needed.
	 */
	abstract class AbstractStatusIconManager {
		/** Observed property. */
		private final Object property;
		/** Icon sprite. */
		private final Sprite sprite;
		/** Horizontal alignment of the sprite. */
		private final HorizontalAlignment xAlign;
		/** Vertical alignment of the sprite. */
		private final VerticalAlignment yAlign;
		private int xOffset, yOffset;
		/**
		 * For tracking changes that can have multiple &quot;true&quot; values (such
		 * as away messages).
		 */
		private boolean wasVisible;
		/**
		 * Property for telling if the icon should be visible.
		 */
		private boolean shouldBeVisible;
		/**
		 * Flag for detecting that the visibility status has changed.
		 */
		private volatile boolean changed;
		
		/**
		 * Create a new StatusIconManager.
		 * 
		 * @param property observed property
		 * @param sprite icon sprite
		 * @param xAlign Horizontal alignment of the sprite related to the
		 * 	entity view
		 * @param yAlign Vertical alignment of the sprite related to the
		 * 	entity view
		 */
		AbstractStatusIconManager(Object property, Sprite sprite,
<span class="nc" id="L1054">				HorizontalAlignment xAlign, VerticalAlignment yAlign) {</span>
<span class="nc" id="L1055">			this.property = property;</span>
<span class="nc" id="L1056">			this.sprite = sprite;</span>
<span class="nc" id="L1057">			this.xAlign = xAlign;</span>
<span class="nc" id="L1058">			this.yAlign = yAlign;</span>
<span class="nc" id="L1059">		}</span>
		
		/**
		 * Check if the icon should be shown.
		 * 
		 * @param entity checked entity
		 * @return &lt;code&gt;true&lt;/code&gt; if the icon should be shown,
		 * 	&lt;code&gt;false&lt;/code&gt; otherwise
		 */
		abstract boolean show(T entity);
		
		/**
		 * Check the entity at a property change. Show or hide the icon if
		 * needed.
		 * 
		 * @param changedProperty property that changed
		 * @param entity changed entity
		 * @return &lt;code&gt;true&lt;/code&gt; if the visibility status changed, otherwise
		 * 	&lt;code&gt;false&lt;/code&gt;
		 */
		boolean check(Object changedProperty, T entity) {
<span class="nc bnc" id="L1080" title="All 2 branches missed.">			if (property == changedProperty) {</span>
<span class="nc" id="L1081">				return check(entity);</span>
			}
			
<span class="nc" id="L1084">			return false;</span>
		}
		
		/**
		 * Apply visibility changes if needed.
		 */
		void apply() {
<span class="nc bnc" id="L1091" title="All 2 branches missed.">			if (changed) {</span>
<span class="nc" id="L1092">				changed = false;</span>
<span class="nc" id="L1093">				setVisible(shouldBeVisible);</span>
			}
<span class="nc" id="L1095">		}</span>
		
		/**
		 * Set the icon offsets compared to the normal position determined by
		 * the alignment. &lt;b&gt;The horizontal offset will be ignored, unless
		 * the icon is center aligned.&lt;/b&gt;
		 * @param xOffset
		 * @param yOffset
		 */
		void setOffsets(int xOffset, int yOffset) {
<span class="nc" id="L1105">			this.xOffset = xOffset;</span>
<span class="nc" id="L1106">			this.yOffset = yOffset;</span>
<span class="nc" id="L1107">		}</span>
		
		/**
		 * Check the status of an entity, and show or hide the icon if
		 * needed.
		 * 
		 * @param entity checked entity
		 * @return &lt;code&gt;true&lt;/code&gt; if the visibility status changed, otherwise
		 * 	&lt;code&gt;false&lt;/code&gt;
		 */
		private boolean check(T entity) {
<span class="nc" id="L1118">			boolean old = shouldBeVisible;</span>
<span class="nc" id="L1119">			shouldBeVisible = show(entity);</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">			boolean tmp = old != shouldBeVisible;</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">			if (tmp) {</span>
<span class="nc" id="L1122">				changed = true;</span>
			}
			
<span class="nc" id="L1125">			return tmp;</span>
		}
		
		/**
		 * Find the correct location for the icon when it has been set visible.
		 */
		private void position() {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">			if (xAlign == HorizontalAlignment.CENTER) {</span>
<span class="nc" id="L1133">				return;</span>
			}
<span class="nc" id="L1135">			xOffset = 0;</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">			for (int i = 0; i &lt; iconManagers.size(); i++) {</span>
<span class="nc" id="L1137">				AbstractStatusIconManager manager = iconManagers.get(i);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">				if (manager != this) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">					if (sharesPosition(manager)) {</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">						if (xAlign == HorizontalAlignment.LEFT) {</span>
<span class="nc" id="L1141">							xOffset += manager.sprite.getWidth();</span>
						} else {
<span class="nc" id="L1143">							xOffset -= manager.sprite.getWidth();</span>
						}
					}
				} else {
					// Reposition any icons in the same position after this
<span class="nc" id="L1148">					reposition(i + 1);</span>
<span class="nc" id="L1149">					break;</span>
				}
			}
<span class="nc" id="L1152">		}</span>

		/**
		 * Reposition any visible icons following this when the visibility has
		 * changed.
		 * 
		 * @param startIndex the position of this manager in the iconManagers
		 * 	list 
		 */
		private void reposition(int startIndex) {
<span class="nc bnc" id="L1162" title="All 2 branches missed.">			for (int j = startIndex; j &lt; iconManagers.size(); j++) {</span>
<span class="nc" id="L1163">				AbstractStatusIconManager follower = iconManagers.get(j);</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">				if (sharesPosition(follower)) {</span>
<span class="nc" id="L1165">					follower.setVisible(false);</span>
<span class="nc" id="L1166">					follower.position();</span>
<span class="nc" id="L1167">					follower.setVisible(true);</span>
					// position() above will trigger repositioning of
					// any icons after follower, so avoid processing any
					// further.
<span class="nc" id="L1171">					break;</span>
				}
			}
<span class="nc" id="L1174">		}</span>
		
		/**
		 * Check if a manager shares position with this, and is in visible
		 * state.
		 * 
		 * @param manager manager to be checked
		 * @return &lt;code&gt;true&lt;/code&gt; if the manages shares alignment properties
		 * with this, and its icon is visible.
		 */
		private boolean sharesPosition(AbstractStatusIconManager manager) {
<span class="nc bnc" id="L1185" title="All 6 branches missed.">			return manager.xAlign == xAlign &amp;&amp; manager.yAlign == yAlign</span>
					&amp;&amp; manager.shouldBeVisible;
		}
		
		/**
		 * Attach or detach the icon sprite, depending on visibility.
		 * 
		 * @param visible new visibility status
		 */
		private void setVisible(boolean visible) {
<span class="nc bnc" id="L1195" title="All 2 branches missed.">			if (visible) {</span>
				// Avoid attaching the sprite more than once
<span class="nc bnc" id="L1197" title="All 2 branches missed.">				if (!wasVisible) {</span>
<span class="nc" id="L1198">					position();</span>
<span class="nc" id="L1199">					attachSprite(sprite, xAlign, yAlign, xOffset, yOffset);</span>
<span class="nc" id="L1200">					wasVisible = true;</span>
				}
			} else {
<span class="nc" id="L1203">				wasVisible = false;</span>
<span class="nc" id="L1204">				detachSprite(sprite);</span>
<span class="nc" id="L1205">				reposition(iconManagers.indexOf(this) + 1);</span>
			}
<span class="nc" id="L1207">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>