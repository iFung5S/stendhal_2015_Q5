<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Expression.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.common.parser</a> &gt; <span class="el_source">Expression.java</span></div><h1>Expression.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.common.parser;

import games.stendhal.common.ErrorDrain;

import java.util.regex.Pattern;

/**
 * An Expression is part of a Sentence. It encapsulates the original, white space trimmed text, the
 * expression type, a normalized lower case text string and the integer amount.
 *
 * @author Martin Fuchs
 */
public final class Expression {
	/** Instance of an empty Expression. */
<span class="fc" id="L27">    public static final Expression EMPTY_EXPRESSION = new Expression(&quot;&quot;, &quot;&quot;);</span>

    /** JOKER is a joker String used in pattern matches. */
    public static final String JOKER = &quot;*&quot;;

    /** Original, un-normalized string expression. */
    private String original;

    /** Expression type. */
    private ExpressionType type;

    /** Normalized string representation of this Expression. */
<span class="fc" id="L39">    private String normalized = &quot;&quot;;</span>

    /** Main word of the Expression. */
    private String mainWord;

    /** Number of items. */
    private Integer amount;

    /** Break flag to define sentence part borders. */
<span class="fc" id="L48">    private boolean breakFlag = false;</span>

    /** Expression matcher for comparing expressions in various modes. */
<span class="fc" id="L51">    private ExpressionMatcher matcher = null;</span>
  

    /**
     * Create an Expression from the given original string. Normalized form, main word and type are
     * not yet defined.
     *
     * @param str
     */
<span class="fc" id="L60">    /*protected*/ Expression(final String str) {</span>
<span class="fc" id="L61">        original = str;</span>
<span class="fc" id="L62">    }</span>

    /**
     * Create an Expression from a single word and a type string.
     *
     * @param word
     * @param typeString
     */
<span class="fc" id="L70">    public Expression(final String word, final String typeString) {</span>
<span class="fc" id="L71">        original = word;</span>
<span class="fc" id="L72">        normalized = word;</span>
<span class="fc" id="L73">        mainWord = word;</span>
<span class="fc" id="L74">        type = new ExpressionType(typeString);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Parse the given numeric expression and assign the value to 'amount'.
     *  TODO mf - We may switch from Integer to Long
     * if we extend the column type in table 'words'
     *
     * @param str
     * @param errors 
     */
    public void parseAmount(final String str, final ErrorDrain errors) {
        try {
            // replace commas by dots to recognize numbers like &quot;1,5&quot;
<span class="fc" id="L88">            final String numberString = str.replace(',', '.');</span>

            // Parse as float number, then round to the next integer.
<span class="fc" id="L91">            setAmount((int) Math.round(Double.parseDouble(numberString)));</span>

<span class="fc" id="L93">            setType(new ExpressionType(ExpressionType.NUMERAL));</span>
<span class="fc" id="L94">            normalized = amount.toString();</span>
<span class="fc" id="L95">        } catch (final NumberFormatException e) {</span>
<span class="fc" id="L96">            errors.setError(&quot;illegal number format: '&quot; + str + &quot;'&quot;);</span>
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">    }</span>

    /**
     * Merge the given preceding Expression into this Expression while leaving
     * mainWord unchanged.The members normalized and original are only touched
     * when negating the expression.
     *
     * @param other
     */
    public void mergeSimple(final Expression other) {
<span class="fc" id="L108">        mergeType(other.getType());</span>
<span class="fc" id="L109">        setAmount(mergeAmount(other.amount, amount));</span>
<span class="fc" id="L110">    }</span>

    /**
     * Merge the given preceding Expression into this Expression, while leaving mainWord unchanged.
     *
     * @param prec
     * @param mergeNormalized
     */
    public void mergeLeft(final Expression prec, final boolean mergeNormalized) {
<span class="fc" id="L119">        original = prec.getOriginal() + ' ' + original;</span>

<span class="fc bfc" id="L121" title="All 4 branches covered.">        if (mergeNormalized) {</span>
<span class="fc" id="L122">            normalized = prec.getNormalized() + ' ' + normalized;</span>
        }

<span class="fc" id="L125">        mergeType(prec.getType());</span>
<span class="fc" id="L126">        setAmount(mergeAmount(prec.amount, amount));</span>
<span class="fc" id="L127">    }</span>

    /**
     * Merge the given following Expression into this Expression, while leaving mainWord unchanged.
     *
     * @param other
     * @param mergeNormalized
     */
    public void mergeRight(final Expression other, final boolean mergeNormalized) {
<span class="fc" id="L136">        original = original + ' ' + other.getOriginal();</span>

<span class="fc bfc" id="L138" title="All 4 branches covered.">        if (mergeNormalized) {</span>
<span class="fc" id="L139">            normalized = normalized + ' ' + other.getNormalized();</span>
        }

<span class="fc" id="L142">        mergeType(other.getType());</span>
<span class="fc" id="L143">        setAmount(mergeAmount(amount, other.amount));</span>
<span class="fc" id="L144">        breakFlag = other.getBreakFlag();</span>
<span class="fc" id="L145">    }</span>

    /**
     * Merge two amounts into one number.
     *
     * @param left
     * @param right
     * @return combined number
     */
    private static Integer mergeAmount(final Integer left, final Integer right) {
<span class="fc bfc" id="L155" title="All 4 branches covered.">        if (left != null) {</span>
<span class="fc bfc" id="L156" title="All 4 branches covered.">            if (right != null) {</span>
<span class="fc bfc" id="L157" title="All 4 branches covered.">                if (left &lt;= right) {</span>
                	// e.g. five hundred
<span class="fc" id="L159">                    return left * right; </span>
                } else {
                	// e.g. hundred fifty
<span class="fc" id="L162">                    return left + right; </span>
                }
            } else {
<span class="fc" id="L165">                return left;</span>
            }
        } else {
<span class="fc" id="L168">            return right;</span>
        }
    }

    /**
     * Merge the given following name component into this Expression.
     *
     * @param next
     * @param newType 
     */
    public void mergeName(final Expression next, ExpressionType newType) {
<span class="fc" id="L179">        original = original + ' ' + next.getOriginal();</span>

<span class="fc bfc" id="L181" title="All 4 branches covered.">        if (newType.isName()) {</span>
<span class="fc" id="L182">        	setNormalized(original.toLowerCase());</span>
        } else {
<span class="fc" id="L184">        	setNormalized(normalized + ' ' + next.getNormalized());</span>
        }

<span class="fc" id="L187">        setType(newType);</span>
<span class="fc" id="L188">        setAmount(mergeAmount(amount, next.amount));</span>
<span class="fc" id="L189">        breakFlag = next.getBreakFlag();</span>
<span class="fc" id="L190">    }</span>

    /**
     * Set item count.
     *
     * @param amount
     */
    public void setAmount(final Integer amount) {
<span class="fc" id="L198">        this.amount = amount;</span>
<span class="fc" id="L199">    }</span>

    /**
     * @return amount as integer value, default to 1.
     */
    public int getAmount() {
<span class="fc bfc" id="L205" title="All 4 branches covered.">		if (amount == null) {</span>
<span class="fc" id="L206">			return 1;</span>
		} else {
<span class="fc" id="L208">			return amount.intValue();</span>
		}
	}

    /**
     * @return true if there is an explicit amount.
     */
    public boolean hasAmount() {
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">		return amount != null;</span>
	}

	/**
	 * @return amount as long integer value, default to 1.
	 */
	public long getAmountLong() {
<span class="fc bfc" id="L223" title="All 4 branches covered.">		if (amount == null) {</span>
<span class="fc" id="L224">			return 1;</span>
		} else {
<span class="fc" id="L226">			return amount;</span>
		}
	}

    /**
	 * Set the break flag to define sentence part borders.
	 */
    public void setBreakFlag() {
<span class="fc" id="L234">        breakFlag = true;</span>
<span class="fc" id="L235">    }</span>

    /**
     * Set Expression matcher.
     *
     * @param matcher
     */
    public void setMatcher(final ExpressionMatcher matcher) {
<span class="fc" id="L243">        this.matcher = matcher;</span>
<span class="fc" id="L244">    }</span>

    /**
     * Return matcher used for matching this expression.
     *
     * @return matcher
     */
    public ExpressionMatcher getMatcher() {
<span class="fc" id="L252">        return matcher;</span>
    }

    /**
     *
     * @return the original, un-normalized string expression.
     */
    public String getOriginal() {
<span class="fc" id="L260">        return original;</span>
    }

    /**
     * Set the normalized form of the expression.
     *
     * @param normalized
     */
    public void setNormalized(final String normalized) {
<span class="fc" id="L269">        this.normalized = normalized;</span>
<span class="fc" id="L270">        this.mainWord = normalized;</span>
<span class="fc" id="L271">    }</span>

    /**
     * Return the normalized form of the Expression.
     * @return normalized form
     */
    public String getNormalized() {
<span class="fc" id="L278">        return normalized;</span>
    }

    /**
     * @return the main word of the expression.
     */
    public String getMainWord() {
<span class="fc bfc" id="L285" title="All 4 branches covered.">    	if (mainWord == null) {</span>
<span class="fc" id="L286">    		return &quot;&quot;;</span>
    	} else {
<span class="fc" id="L288">    		return mainWord;</span>
    	}
    }

    /**
     * @return the break flag to check for sentence part borders.
     */
    public boolean getBreakFlag() {
<span class="fc" id="L296">        return breakFlag;</span>
    }

    /**
     * Set Expression type.
     *
     * @param type
     */
    public void setType(final ExpressionType type) {
<span class="fc" id="L305">        this.type = type;</span>
<span class="fc" id="L306">    }</span>

    /**
     *
     * @return  Expression type.
     */
    public ExpressionType getType() {
<span class="fc" id="L313">        return type;</span>
    }

    /**
     *
     * @return string representation of Expression type 
     */
    public String getTypeString() {
<span class="fc bfc" id="L321" title="All 4 branches covered.">		if (type == null) {</span>
<span class="fc" id="L322">			return &quot;&quot;;</span>
		} else {
<span class="fc" id="L324">			return type.getTypeString();</span>
		}
	}

    /**
	 * Determine if the Expression consists of verbs.
	 * 
	 * @return false if not a verb or null, true otherwise
	 */
    public boolean isVerb() {
<span class="pc bpc" id="L334" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isVerb();</span>
    }

    /**
     * Determine if the Expression is an object. (a thing, not a person)
     *
     * @return false if not an object or null, true otherwise
     */
    public boolean isObject() {
<span class="pc bpc" id="L343" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isObject();</span>
    }

    /**
     * Determine if the Expression represents a person.
     *
     * @return false if not a subject or null, true otherwise
     */
    public boolean isSubject() {
<span class="pc bpc" id="L352" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isSubject();</span>
    }

    /**
     * Determine if the Expression is negated.
     *
     * @return false if not negated or null, true otherwise
     */
    public boolean isNegated() {
<span class="pc bpc" id="L361" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isNegated();</span>
    }

    /**
     * Determine Expressions to ignore.
     *
     * @return false if not ignored or null, true otherwise
     */
    public boolean isIgnore() {
<span class="fc bfc" id="L370" title="All 8 branches covered.">        return (type != null) &amp;&amp; type.isIgnore();</span>
    }

    /**
     * Determine if the Expression consists of question words.
     *
     * @return false if not a question or null, true otherwise
     */
    public boolean isQuestion() {
<span class="pc bpc" id="L379" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isQuestion();</span>
    }

    /**
     * Determine if the Expression consists of prepositions.
     *
     * @return false if not a preposition or null, true otherwise
     */
    public boolean isPreposition() {
<span class="pc bpc" id="L388" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isPreposition();</span>
    }

    /**
     * Determine if the Expression consists of numeral words.
     *
     * @return false if not a numeral or null, true otherwise
     */
    public boolean isNumeral() {
<span class="pc bpc" id="L397" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isNumeral();</span>
    }

    /**
     * Determine if the Expression contains a dynamically defined word.
     *
     * @return true dynamically created
     */
	public boolean isDynamic() {
<span class="pc bpc" id="L406" title="2 of 8 branches missed.">        return (type != null) &amp;&amp; type.isDynamic();</span>
	}

    /**
     * Merge Expression type with another one while handling null values.
     *
     * @param otherType
     */
    public void mergeType(final ExpressionType otherType) {
<span class="pc bpc" id="L415" title="2 of 4 branches missed.">        if (type != null) {</span>
<span class="pc bpc" id="L416" title="2 of 4 branches missed.">            if (otherType != null) {</span>
<span class="fc" id="L417">                type = type.merge(otherType);</span>

<span class="fc bfc" id="L419" title="All 4 branches covered.">                if (otherType.isNegated()) {</span>
<span class="fc" id="L420">                	negateStrings();</span>
                }
            }
        } else {
<span class="nc" id="L424">            type = otherType;</span>
        }
<span class="fc" id="L426">    }</span>

    /**
     * Return the normalized Expression with type. 
     *
     * @return string in the format NORMALIZED/TYPE.
     */
    public String getNormalizedWithTypeString() {
<span class="fc" id="L434">        return normalized + &quot;/&quot; + getTypeString();</span>
    }

    /**
     * Check if two Expressions match exactly.
     *
     * @param other
     *            Expression
     * @return true if two expression match, false otherwise
     */
    public boolean matches(final Expression other) {
<span class="pc bpc" id="L445" title="2 of 4 branches missed.">        if (other != null) {</span>
            // If there is no override by an ExpressionMatcher in 'other', use the
            // default rule and compare the original strings.
<span class="fc bfc" id="L448" title="All 4 branches covered.">            if (other.matcher == null) {</span>
<span class="fc bfc" id="L449" title="All 4 branches covered.">                if (original.equals(other.original)) {</span>
<span class="fc" id="L450">                    return true;</span>
                }
            } else {
                // If both Expressions contain a matcher object, first compare this.
<span class="fc bfc" id="L454" title="All 4 branches covered.">                if (matcher != null) {</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">                    if (!matcher.equals(other.matcher)) {</span>
<span class="fc" id="L456">                        return false;</span>
                    }
                }

                // Now call the matcher to look if the Expression matches the defined rule.
<span class="fc" id="L461">                return other.matcher.match(this, other);</span>
            }
        }

<span class="fc" id="L465">        return false;</span>
    }

    /**
     * Check if two Expressions match each other.
     *
     * @param other
     *            Expression
     * @return true if two expression match, false otherwise
     */
    public boolean matchesNormalized(final Expression other) {
<span class="pc bpc" id="L476" title="2 of 4 branches missed.">        if (other != null) {</span>
            // If there is no override by an ExpressionMatcher in 'other', use the
            // default rule and compare the normalised strings.
<span class="fc bfc" id="L479" title="All 4 branches covered.">            if (other.matcher == null) {</span>
<span class="fc bfc" id="L480" title="All 4 branches covered.">                if (getNormalized().equals(other.getNormalized())) {</span>
<span class="fc" id="L481">                    return true;</span>
                }
            } else {
                // If both Expressions contain a matcher object, first compare this.
<span class="pc bpc" id="L485" title="2 of 4 branches missed.">                if (matcher != null) {</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">                    if (!matcher.equals(other.matcher)) {</span>
<span class="nc" id="L487">                        return false;</span>
                    }
                }

<span class="fc" id="L491">                return other.matcher.match(this, other);</span>
            }
        }

<span class="fc" id="L495">        return false;</span>
    }

    /**
     * Check if the Expression is similar to another Expression.
     *
     * @param other
     *            Expression
     * @return true if two expression match, false otherwise
     */
    public boolean matchesNormalizedSimilar(final Expression other) {
<span class="pc bpc" id="L506" title="2 of 4 branches missed.">        if (other != null) {</span>
            // If there is no override by an ExpressionMatcher in 'other', use the
            // default rule and compare the normalised strings and main words.
<span class="fc bfc" id="L509" title="All 4 branches covered.">            if (other.matcher == null) {</span>
<span class="fc bfc" id="L510" title="All 4 branches covered.">                if (SimilarExprMatcher.isSimilar(getNormalized(), other.getNormalized(), 0.1)) {</span>
<span class="fc" id="L511">                    return true;</span>
<span class="fc bfc" id="L512" title="All 4 branches covered.">                } else if (SimilarExprMatcher.isSimilar(getMainWord(), other.getMainWord(), 0.1)) {</span>
<span class="fc" id="L513">                    return true;</span>
                }
            }

            // We don't use ExpressionMatcher here when searching only for matches at the Expression start.
        }

<span class="fc" id="L520">        return false;</span>
    }

    /**
	 * Check if the Expression matches the given matching Expression.
	 * 
	 * &lt;p&gt;
	 * The matching object can contain explicit expressions, which are compared
	 * after normalizing, or ExpressionType specifiers like &quot;VER&quot; or &quot;SUB*&quot; in
	 * upper case. This defines the joker matching algorithm for sentence
	 * matching, which chooses automatically between word and type matching,
	 * depending on which of word and word type string is given.
	 * 
	 * @param other
	 * @return true if this expression matches the other, false otherwise
	 */
    boolean sentenceMatchExpression(final Expression other) {
<span class="fc" id="L537">        final String matchString = other.getNormalized();</span>

<span class="fc bfc" id="L539" title="All 4 branches covered.">        if (matchString.contains(JOKER)) {</span>
<span class="fc bfc" id="L540" title="All 4 branches covered.">            if (matchString.equals(JOKER)) {</span>
                // Type string matching is identified by a single &quot;*&quot; as normalized string expression.
<span class="fc bfc" id="L542" title="All 4 branches covered.">                if (!matchesJokerString(getTypeString(), other.getTypeString())) {</span>
<span class="fc" id="L543">                    return false;</span>
                }
            } else {
                // Look for a normalized string match against the string containing a joker character.
<span class="fc bfc" id="L547" title="All 4 branches covered.">                if (!matchesJokerString(getNormalized(), matchString)) {</span>
<span class="fc" id="L548">                    return false;</span>
                }
            }
<span class="pc bpc" id="L551" title="2 of 4 branches missed.">        } else if (other.getMatcher() != null) {</span>
            // avoid endless recursion
<span class="nc" id="L553">            return original.equals(other.original);</span>
<span class="fc bfc" id="L554" title="All 4 branches covered.">        } else if (!matchesNormalized(other)) {</span>
<span class="fc" id="L555">            return false;</span>
        }

<span class="fc" id="L558">        return true;</span>
    }

    /**
     * Match the given String against a pattern String containing JOKER characters.
     *
     * @param str
     * @param matchString
     * @return true if two expression match, false otherwise
     */
    public static boolean matchesJokerString(final String str, final String matchString) {
<span class="pc bpc" id="L569" title="2 of 4 branches missed.">        if (str.equals(JOKER)) {</span>
            // Empty strings do not match the &quot;*&quot; joker.
<span class="nc bnc" id="L571" title="All 4 branches missed.">            return str.length() &gt; 0;</span>
        } else {
            // Convert the joker string into a regular expression and let the Pattern class do the work.
<span class="fc" id="L574">            return Pattern.compile(matchString.replace(JOKER, &quot;.*&quot;)).matcher(str).find();</span>
        }
    }

	/**
	 * Negate the expression.
	 * This is used in SentenceImplementation to normalize sentences containing &quot;don't&quot; expressions.
	 */
	public void negate() {
<span class="fc" id="L583">		type = getType().negate();</span>

<span class="fc" id="L585">		negateStrings();</span>
<span class="fc" id="L586">	}</span>

	/**
	 * Negate original and normalized string, while leaving
	 * type untouched.
	 */
	private void negateStrings() {
<span class="fc bfc" id="L593" title="All 4 branches covered.">		if (type.isNegated()) {</span>
<span class="fc" id="L594">			original = original + &quot; not&quot;;</span>
<span class="fc" id="L595">			normalized = normalized + &quot; not&quot;;</span>
		} else {
<span class="fc" id="L597">			original = original.replaceFirst(&quot; not&quot;, &quot;&quot;);</span>
<span class="fc" id="L598">			normalized = normalized.replaceFirst(&quot; not&quot;, &quot;&quot;);</span>
		}
<span class="fc" id="L600">	}</span>

    /**
     * Check for equality of two Expression objects.
     */
    @Override
    public boolean equals(final Object other) {
<span class="fc bfc" id="L607" title="All 4 branches covered.">        if (other == this) {</span>
<span class="fc" id="L608">            return true;</span>
<span class="fc bfc" id="L609" title="All 4 branches covered.">        } else if (other == null) {</span>
<span class="fc" id="L610">            return false;</span>
<span class="fc bfc" id="L611" title="All 4 branches covered.">        } else if (other.getClass() == Expression.class) {</span>
<span class="fc" id="L612">            final Expression o = (Expression) other;</span>

<span class="pc bpc" id="L614" title="2 of 4 branches missed.">            if (matcher != null) {</span>
<span class="nc bnc" id="L615" title="All 8 branches missed.">                if ((o.matcher == null) || !matcher.equals(o.matcher)) {</span>
<span class="nc" id="L616">                    return false;</span>
                }
            } else {
<span class="pc bpc" id="L619" title="2 of 4 branches missed.">                if (o.matcher != null) {</span>
<span class="nc" id="L620">                    return false;</span>
                }
            }

<span class="fc bfc" id="L624" title="All 4 branches covered.">            if (normalized.length() &gt; 0) {</span>
<span class="fc" id="L625">                return normalized.equals(o.normalized);</span>
            } else {
<span class="fc" id="L627">                return original.equals(o.original);</span>
            }
        } else {
<span class="fc" id="L630">            return false;</span>
        }
    }

    /**
     * Returns a hash code for this Expression object.
     */
    @Override
    public int hashCode() {
        int hash;

<span class="nc bnc" id="L641" title="All 4 branches missed.">        if (normalized.length() &gt; 0) {</span>
<span class="nc" id="L642">            hash = normalized.hashCode();</span>
        } else {
<span class="nc" id="L644">            hash = original.hashCode();</span>
        }

<span class="nc bnc" id="L647" title="All 4 branches missed.">        if (matcher != null) {</span>
<span class="nc" id="L648">            hash ^= matcher.hashCode();</span>
        }

<span class="nc" id="L651">        return hash;</span>
    }

    /**
     * Return a simple string representation of the Expression.
     */
    @Override
    public String toString() {
<span class="fc" id="L659">        final StringBuilder b = new StringBuilder();</span>

<span class="fc bfc" id="L661" title="All 4 branches covered.">        if (matcher != null) {</span>
<span class="fc" id="L662">            b.append(matcher.toString());</span>
<span class="fc" id="L663">            b.append(ExpressionMatcher.PM_SEPARATOR);</span>
        }

<span class="fc bfc" id="L666" title="All 4 branches covered.">        if (normalized.length() &gt; 0) {</span>
<span class="fc" id="L667">            b.append(normalized);</span>
        } else {
<span class="fc" id="L669">            b.append(original);</span>
        }

<span class="fc" id="L672">        return b.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>