<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Creature.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity.creature</a> &gt; <span class="el_source">Creature.java</span></div><h1>Creature.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2012 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.entity.creature;

import games.stendhal.common.Level;
import games.stendhal.common.Rand;
import games.stendhal.common.constants.Nature;
import games.stendhal.common.constants.SoundLayer;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.StendhalRPRuleProcessor;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.core.pathfinder.FixedPath;
import games.stendhal.server.core.pathfinder.Node;
import games.stendhal.server.core.pathfinder.Path;
import games.stendhal.server.core.rule.EntityManager;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.Killer;
import games.stendhal.server.entity.RPEntity;
import games.stendhal.server.entity.Registrator;
import games.stendhal.server.entity.creature.impl.DropItem;
import games.stendhal.server.entity.creature.impl.EquipItem;
import games.stendhal.server.entity.creature.impl.attack.AttackStrategy;
import games.stendhal.server.entity.creature.impl.attack.AttackStrategyFactory;
import games.stendhal.server.entity.creature.impl.heal.HealerBehavior;
import games.stendhal.server.entity.creature.impl.heal.HealerBehaviourFactory;
import games.stendhal.server.entity.creature.impl.idle.IdleBehaviour;
import games.stendhal.server.entity.creature.impl.idle.IdleBehaviourFactory;
import games.stendhal.server.entity.item.Corpse;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.item.StackableItem;
import games.stendhal.server.entity.mapstuff.spawner.CreatureRespawnPoint;
import games.stendhal.server.entity.npc.NPC;
import games.stendhal.server.entity.player.Player;
import games.stendhal.server.entity.slot.EntitySlot;
import games.stendhal.server.entity.status.PoisonAttackerFactory;
import games.stendhal.server.entity.status.StatusAttacker;
import games.stendhal.server.entity.status.StatusAttackerFactory;
import games.stendhal.server.events.SoundEvent;
import games.stendhal.server.util.CounterMap;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Observer;

import marauroa.common.game.Definition;
import marauroa.common.game.Definition.Type;
import marauroa.common.game.RPClass;
import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;
import marauroa.common.game.SyntaxException;

import org.apache.log4j.Logger;

/**
 * Server-side representation of a creature.
 * &lt;p&gt;
 * A creature is defined as an entity which can move with certain speed, has
 * life points (HP) and can die.
 * &lt;p&gt;
 * Not all creatures have to be hostile, but at the moment the default behavior
 * is to attack the player.
 *
 */
public class Creature extends NPC {
	/** the logger instance. */
<span class="fc" id="L81">	private static final Logger LOGGER = Logger.getLogger(Creature.class);</span>

	/**
	 * The higher the number the less items are dropped. To use numbers
	 * determined at creatures.xml, just make it 1.
	 */
	private static final double SERVER_DROP_GENEROSITY = 1;

<span class="fc" id="L89">	private HealerBehavior healer = HealerBehaviourFactory.get(null);</span>

	private AttackStrategy strategy;


	/**
	 * This list of item names this creature may drop Note; per default this list
	 * is shared with all creatures of that class.
	 */
	protected List&lt;DropItem&gt; dropsItems;

	/**
	 * This list of item instances this creature may drop for use in quests. This
	 * is always creature specific.
	 */
	protected List&lt;Item&gt; dropItemInstances;

	/** Sound played on death */
	private String deathSound;

	// A looped sound to be played while creature is moving
	private String movementSound;
	private SoundEvent movementSoundEvent;

	/**
	 * List of things this creature should say.
	 */
	protected LinkedHashMap&lt;String, LinkedList&lt;String&gt;&gt; noises;

	boolean isRespawned;

	private String corpseName;
	private String harmlessCorpseName;
<span class="fc" id="L122">	private int corpseWidth = 1;</span>
<span class="fc" id="L123">	private int corpseHeight = 1;</span>

	private CreatureRespawnPoint point;

	/** Respawn time in turns */
	private int respawnTime;

	private Map&lt;String, String&gt; aiProfiles;
	private IdleBehaviour idler;

	private int targetX;

	private int targetY;

<span class="fc" id="L137">	private final int attackTurn = Rand.rand(5);</span>

	private boolean isIdle;

	/** The type of the damage this creature does */
<span class="fc" id="L142">	private Nature damageType = Nature.CUT;</span>
	/** The type of the damage this creature does in ranged attacks */
<span class="fc" id="L144">	private Nature rangedDamageType = Nature.CUT;</span>

	/** Susceptibilities to various damage types this creature has */
	private Map&lt;Nature, Double&gt; susceptibilities;

	private CircumstancesOfDeath circumstances;
<span class="fc" id="L150">	private final Registrator registrator = new Registrator();</span>

	private CounterMap&lt;String&gt; hitPlayers;

	/**
	 * creates a new Creature
	 *
	 * @param object serialized creature
	 */
	public Creature(final RPObject object) {
<span class="fc" id="L160">		super(object);</span>

<span class="fc" id="L162">		setRPClass(&quot;creature&quot;);</span>
<span class="fc" id="L163">		put(&quot;type&quot;, &quot;creature&quot;);</span>
<span class="fc" id="L164">		put(&quot;title_type&quot;, &quot;enemy&quot;);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (object.has(&quot;title_type&quot;)) {</span>
<span class="fc" id="L166">			put(&quot;title_type&quot;, object.get(&quot;title_type&quot;));</span>
		}

<span class="fc" id="L169">		dropsItems = new ArrayList&lt;DropItem&gt;();</span>
<span class="fc" id="L170">		dropItemInstances = new ArrayList&lt;Item&gt;();</span>
<span class="fc" id="L171">		setAIProfiles(new HashMap&lt;String, String&gt;());</span>

<span class="fc" id="L173">		susceptibilities = new EnumMap&lt;Nature, Double&gt;(Nature.class);</span>

		// set the default movement range
<span class="fc" id="L176">		setMovementRange(20);</span>

<span class="fc" id="L178">		updateModifiedAttributes();</span>
<span class="fc" id="L179">	}</span>

	/**
	 * creates a new Creature
	 *
	 * @param copy template to copy
	 */
	public Creature(final Creature copy) {
<span class="fc" id="L187">		this();</span>

<span class="fc" id="L189">		this.baseSpeed = copy.baseSpeed;</span>
<span class="fc" id="L190">		setSize((int) copy.getWidth(), (int) copy.getHeight());</span>

<span class="fc" id="L192">		setCorpse(copy.getCorpseName(), copy.getHarmlessCorpseName(), copy.getCorpseWidth(), copy.getCorpseHeight());</span>
<span class="fc" id="L193">		setBlood(copy.getBloodClass());</span>

		/**
		 * Creatures created with this function will share their dropsItems with
		 * any other creature of that kind. If you want individual dropsItems,
		 * use clearDropItemList first!
		 */
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">		if (copy.dropsItems != null) {</span>
<span class="fc" id="L201">			this.dropsItems = copy.dropsItems;</span>
		}
		// this.dropItemInstances is ignored;

<span class="fc" id="L205">		this.setAIProfiles(copy.getAIProfiles(), false);</span>
<span class="fc" id="L206">		this.statusAttackers = copy.statusAttackers;</span>
<span class="fc" id="L207">		this.noises = copy.noises;</span>

<span class="fc" id="L209">		this.respawnTime = copy.respawnTime;</span>
<span class="fc" id="L210">		susceptibilities = copy.susceptibilities;</span>
<span class="fc" id="L211">		setDamageTypes(copy.damageType, copy.rangedDamageType);</span>

<span class="fc" id="L213">		setEntityClass(copy.get(&quot;class&quot;));</span>
<span class="fc" id="L214">		setEntitySubclass(copy.get(&quot;subclass&quot;));</span>

<span class="fc" id="L216">		setDescription(copy.getDescription());</span>
<span class="fc" id="L217">		setAtk(copy.getAtk());</span>
<span class="fc" id="L218">		setDef(copy.getDef());</span>
<span class="fc" id="L219">		setXP(copy.getXP());</span>
<span class="fc" id="L220">		initHP(copy.getBaseHP());</span>
<span class="fc" id="L221">		setName(copy.getName());</span>

<span class="fc" id="L223">		setLevel(copy.getLevel());</span>
<span class="fc" id="L224">		setSounds(copy.getSounds());</span>
<span class="fc" id="L225">		setDeathSound(copy.deathSound);</span>
<span class="fc" id="L226">		setMovementSound(copy.movementSound);</span>

<span class="fc bfc" id="L228" title="All 2 branches covered.">		for (RPSlot slot : copy.slots()) {</span>
<span class="fc" id="L229">			this.addSlot((RPSlot) slot.clone());</span>
<span class="fc" id="L230">		}</span>

<span class="fc" id="L232">		update();</span>
<span class="fc" id="L233">		updateModifiedAttributes();</span>
<span class="fc" id="L234">		stop();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">		if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L236">			LOGGER.debug(getID() + &quot; Created &quot; + get(&quot;class&quot;) + &quot;:&quot;</span>
					+ this);
		}
<span class="fc" id="L239">	}</span>


	/**
	 * creates a new creature without properties. These must be set in the
	 * deriving class
	 */
	public Creature() {
<span class="fc" id="L247">		super();</span>
<span class="fc" id="L248">		setRPClass(&quot;creature&quot;);</span>
<span class="fc" id="L249">		put(&quot;type&quot;, &quot;creature&quot;);</span>
<span class="fc" id="L250">		put(&quot;title_type&quot;, &quot;enemy&quot;);</span>
<span class="fc" id="L251">		dropsItems = new ArrayList&lt;DropItem&gt;();</span>
<span class="fc" id="L252">		dropItemInstances = new ArrayList&lt;Item&gt;();</span>
<span class="fc" id="L253">		setAIProfiles(new HashMap&lt;String, String&gt;());</span>

<span class="fc" id="L255">		susceptibilities = new EnumMap&lt;Nature, Double&gt;(Nature.class);</span>
<span class="fc" id="L256">		updateModifiedAttributes();</span>
<span class="fc" id="L257">	}</span>

	/**
	 * Creates a new creature with the given properties.
	 * &lt;p&gt;
	 * Creatures created with this function will share their dropItems with any
	 * other creature of that kind. If you want individual dropItems, use
	 * clearDropItemList first!
	 *
	 * @param clazz
	 *            The creature's class, e.g. &quot;golem&quot;
	 * @param subclass
	 *            The creature's subclass, e.g. &quot;wooden_golem&quot;
	 * @param name
	 *            Typically the same as clazz, except for NPCs
	 * @param hp
	 *            The creature's maximum health points
	 * @param attack
	 *            The creature's attack strength
	 * @param defense
	 *            The creature's attack strength
	 * @param level
	 *            The creature's level
	 * @param xp
	 *            The creature's experience
	 * @param width
	 *            The creature's width, in squares
	 * @param height
	 *            The creature's height, in squares
	 * @param baseSpeed
	 * @param dropItems
	 * @param aiProfiles
	 * @param noises
	 * @param respawnTime in turns
	 * @param description
	 */
	public Creature(final String clazz, final String subclass, final String name, final int hp,
			final int attack, final int defense, final int level, final int xp, final int width, final int height,
			final double baseSpeed, final List&lt;DropItem&gt; dropItems,
			final Map&lt;String, String&gt; aiProfiles, final LinkedHashMap&lt;String, LinkedList&lt;String&gt;&gt; noises,
			final int respawnTime, final String description) {
<span class="fc" id="L298">		this();</span>

<span class="fc" id="L300">		this.baseSpeed = baseSpeed;</span>

<span class="fc" id="L302">		setSize(width, height);</span>

<span class="pc bpc" id="L304" title="1 of 2 branches missed.">		if (dropItems != null) {</span>
<span class="fc" id="L305">			this.dropsItems = dropItems;</span>
		}
		// this.dropItemInstances is ignored;

<span class="fc" id="L309">		this.setAIProfiles(aiProfiles);</span>
<span class="fc" id="L310">		this.noises = new LinkedHashMap&lt;String, LinkedList&lt;String&gt;&gt;();</span>
<span class="fc" id="L311">		this.noises.putAll(noises);</span>
<span class="fc" id="L312">		this.respawnTime = respawnTime;</span>

<span class="fc" id="L314">		setEntityClass(clazz);</span>
<span class="fc" id="L315">		setEntitySubclass(subclass);</span>
<span class="fc" id="L316">		setName(name);</span>

<span class="fc" id="L318">		put(&quot;x&quot;, 0);</span>
<span class="fc" id="L319">		put(&quot;y&quot;, 0);</span>
<span class="fc" id="L320">		setDescription(description);</span>
<span class="fc" id="L321">		setAtk(attack);</span>
<span class="fc" id="L322">		setDef(defense);</span>
<span class="fc" id="L323">		setXP(xp);</span>
<span class="fc" id="L324">		setBaseHP(hp);</span>
<span class="fc" id="L325">		setHP(hp);</span>

<span class="fc" id="L327">		setLevel(level);</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">		if (Level.getLevel(xp) != level) {</span>
<span class="fc" id="L330">			LOGGER.debug(&quot;Wrong level for xp [&quot; + name + &quot;]: &quot; + xp + &quot; -&gt; &quot;</span>
					+ Level.getLevel(xp) + &quot; (!&quot; + level + &quot;)&quot;);
		}

<span class="fc" id="L334">		update();</span>
<span class="fc" id="L335">		updateModifiedAttributes();</span>
<span class="fc" id="L336">		stop();</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L338">			LOGGER.debug(getID() + &quot; Created &quot; + clazz + &quot;:&quot; + this);</span>
		}
<span class="fc" id="L340">	}</span>

	/**
	 * creates a new instance, using this creature as template
	 *
	 * @return a new creature
	 */
	public Creature getNewInstance() {
<span class="fc" id="L348">		return new Creature(this);</span>
	}

	/**
	 * Sets the sound played at creature's death
	 *
	 * @param sound Name of sound
	 */
	@Override
	public final void setDeathSound(String sound) {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">	    if (deathSound == null) {</span>
<span class="fc" id="L359">	        deathSound = sound;</span>
	    }
<span class="fc" id="L361">	    super.setDeathSound(deathSound);</span>
<span class="fc" id="L362">	}</span>

	/**
	 * Set looped sound to be played while creature is walking
	 * @param sound sound effect file name
	 */
	public final void setMovementSound(String sound) {
<span class="fc" id="L369">	    this.movementSound = sound;</span>
<span class="fc" id="L370">	}</span>

	/**
	 * Override noises for changes.
	 *
	 * @param creatureNoises noises to be used instead of the defaults for the
	 * 	creature
	 */
	public void setNoises(final LinkedHashMap&lt;String, LinkedList&lt;String&gt;&gt; creatureNoises){
<span class="fc" id="L379">		noises.clear();</span>
<span class="fc" id="L380">		noises.putAll(creatureNoises);</span>
<span class="fc" id="L381">	}</span>

	/**
	 * sets new observer
	 * @param observer
	 * 				- observer, which will get info about creature death.
	 */
	public void registerObjectsForNotification(final Observer observer) {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">		if(observer!=null) {</span>
<span class="fc" id="L390">			   registrator.setObserver(observer);</span>
		}
<span class="fc" id="L392">	}</span>

	/**
	 * sets new observer
	 * @param observers
	 * 				- observers, which will get info about creature death.
	 */
	public void registerObjectsForNotification(final List&lt;Observer&gt; observers) {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">		for(Observer observer : observers) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">			if(observer!=null) {</span>
<span class="nc" id="L402">				   registrator.setObserver(observer);</span>
			}
<span class="nc" id="L404">		}</span>
<span class="fc" id="L405">	}</span>

	/**
	 * unset observer
	 * @param observer
	 * 				- observer to remove.
	 */
	public void unregisterObjectsForNotification(final Observer observer) {
<span class="nc bnc" id="L413" title="All 2 branches missed.">		if(observer!=null) {</span>
<span class="nc" id="L414">			   registrator.removeObserver(observer);</span>
		}
<span class="nc" id="L416">	}</span>

	/**
	 * unset observer
	 * @param observers
	 * 				- observers to remove.
	 */
	public void unregisterObjectsForNotification(final List&lt;Observer&gt; observers) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">		for(Observer observer : observers) {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">			if(observer!=null) {</span>
<span class="nc" id="L426">				    registrator.removeObserver(observer);</span>
			}
<span class="nc" id="L428">		}</span>
<span class="nc" id="L429">	}</span>

	/**
	 * Will notify observers when event will occurred (death).
	 */
	public void notifyRegisteredObjects() {
<span class="fc" id="L435">	     registrator.setChanges();</span>
<span class="fc" id="L436">	     registrator.notifyObservers(circumstances);</span>
<span class="fc" id="L437">	}</span>

	public boolean isSpawned() {
<span class="nc" id="L440">		return isRespawned;</span>
	}

	public void setRespawned(final boolean isRespawned) {
<span class="fc" id="L444">		this.isRespawned = isRespawned;</span>
<span class="fc" id="L445">	}</span>

	public int getAttackTurn() {
<span class="nc" id="L448">		return attackTurn;</span>
	}

	public boolean isAttackTurn(final int turn) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">		return ((turn + attackTurn) % getAttackRate() == 0);</span>
	}


	public static void generateRPClass() {
		try {
<span class="fc" id="L458">			final RPClass npc = new RPClass(&quot;creature&quot;);</span>
<span class="fc" id="L459">			npc.isA(&quot;npc&quot;);</span>
<span class="fc" id="L460">			npc.addAttribute(&quot;debug&quot;, Type.VERY_LONG_STRING,</span>
					Definition.VOLATILE);
<span class="fc" id="L462">			npc.addAttribute(&quot;metamorphosis&quot;, Type.STRING, Definition.VOLATILE);</span>
<span class="nc" id="L463">		} catch (final SyntaxException e) {</span>
<span class="nc" id="L464">			LOGGER.error(&quot;cannot generate RPClass&quot;, e);</span>
<span class="fc" id="L465">		}</span>
<span class="fc" id="L466">	}</span>

	/**
	 * sets  the aiProfile of this creature
	 *
	 * @param aiProfiles aiProfile
	 */
	public final void setAIProfiles(final Map&lt;String, String&gt; aiProfiles) {
<span class="fc" id="L474">		this.setAIProfiles(aiProfiles, true);</span>
<span class="fc" id="L475">	}</span>
	
	private void setAIProfiles(final Map&lt;String, String&gt; aiProfiles, boolean initStatusAttacker) {
<span class="fc" id="L478">		this.aiProfiles = aiProfiles;</span>
<span class="fc" id="L479">		setHealer(aiProfiles.get(&quot;heal&quot;));</span>
<span class="fc" id="L480">		setAttackStrategy(aiProfiles);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">		if (initStatusAttacker) {</span>
<span class="fc" id="L482">			StatusAttacker poisoner = PoisonAttackerFactory.get(aiProfiles.get(&quot;poisonous&quot;));</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">			if (poisoner != null) {</span>
<span class="fc" id="L484">				this.addStatusAttacker(poisoner);</span>
			}
			
<span class="fc" id="L487">			String statusAttackerProfiles = aiProfiles.get(&quot;status_attackers&quot;);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">			if (statusAttackerProfiles != null) {</span>
<span class="fc" id="L489">    			String[] statusAttackers = statusAttackerProfiles.split(&quot;;&quot;);</span>
<span class="fc" id="L490">    			int statusCount = statusAttackers.length;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">    			for (int index = 0; index &lt; statusCount; index++) {</span>
<span class="fc" id="L492">    			    StatusAttacker statusAttacker = StatusAttackerFactory.get(statusAttackers[index]);</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">    			    if (statusAttacker != null) {</span>
<span class="fc" id="L494">    			        this.addStatusAttacker(statusAttacker);</span>
    			    }
    			}
			}
		}
<span class="fc" id="L499">		idler = IdleBehaviourFactory.get(aiProfiles);</span>
<span class="fc" id="L500">	}</span>

	/**
	 * gets the aiProfile of this creature
	 *
	 * @return aiProfile
	 */
	public Map&lt;String, String&gt; getAIProfiles() {
<span class="fc" id="L508">		return aiProfiles;</span>
	}

	public void setRespawnPoint(final CreatureRespawnPoint point) {
<span class="fc" id="L512">		this.point = point;</span>
<span class="fc" id="L513">		setRespawned(true);</span>
<span class="fc" id="L514">	}</span>

	/**
	 * gets the respan point of this create
	 *
	 * @return CreatureRespawnPoint
	 */
	public CreatureRespawnPoint getRespawnPoint() {
<span class="nc" id="L522">		return point;</span>
	}

	/**
	 * Get the respawn time of the creature.
	 *
	 * @return respawn time in turns
	 */
	public int getRespawnTime() {
<span class="fc" id="L531">		return respawnTime;</span>
	}

	public final void setCorpse(final String name, final String harmless, final int width, final int height) {
<span class="fc" id="L535">		corpseName = name;</span>
<span class="fc" id="L536">		harmlessCorpseName = harmless;</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">		if (corpseName == null) {</span>
<span class="nc" id="L538">			LOGGER.error(getName() + &quot; has null corpse name.&quot;);</span>
			/*
			 * Should not happen, but a null corpse would result
			 * in an unkillable creature, so set it to something
			 * workable.
			 */
<span class="nc" id="L544">			corpseName = &quot;animal&quot;;</span>
		}
<span class="fc bfc" id="L546" title="All 2 branches covered.">		if (harmlessCorpseName == null) {</span>
			// Set default harmless corpse to &quot;bag.png&quot;
<span class="fc" id="L548">			harmlessCorpseName = &quot;bag&quot;;</span>
		}
<span class="fc" id="L550">		corpseWidth = width;</span>
<span class="fc" id="L551">		corpseHeight = height;</span>
<span class="fc" id="L552">	}</span>

	@Override
	public String getCorpseName() {
<span class="fc bfc" id="L556" title="All 2 branches covered.">		if (corpseName == null) {</span>
<span class="fc" id="L557">			return &quot;animal&quot;;</span>
		}
<span class="fc" id="L559">		return corpseName;</span>
	}

	@Override
	public String getHarmlessCorpseName() {
<span class="fc bfc" id="L564" title="All 2 branches covered.">		if (harmlessCorpseName == null) {</span>
<span class="fc" id="L565">			return &quot;bag&quot;;</span>
		}
<span class="fc" id="L567">		return harmlessCorpseName;</span>
	}

	@Override
	public int getCorpseWidth() {
<span class="fc" id="L572">		return corpseWidth;</span>
	}

	@Override
	public int getCorpseHeight() {
<span class="fc" id="L577">		return corpseHeight;</span>
	}

	/**
	 * clears the list of predefined dropItems and creates an empty list
	 * specific to this creature.
	 *
	 */
	public void clearDropItemList() {
<span class="fc" id="L586">		dropsItems = new ArrayList&lt;DropItem&gt;();</span>
<span class="fc" id="L587">		dropItemInstances.clear();</span>
<span class="fc" id="L588">	}</span>

	/**
	 * adds a named item to the List of Items that will be dropped on dead if
	 * clearDropItemList hasn't been called first, this will change all
	 * creatures of this kind.
	 *
	 * @param name
	 * @param probability
	 * @param min
	 * @param max
	 */
	public void addDropItem(final String name, final double probability, final int min, final int max) {
<span class="nc" id="L601">		dropsItems.add(new DropItem(name, probability, min, max));</span>
<span class="nc" id="L602">	}</span>

	/**
	 * adds a named item to the List of Items that will be dropped on dead if
	 * clearDropItemList hasn't been called first, this will change all
	 * creatures of this kind.
	 *
	 * @param name
	 * @param probability
	 * @param amount
	 */
	public void addDropItem(final String name, final double probability, final int amount) {
<span class="nc" id="L614">		dropsItems.add(new DropItem(name, probability, amount));</span>
<span class="nc" id="L615">	}</span>

	/**
	 * adds a specific item to the List of Items that will be dropped on dead
	 * with 100 % probability. this is always for that specific creature only.
	 *
	 * @param item
	 */
	public void addDropItem(final Item item) {
<span class="nc" id="L624">		dropItemInstances.add(item);</span>
<span class="nc" id="L625">	}</span>

	/**
	 * Returns true if this RPEntity is attackable.
	 */
	@Override
	public boolean isAttackable() {
<span class="fc" id="L632">		return true;</span>
	}

	@Override
	public void onDead(final Killer killer, final boolean remove) {
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">		if (killer instanceof RPEntity) {</span>
<span class="fc" id="L638">			circumstances = new CircumstancesOfDeath((RPEntity)killer, this, this.getZone());</span>
		}

<span class="fc" id="L641">		notifyRegisteredObjects();</span>

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">		if (this.point != null) {</span>
<span class="nc" id="L644">			this.point.notifyDead(this);</span>
		}

<span class="fc" id="L647">		super.onDead(killer, remove);</span>
<span class="fc" id="L648">	}</span>

	@Override
	protected void dropItemsOn(final Corpse corpse) {
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">		for (final Item item : dropItemInstances) {</span>
<span class="nc" id="L653">			item.setFromCorpse(true);</span>
<span class="nc" id="L654">			corpse.add(item);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">			if (corpse.isFull()) {</span>
<span class="nc" id="L656">				break;</span>
			}
<span class="nc" id="L658">		}</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">		for (final Item item : createDroppedItems(SingletonRepository.getEntityManager())) {</span>
<span class="fc" id="L661">			corpse.add(item);</span>
<span class="fc" id="L662">			item.setFromCorpse(true);</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">			if (corpse.isFull()) {</span>
<span class="nc" id="L664">				break;</span>
			}
<span class="fc" id="L666">		}</span>
<span class="fc" id="L667">	}</span>


	/**
	 * Returns a list of enemies. One of it will be attacked.
	 *
	 * @return list of enemies
	 */
	public List&lt;RPEntity&gt; getEnemyList() {
<span class="fc bfc" id="L676" title="All 2 branches covered.">		if (getAIProfiles().containsKey(&quot;offensive&quot;)) {</span>
<span class="fc" id="L677">			return getZone().getPlayerAndFriends();</span>
		} else {
<span class="fc" id="L679">			return getAttackingRPEntities();</span>
		}
	}

	/**
	 * Returns the nearest enemy, which is reachable or otherwise attackable.
	 *
	 * @param range
	 *            attack radius
	 * @return chosen enemy or null if no enemy was found.
	 */
	public RPEntity getNearestEnemy(final double range) {
		// create list of enemies
<span class="fc" id="L692">		final List&lt;RPEntity&gt; enemyList = getEnemyList();</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">		if (enemyList.isEmpty()) {</span>
<span class="fc" id="L694">			return null;</span>
		}

		// calculate the distance of all possible enemies
<span class="fc" id="L698">		final Map&lt;RPEntity, Double&gt; distances = new HashMap&lt;RPEntity, Double&gt;();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">		for (final RPEntity enemy : enemyList) {</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">			if (enemy == this) {</span>
<span class="nc" id="L701">				continue;</span>
			}

<span class="fc bfc" id="L704" title="All 2 branches covered.">			if (enemy.isInvisibleToCreatures()) {</span>
<span class="fc" id="L705">				continue;</span>
			}

<span class="fc" id="L708">			final double squaredDistance = this.squaredDistance(enemy);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">			if (squaredDistance &lt;= (range * range)) {</span>
<span class="fc" id="L710">				distances.put(enemy, squaredDistance);</span>
			}
<span class="fc" id="L712">		}</span>

		// now choose the nearest enemy for which there is a path, or is
		// attackable otherwise
<span class="fc" id="L716">		RPEntity chosen = null;</span>
<span class="fc bfc" id="L717" title="All 4 branches covered.">		while ((chosen == null) &amp;&amp; !distances.isEmpty()) {</span>
<span class="fc" id="L718">			double shortestDistance = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">			for (final Map.Entry&lt;RPEntity, Double&gt; enemy : distances.entrySet()) {</span>
<span class="fc" id="L720">				final double distance = enemy.getValue();</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">				if (distance &lt; shortestDistance) {</span>
<span class="fc" id="L722">					chosen = enemy.getKey();</span>
<span class="fc" id="L723">					shortestDistance = distance;</span>
				}
<span class="fc" id="L725">			}</span>

<span class="fc bfc" id="L727" title="All 2 branches covered.">			if (shortestDistance &gt;= 1) {</span>
<span class="fc" id="L728">				final List&lt;Node&gt; path = Path.searchPath(this, chosen, getMovementRange());</span>
<span class="pc bpc" id="L729" title="4 of 6 branches missed.">				if ((path == null) || path.isEmpty() &amp;&amp; !strategy.canAttackNow(this, chosen)) {</span>
<span class="nc" id="L730">					distances.remove(chosen);</span>
<span class="nc" id="L731">					chosen = null;</span>
				} else {
					// set the path. if not setMovement() will search a new one
<span class="fc" id="L734">					setPath(new FixedPath(path, false));</span>
				}
			}
<span class="fc" id="L737">		}</span>
		// return the chosen enemy or null if we could not find one in reach
<span class="fc" id="L739">		return chosen;</span>
	}

	public boolean isEnemyNear(final double range) {
<span class="nc" id="L743">		final int x = getX();</span>
<span class="nc" id="L744">		final int y = getY();</span>

<span class="nc" id="L746">		List&lt;RPEntity&gt; enemyList = getEnemyList();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">		if (enemyList.isEmpty()) {</span>
<span class="nc" id="L748">			final StendhalRPZone zone = getZone();</span>
<span class="nc" id="L749">			enemyList = zone.getPlayerAndFriends();</span>
		}

<span class="nc bnc" id="L752" title="All 2 branches missed.">		for (final RPEntity playerOrFriend : enemyList) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">			if (playerOrFriend == this) {</span>
<span class="nc" id="L754">				continue;</span>
			}

<span class="nc bnc" id="L757" title="All 2 branches missed.">			if (playerOrFriend.isInvisibleToCreatures()) {</span>
<span class="nc" id="L758">				continue;</span>
			}

<span class="nc bnc" id="L761" title="All 2 branches missed.">			if (playerOrFriend.getZone() == getZone()) {</span>
<span class="nc" id="L762">				final int fx = playerOrFriend.getX();</span>
<span class="nc" id="L763">				final int fy = playerOrFriend.getY();</span>

<span class="nc bnc" id="L765" title="All 4 branches missed.">				if ((Math.abs(fx - x) &lt; range) &amp;&amp; (Math.abs(fy - y) &lt; range)) {</span>
<span class="nc" id="L766">					return true;</span>
				}
			}
<span class="nc" id="L769">		}</span>

<span class="nc" id="L771">		return false;</span>
	}

	/**
	 * Check if the creature has a rare profile, and thus should not appear in DeathMatch,
	 * or the daily quest.
	 *
	 * @return true if the creature is rare, false otherwise
	 */
	public boolean isRare() {
<span class="fc" id="L781">		return getAIProfiles().containsKey(&quot;rare&quot;);</span>
	}

	public void equip(final List&lt;EquipItem&gt; items) {
<span class="fc bfc" id="L785" title="All 2 branches covered.">		for (final EquipItem equippedItem : items) {</span>
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">			if (!hasSlot(equippedItem.slot)) {</span>
<span class="fc" id="L787">				addSlot(new EntitySlot(equippedItem.slot, equippedItem.slot));</span>
			}

<span class="fc" id="L790">			final RPSlot slot = getSlot(equippedItem.slot);</span>
<span class="fc" id="L791">			final Item item = SingletonRepository.getEntityManager().getItem(equippedItem.name);</span>

<span class="fc bfc" id="L793" title="All 2 branches covered.">			if (item instanceof StackableItem) {</span>
<span class="fc" id="L794">				((StackableItem) item).setQuantity(equippedItem.quantity);</span>
			}

<span class="fc" id="L797">			slot.add(item);</span>
<span class="fc" id="L798">		}</span>
<span class="fc" id="L799">	}</span>

	private List&lt;Item&gt; createDroppedItems(final EntityManager defaultEntityManager) {
<span class="fc" id="L802">		final List&lt;Item&gt; list = new LinkedList&lt;Item&gt;();</span>

<span class="fc bfc" id="L804" title="All 2 branches covered.">		for (final DropItem dropped : dropsItems) {</span>
<span class="fc" id="L805">			final double probability = Rand.rand(1000000) / 10000.0;</span>

<span class="fc bfc" id="L807" title="All 2 branches covered.">			if (probability &lt;= (dropped.probability / SERVER_DROP_GENEROSITY)) {</span>
<span class="fc" id="L808">				final Item item = defaultEntityManager.getItem(dropped.name);</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">				if (item == null) {</span>
<span class="nc" id="L810">					LOGGER.error(&quot;Unable to create item: &quot; + dropped.name);</span>
<span class="nc" id="L811">					continue;</span>
				}

<span class="fc bfc" id="L814" title="All 2 branches covered.">				if (dropped.min == dropped.max) {</span>
<span class="fc" id="L815">					list.add(item);</span>
				} else {
<span class="fc" id="L817">					final StackableItem stackItem = (StackableItem) item;</span>
<span class="fc" id="L818">					stackItem.setQuantity(Rand.rand(dropped.max - dropped.min)</span>
							+ dropped.min);
<span class="fc" id="L820">					list.add(stackItem);</span>
				}
			}
<span class="fc" id="L823">		}</span>
<span class="fc" id="L824">		return list;</span>
	}

	@Override
	public int getMaxRangeForArcher() {
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">		if (strategy != null) {</span>
<span class="fc" id="L830">			return strategy.getRange();</span>
		} else {
<span class="nc" id="L832">			return 0;</span>
		}
	}

	/**
	 * returns the value of an ai profile.
	 *
	 * @param key
	 *            as defined in creatures.xml
	 * @return value or null if undefined
	 */
	public String getAIProfile(final String key) {
<span class="fc" id="L844">		return getAIProfiles().get(key);</span>
	}

	/**
	 * is called after the Creature is added to the zone.
	 */
	public void init() {
		// do nothing
<span class="fc" id="L852">	}</span>

	@Override
	public void logic() {
<span class="fc" id="L856">		healer.heal(this);</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">		if (!this.getZone().getPlayerAndFriends().isEmpty()) {</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">			if (strategy.hasValidTarget(this)) {</span>
<span class="fc" id="L859">				strategy.getBetterAttackPosition(this);</span>
<span class="fc" id="L860">				this.applyMovement();</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">				if (strategy.canAttackNow(this)) {</span>
<span class="fc" id="L862">					strategy.attack(this);</span>
<span class="fc" id="L863">					this.makeNoiseChance(100, &quot;fight&quot;);</span>
				} else {
					// can't attack and trying to find better position
					// treat it as creature follows player.
<span class="nc" id="L867">					this.makeNoiseChance(100, &quot;follow&quot;);</span>
				}
			} else {
<span class="fc" id="L870">				this.stopAttack();</span>
<span class="fc" id="L871">				strategy.findNewTarget(this);</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">				if (strategy.hasValidTarget(this)) {</span>
<span class="fc" id="L873">					this.setBusy();</span>
					// this event duration usually is only one turn
<span class="fc" id="L875">					this.makeNoiseChance(50, &quot;target&quot;);</span>
				} else {
<span class="fc" id="L877">				 	this.setIdle();</span>
<span class="fc" id="L878">					this.makeNoiseChance(100, &quot;idle&quot;);</span>
				}
			}
<span class="fc" id="L881">			maybeMakeSound();</span>

			// FIXME: Play a looped sound for walking creatrue
<span class="pc bpc" id="L884" title="3 of 4 branches missed.">			if (movementSound != null &amp;&amp; movementSoundEvent == null) {</span>
<span class="nc" id="L885">				loopMovementSound();</span>
			}
<span class="fc" id="L887">			this.notifyWorldAboutChanges();</span>
		} else {
			/*
			 * Run enough logic to stop attacking, if the zone gets empty.
			 * Otherwise the target attribute does not get changed, and may
			 * be incorrect if the same player that was the target reappears.
			 */
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">			if (isAttacking()) {</span>
<span class="nc" id="L895">				stopAttack();</span>
			}
		}
<span class="fc" id="L898">	}</span>

	/**
	 * Random sound noises.
	 * @param state - state for noises
	 */
	public void makeNoise(final String state) {
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">		if (noises == null) {</span>
<span class="nc" id="L906">			return;</span>
		}
<span class="fc bfc" id="L908" title="All 2 branches covered.">		if (noises.get(state)==null) {</span>
<span class="fc" id="L909">			return;</span>
		}
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">		if (noises.get(state).size() &gt; 0) {</span>
<span class="fc" id="L912">			final int pos = Rand.rand(noises.get(state).size());</span>
<span class="fc" id="L913">			say(noises.get(state).get(pos));</span>
		}
<span class="fc" id="L915">	}</span>


	/**
	 * wrapper around makeNoise to simplify a code
	 * @param prob - 1/chance of make noise
	 * @param state - state for noises
	 */
	public void makeNoiseChance(int prob, final String state) {
<span class="fc bfc" id="L924" title="All 2 branches covered.">		if(Rand.rand(prob)==1) {</span>
<span class="fc" id="L925">			makeNoise(state);</span>
		}
<span class="fc" id="L927">	}</span>

	/**
	 * Generates a looped sound for creature
	 *
	 * FIXME: doesn't play sound
	 */
	private void loopMovementSound() {
<span class="nc" id="L935">	    movementSoundEvent = new SoundEvent(movementSound, SOUND_RADIUS, 100, SoundLayer.CREATURE_NOISE);</span>
<span class="nc" id="L936">	    this.addEvent(movementSoundEvent);</span>
<span class="nc" id="L937">	    this.notifyWorldAboutChanges();</span>
<span class="nc" id="L938">	}</span>

	/**
	 * Stops the looped sound
	 */
	public void stopMovementSound() {
<span class="nc" id="L944">		movementSoundEvent = null;</span>
<span class="nc" id="L945">	}</span>

	/**
	 *
	 * @return
	 * 		true if looped sound is currently playing
	 */
	public boolean isPlayingMovementSound() {
<span class="nc bnc" id="L953" title="All 2 branches missed.">		return (movementSoundEvent != null);</span>
	}

	public boolean hasTargetMoved() {
<span class="pc bpc" id="L957" title="1 of 4 branches missed.">		if ((targetX != getAttackTarget().getX()) || (targetY != getAttackTarget().getY())) {</span>
<span class="fc" id="L958">			targetX = getAttackTarget().getX();</span>
<span class="fc" id="L959">			targetY = getAttackTarget().getY();</span>

<span class="fc" id="L961">			return true;</span>
		}
<span class="fc" id="L963">		return false;</span>
	}

	public void setIdle() {
<span class="fc bfc" id="L967" title="All 2 branches covered.">		if (!isIdle) {</span>
<span class="fc" id="L968">			isIdle = true;</span>
<span class="fc" id="L969">			clearPath();</span>
<span class="fc" id="L970">			stopAttack();</span>
<span class="fc" id="L971">			stop();</span>

		} else {
<span class="fc" id="L974">			idler.perform(this);</span>

		}

<span class="fc" id="L978">	}</span>

	public void setBusy() {
<span class="fc" id="L981">		isIdle = false;</span>
<span class="fc" id="L982">	}</span>

	/**
	 * Set the fighting strategy used by the creature.
	 *
	 * @param aiProfiles AI profiles to be used when deciding the strategy
	 */
	public void setAttackStrategy(final Map&lt;String, String&gt; aiProfiles) {
<span class="fc" id="L990">		strategy = AttackStrategyFactory.get(aiProfiles);</span>
<span class="fc" id="L991">	}</span>

	/**
	 * Get the fighting strategy used by the creature.
	 *
	 * @return strategy
	 */
	public AttackStrategy getAttackStrategy() {
<span class="fc" id="L999">		return strategy;</span>
	}

	public void setHealer(final String aiprofile) {
<span class="fc" id="L1003">		healer = HealerBehaviourFactory.get(aiprofile);</span>
<span class="fc" id="L1004">	}</span>

	@Override
	public float getItemAtk() {
		// Give creatures a bit weapon atk to prevent having too high
		// personal atk values
<span class="fc" id="L1010">		return 5f;</span>
	}

	// *** Damage type code ***

	/**
	 * Set the susceptibility mapping of a creature. The mapping is &lt;em&gt;not&lt;/em&gt;
	 * copied.
	 * @param susceptibilities The susceptibilities of the creature
	 */
	public void setSusceptibilities(Map&lt;Nature, Double&gt; susceptibilities) {
<span class="fc" id="L1021">		this.susceptibilities = susceptibilities;</span>
<span class="fc" id="L1022">	}</span>

	@Override
	protected double getSusceptibility(Nature type) {
<span class="fc" id="L1026">		Double d = susceptibilities.get(type);</span>

<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">		if (d != null) {</span>
<span class="nc" id="L1029">			return d.doubleValue();</span>
		}

<span class="fc" id="L1032">		return 1.0;</span>
	}

	@Override
	protected Nature getDamageType() {
<span class="fc" id="L1037">		return damageType;</span>
	}

	@Override
	protected Nature getRangedDamageType() {
<span class="nc" id="L1042">		return rangedDamageType;</span>
	}

	/**
	 * Set the damage natures the creature inflicts.
	 *
	 * @param type Damage nature.
	 * @param rangedType Damage nature for ranged attacks, or &lt;code&gt;null&lt;/code&gt;
	 * 	if the creature uses the same type as for the melee.
	 */
	public final void setDamageTypes(Nature type, Nature rangedType) {
<span class="fc" id="L1053">		damageType = type;</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">		if (rangedType != null) {</span>
<span class="fc" id="L1055">			rangedDamageType = rangedType;</span>
		} else {
<span class="fc" id="L1057">			rangedDamageType = type;</span>
		}
<span class="fc" id="L1059">	}</span>

	@Override
	public boolean attack() {
<span class="fc" id="L1063">		boolean res = super.attack();</span>

		// count hits for corpse protection
<span class="fc" id="L1066">		final RPEntity defender = this.getAttackTarget();</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">		if (defender instanceof Player) {</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">			if (hitPlayers == null) {</span>
<span class="fc" id="L1069">				hitPlayers = new CounterMap&lt;String&gt;();</span>
			}
<span class="fc" id="L1071">			hitPlayers.add(defender.getName());</span>
		}

<span class="fc" id="L1074">		return res;</span>
	}


	/**
	 * gets the name of the player who deserves the corpse
	 *
	 * @return name of player who deserves the corpse or &lt;code&gt;null&lt;/code&gt;.
	 */
	@Override
	public String getCorpseDeserver() {
		// which player did we hurt most?
<span class="fc bfc" id="L1086" title="All 2 branches covered.">		if (hitPlayers != null) {</span>
<span class="fc" id="L1087">			String playerName = hitPlayers.getHighestCountedObject();</span>
<span class="pc bpc" id="L1088" title="1 of 4 branches missed.">			if ((playerName != null) &amp;&amp; (hitPlayers.getCount(playerName) &gt; 3)) {</span>
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">				if (isPlayerInZone(playerName)) {</span>
<span class="fc" id="L1090">					return playerName;</span>
				}
			}
		}

		// which player did hurt us most
<span class="fc" id="L1096">		Entity entity = damageReceived.getHighestCountedObject();</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">		if (entity instanceof Player) {</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">			if (getZone() == entity.getZone()) {</span>
<span class="fc" id="L1099">				return ((Player) entity).getName();</span>
			}
		}

		// which player did we attack last?
<span class="fc" id="L1104">		RPEntity target = getAttackTarget();</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">		if (target instanceof Player) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">			if (getZone() == target.getZone()) {</span>
<span class="nc" id="L1107">				return target.getName();</span>
			}
		}

<span class="fc" id="L1111">		return null;</span>
	}

	/**
	 * checks if the name player is in the same zone
	 *
	 * @param playerName name of player
	 * @return true if he is online and in the same zone as this creature
	 */
	private boolean isPlayerInZone(String playerName) {
<span class="fc" id="L1121">		Player player = StendhalRPRuleProcessor.get().getPlayer(playerName);</span>
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">		if (player == null) {</span>
<span class="nc" id="L1123">			return false;</span>
		}
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">		return getZone() == player.getZone();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>