<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EntityViewManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client</a> &gt; <span class="el_source">EntityViewManager.java</span></div><h1>EntityViewManager.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                   (C) Copyright 2003-2012 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client;

import games.stendhal.client.entity.IEntity;
import games.stendhal.client.entity.Item;
import games.stendhal.client.entity.Player;
import games.stendhal.client.gui.j2d.entity.EntityView;
import games.stendhal.client.gui.j2d.entity.EntityViewFactory;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.log4j.Logger;

/**
 * Manager for EntityViews. Several methods specify from which threads they may
 * be called. The manager takes care of synchronizing the relevant data between
 * those.
 */
<span class="nc" id="L38">class EntityViewManager {</span>
<span class="nc" id="L39">	private static final Logger logger = Logger.getLogger(EntityViewManager.class);</span>
	
	/**
	 * Comparator used to sort entities to display.
	 */
<span class="nc" id="L44">	private static final EntityViewComparator entityViewComparator = new EntityViewComparator();</span>

	/**
	 * The entity views. Modified in the game loop and read in the EDT.
	 * Remember to synchronize.
	 */
<span class="nc" id="L50">	private final List&lt;EntityView&lt;IEntity&gt;&gt; views = new ArrayList&lt;EntityView&lt;IEntity&gt;&gt;();</span>
	/** Entities on the screen. */
<span class="nc" id="L52">	private final List&lt;EntityView&lt;IEntity&gt;&gt; visibleViews = new ArrayList&lt;EntityView&lt;IEntity&gt;&gt;();</span>

	/**
	 * The entity to view map. May be accessed only in the game loop thread.
	 */
<span class="nc" id="L57">	private final Map&lt;IEntity, EntityView&lt;IEntity&gt;&gt; entities = new HashMap&lt;IEntity, EntityView&lt;IEntity&gt;&gt;();</span>

	/** User name. Used for grabbing user owned items hack. */
<span class="nc" id="L60">	private final String userName = StendhalClient.get().getCharacter();</span>

	/**
	 * Add an entity. Must be called only from the game loop thread.
	 * 
	 * @param entity new entity
	 * @return view belonging to the entity, or &lt;code&gt;null&lt;/code&gt;
	 */
	EntityView&lt;IEntity&gt; addEntity(final IEntity entity) {
<span class="nc" id="L69">		final EntityView&lt;IEntity&gt; view = EntityViewFactory.create(entity);</span>

<span class="nc bnc" id="L71" title="All 2 branches missed.">		if (view != null) {</span>
<span class="nc" id="L72">			entities.put(entity, view);</span>
<span class="nc" id="L73">			addEntityView(view);</span>
		}
<span class="nc" id="L75">		return view;</span>
	}

	/**
	 * Add an entity view.
	 * 
	 * @param view new view
	 */
	private void addEntityView(EntityView&lt;IEntity&gt; view) {
<span class="nc" id="L84">		synchronized (views) {</span>
<span class="nc" id="L85">			views.add(view);</span>
<span class="nc" id="L86">		}</span>
<span class="nc" id="L87">	}</span>

	/**
	 * Get an entity view at a specific location.
	 * 
	 * @param x world x coordinate
	 * @param y world y coordinate
	 * @param sx pixel x coordinate
	 * @param sy pixel y coordinate
	 * 
	 * @return entity view, or &lt;code&gt;null&lt;/code&gt; if no entity was found at the
	 *         location
	 */
	EntityView&lt;IEntity&gt; getEntityViewAt(final double x, final double y,
			final int sx, final int sy) {
		// Try the physical entity areas first
<span class="nc" id="L103">		EntityView&lt;IEntity&gt; view = getOccupyingEntityViewAt(x, y, false);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">		if (view != null) {</span>
<span class="nc" id="L105">			return view;</span>
		}

<span class="nc" id="L108">		return getVisibleEntityViewAt(sx, sy, false);</span>
	}

	/**
	 * Get a movable entity view at a specific location. Looks for physical
	 * entities occupying the area first.
	 * 
	 * @param x world x coordinate
	 * @param y world y coordinate
	 * @param sx pixel x coordinate
	 * @param sy pixel y coordinate
	 * 
	 * @return moveable entity view, or &lt;code&gt;null&lt;/code&gt; if none was found
	 */
	EntityView&lt;IEntity&gt; getMovableEntityViewAt(final double x, final double y,
			final int sx, final int sy) {
		// Try the physical entity areas first
<span class="nc" id="L125">		EntityView&lt;IEntity&gt; view = getOccupyingEntityViewAt(x, y, true);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (view != null) {</span>
<span class="nc" id="L127">			return view;</span>
		}

<span class="nc" id="L130">		return getVisibleEntityViewAt(sx, sy, true);</span>
	}

	/**
	 * Look for a physical entity at a specific location.
	 * 
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param movable if &lt;code&gt;true&lt;/code&gt;, look for a movable entity
	 * 
	 * @return EntityView of an entity occupying (x, y), or &lt;code&gt;null&lt;/code&gt; if
	 *         no suitable entity was found
	 */
	private EntityView&lt;IEntity&gt; getOccupyingEntityViewAt(final double x,
			final double y, boolean movable) {
		ListIterator&lt;EntityView&lt;IEntity&gt;&gt; it;
<span class="nc" id="L146">		EntityView&lt;IEntity&gt; foundEntity = null;</span>

<span class="nc" id="L148">		it = visibleViews.listIterator(visibleViews.size());</span>

		// A hack to grab bound items if they are under another player
<span class="nc" id="L151">		boolean deepFind = false;</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">		while (it.hasPrevious()) {</span>
<span class="nc" id="L154">			final EntityView&lt;IEntity&gt; view = it.previous();</span>
<span class="nc" id="L155">			IEntity entity = view.getEntity();</span>

<span class="nc bnc" id="L157" title="All 8 branches missed.">			if (movable &amp;&amp; (entity instanceof Player)</span>
					&amp;&amp; (!((Player) entity).isUser())
					&amp;&amp; entity.getArea().contains(x, y)) {
				// Looking for a movable entity under another player. Try to
				// find an item belonging to the user
<span class="nc" id="L162">				deepFind = true;</span>
			}

<span class="nc bnc" id="L165" title="All 4 branches missed.">			if (!movable || view.isMovable()) {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">				if (entity.getArea().contains(x, y)) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">					if (deepFind) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">						if (foundEntity == null) {</span>
							// Store the first candidate in case we do not
							// find bound items
<span class="nc" id="L171">							foundEntity = view;</span>
						}
<span class="nc bnc" id="L173" title="All 2 branches missed.">						if (entity instanceof Item) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">							if (userName.equals(entity.getRPObject().get(</span>
									&quot;bound&quot;))) {
								// Found an item bound to the user. This is
								// what we want to grab.
<span class="nc" id="L178">								return view;</span>
							}
						}
					} else {
<span class="nc" id="L182">						return view;</span>
					}
				}
			}
<span class="nc" id="L186">		}</span>
<span class="nc" id="L187">		return foundEntity;</span>
	}

	/**
	 * Get topmost EntityView whose visual area contains pixel coordinates (sx,
	 * sy).
	 * 
	 * @param sx x coordinate
	 * @param sy y coordinate
	 * @param movable if &lt;code&gt;true&lt;/code&gt;, look only for movable entities
	 * 
	 * @return EntityView, or &lt;code&gt;null&lt;/code&gt; if suitable view was not found
	 */
	private EntityView&lt;IEntity&gt; getVisibleEntityViewAt(final int sx,
			final int sy, boolean movable) {
<span class="nc" id="L202">		ListIterator&lt;EntityView&lt;IEntity&gt;&gt; it = visibleViews.listIterator(visibleViews.size());</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">		while (it.hasPrevious()) {</span>
<span class="nc" id="L205">			final EntityView&lt;IEntity&gt; view = it.previous();</span>

<span class="nc bnc" id="L207" title="All 2 branches missed.">			if (view.getArea().contains(sx, sy)) {</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">				if (!movable || view.isMovable()) {</span>
<span class="nc" id="L209">					return view;</span>
				}
			}
<span class="nc" id="L212">		}</span>

<span class="nc" id="L214">		return null;</span>
	}

	/**
	 * Remove an entity. Must be called only from the game loop thread.
	 * 
	 * @param entity removed entity
	 */
	void removeEntity(final IEntity entity) {
<span class="nc" id="L223">		final EntityView&lt;IEntity&gt; view = entities.remove(entity);</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">		if (view != null) {</span>
<span class="nc" id="L226">			removeEntityView(view);</span>
		}
<span class="nc" id="L228">	}</span>

	/**
	 * Remove an entity view.
	 * 
	 * @param view removed view
	 */
	private void removeEntityView(EntityView&lt;IEntity&gt; view) {
<span class="nc" id="L236">		synchronized (views) {</span>
<span class="nc" id="L237">			views.remove(view);</span>
<span class="nc" id="L238">			view.release();</span>
<span class="nc" id="L239">		}</span>
<span class="nc" id="L240">	}</span>

	/**
	 * Reinitialize the views of all entities. Should be called only from the
	 * game loop thread.
	 */
	void resetViews() {
		// * Update the coloring of the entity views. *
<span class="nc bnc" id="L248" title="All 2 branches missed.">		for (Entry&lt;IEntity, EntityView&lt;IEntity&gt;&gt; entry : entities.entrySet()) {</span>
			// initialize() should trigger making a new image
<span class="nc" id="L250">			entry.getValue().initialize(entry.getKey());</span>
<span class="nc" id="L251">		}</span>
<span class="nc" id="L252">	}</span>

	/**
	 * Prepare the entity views for drawing. Must be called only from the event
	 * dispatch thread.
	 * 
	 * @param area visible area
	 */
	void prepareViews(Rectangle area) {
<span class="nc" id="L261">		visibleViews.clear();</span>
<span class="nc" id="L262">		synchronized (views) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">			for (EntityView&lt;IEntity&gt; view : views) {</span>
<span class="nc" id="L264">				view.applyChanges();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">				if (area.intersects(view.getArea())) {</span>
<span class="nc" id="L266">					visibleViews.add(view);</span>
				}
<span class="nc" id="L268">			}</span>
<span class="nc" id="L269">		}</span>
	
<span class="nc" id="L271">		Collections.sort(visibleViews, entityViewComparator);</span>
<span class="nc" id="L272">	}</span>
	
	/**
	 * Draw entities.
	 * 
	 * @param g graphics
	 */
	void draw(Graphics2D g) {
<span class="nc bnc" id="L280" title="All 2 branches missed.">		for (final EntityView&lt;IEntity&gt; view : visibleViews) {</span>
			try {
<span class="nc" id="L282">				view.draw(g);</span>
<span class="nc" id="L283">			} catch (RuntimeException e) {</span>
<span class="nc" id="L284">				logger.error(e, e);</span>
<span class="nc" id="L285">			}</span>
<span class="nc" id="L286">		}</span>
<span class="nc" id="L287">	}</span>
	
	/**
	 * Draw the top parts of the entities.
	 * 
	 * @param g graphics
	 */
	void drawTop(Graphics2D g) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">		for (final EntityView&lt;IEntity&gt; view : visibleViews) {</span>
			try {
<span class="nc" id="L297">				view.drawTop(g);</span>
<span class="nc" id="L298">			} catch (RuntimeException e) {</span>
<span class="nc" id="L299">				logger.error(e, e);</span>
<span class="nc" id="L300">			}</span>
<span class="nc" id="L301">		}</span>
<span class="nc" id="L302">	}</span>

	/**
	 * Comparator for sorting the views.
	 */
<span class="nc" id="L307">	private static class EntityViewComparator implements</span>
			Comparator&lt;EntityView&lt;IEntity&gt;&gt; {
		@Override
		public int compare(final EntityView&lt;IEntity&gt; view1,
				final EntityView&lt;IEntity&gt; view2) {
			int rv;

<span class="nc" id="L314">			rv = view1.getZIndex() - view2.getZIndex();</span>

<span class="nc bnc" id="L316" title="All 2 branches missed.">			if (rv == 0) {</span>
<span class="nc" id="L317">				final Rectangle area1 = view1.getArea();</span>
<span class="nc" id="L318">				final Rectangle area2 = view2.getArea();</span>

<span class="nc" id="L320">				rv = (area1.y + area1.height) - (area2.y + area2.height);</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">				if (rv == 0) {</span>
					/*
					 * Quick workaround to stack items in the same order they
					 * were added.
					 * 
					 * TODO: stack items in the same order they were added on
					 * server side.
					 */
<span class="nc" id="L330">					rv = view1.getEntity().getID().getObjectID()</span>
							- view2.getEntity().getID().getObjectID();
				}
			}

<span class="nc" id="L335">			return rv;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>