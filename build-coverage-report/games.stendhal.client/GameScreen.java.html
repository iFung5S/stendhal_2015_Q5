<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GameScreen.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client</a> &gt; <span class="el_source">GameScreen.java</span></div><h1>GameScreen.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                      (C) Copyright 2003 - Marauroa                      *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.geom.Point2D;
import java.awt.image.VolatileImage;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import javax.swing.JComponent;
import javax.swing.SwingUtilities;

import org.apache.log4j.Logger;

import games.stendhal.client.entity.Corpse;
import games.stendhal.client.entity.IEntity;
import games.stendhal.client.entity.Item;
import games.stendhal.client.gui.DropTarget;
import games.stendhal.client.gui.EffectLayer;
import games.stendhal.client.gui.GroundContainer;
import games.stendhal.client.gui.j2d.AchievementBoxFactory;
import games.stendhal.client.gui.j2d.RemovableSprite;
import games.stendhal.client.gui.j2d.entity.Entity2DView;
import games.stendhal.client.gui.j2d.entity.EntityView;
import games.stendhal.client.gui.spellcasting.SpellCastingGroundContainerMouseState;
import games.stendhal.client.sprite.Sprite;
import games.stendhal.client.sprite.SpriteStore;
import games.stendhal.common.MathHelper;
import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;

/**
 * The game screen. This manages and renders the visual elements of the game.
 */
public class GameScreen extends JComponent implements IGameScreen, DropTarget,
	GameObjects.GameObjectListener, StendhalClient.ZoneChangeListener {
	/**
	 * serial version uid.
	 */
	private static final long serialVersionUID = -4070406295913030925L;

<span class="nc" id="L69">	private static final Logger logger = Logger.getLogger(GameScreen.class);</span>
	
	/** Map KeyEvents to a number, i.e. to determine position in spells slot based on pressed key **/
<span class="nc" id="L72">	private static final Map&lt;Integer, Integer&gt; keyEventMapping = new HashMap&lt;Integer, Integer&gt;();</span>
	static {
<span class="nc" id="L74">		keyEventMapping.put(KeyEvent.VK_1, Integer.valueOf(1));</span>
<span class="nc" id="L75">		keyEventMapping.put(KeyEvent.VK_2, Integer.valueOf(2));</span>
<span class="nc" id="L76">		keyEventMapping.put(KeyEvent.VK_3, Integer.valueOf(3));</span>
<span class="nc" id="L77">		keyEventMapping.put(KeyEvent.VK_4, Integer.valueOf(4));</span>
<span class="nc" id="L78">		keyEventMapping.put(KeyEvent.VK_5, Integer.valueOf(5));</span>
<span class="nc" id="L79">		keyEventMapping.put(KeyEvent.VK_6, Integer.valueOf(6));</span>
<span class="nc" id="L80">		keyEventMapping.put(KeyEvent.VK_7, Integer.valueOf(7));</span>
<span class="nc" id="L81">		keyEventMapping.put(KeyEvent.VK_8, Integer.valueOf(8));</span>
<span class="nc" id="L82">		keyEventMapping.put(KeyEvent.VK_9, Integer.valueOf(9));</span>
<span class="nc" id="L83">		keyEventMapping.put(KeyEvent.VK_0, Integer.valueOf(10));</span>
	}

	/**
	 * A scale factor for panning delta (to allow non-float precision).
	 */
	private static final int PAN_SCALE = 8;
	/**
	 * Speed factor for centering the screen. Smaller is faster,
	 * and keeps the player closer to the center of the screen when walking.
	 */
	private static final int PAN_INERTIA = 15;
	/**
	 * Space at the right and bottom of the screen next to the off line
	 * indicator icon.
	 */
	private static final int OFFLINE_MARGIN = 10;

	private static final Sprite offlineIcon;

	/** the singleton instance. */
	private static GameScreen screen;

	/**
	 * Static game layers.
	 */
	private final StaticGameLayers gameLayers;
<span class="nc" id="L110">	private static final Collection&lt;EffectLayer&gt; globalEffects = new LinkedList&lt;&gt;();</span>
	
	/** Entity views container. */
<span class="nc" id="L113">	private final EntityViewManager viewManager = new EntityViewManager();</span>

	/** Actual width of the world in world units. */
	private int ww;
	/** Actual height of the world in world units. */
	private int wh;

	/**
	 * The ground layer.
	 */
	private final GroundContainer ground;

	/**
	 * The text bubbles.
	 */
	private final List&lt;RemovableSprite&gt; texts;
	
	/**
	 * Text boxes that are anchored to the screen coordinates.
	 */
	private final List&lt;RemovableSprite&gt; staticSprites;

	private boolean offline;

	/**
	 * Off line indicator counter. 
	 */
	private int blinkOffline;

	/**
	 * The targeted center of view X coordinate (truncated).
	 */
	private int x;

	/**
	 * The targeted center of view Y coordinate (truncated).
	 */
	private int y;

	/** Actual size of the screen in pixels. */
	private int sw;
	private int sh;

	/**
	 * The difference between current and target screen view X.
	 */
	private int dvx;

	/**
	 * The difference between current and target screen view Y.
	 */
	private int dvy;

	/**
	 * The current screen view X.
	 */
	private int svx;

	/**
	 * The current screen view Y.
	 */
	private int svy;

	/**
	 * Current panning speed.
	 */
	private int speed;
	
	/**
	 * Scaling factor of the screen.
	 */
<span class="nc" id="L184">	private double scale = 1.0;</span>
	/**
	 * Flag for telling if the screen should be scaled if it's not of the
	 * default size.
	 */
<span class="nc" id="L189">	private boolean useScaling = true;</span>
	/**
	 * A flag for telling if the screen is being actually scaled. Used for
	 * detecting if the ground layers will need triple buffering.
	 */
	private boolean useTripleBuffer;
	/**
	 * Buffer for drawing the ground layers when the screen is scaled.
	 */
	private VolatileImage buffer;

	static {
<span class="nc" id="L201">		offlineIcon = SpriteStore.get().getSprite(&quot;data/gui/offline.png&quot;);</span>
<span class="nc" id="L202">	}</span>

	private AchievementBoxFactory achievementBoxFactory;

	/**
	 * Create a game screen.
	 *
	 * @param client
	 *            The client.
	 */
<span class="nc" id="L212">	public GameScreen(final StendhalClient client) {</span>
<span class="nc" id="L213">		setSize(stendhal.getDisplaySize());</span>
<span class="nc" id="L214">		addComponentListener(new ComponentAdapter() {</span>
			@Override
			public void componentResized(ComponentEvent e) {
<span class="nc" id="L217">				onResized();</span>
<span class="nc" id="L218">			}</span>
		});
		
<span class="nc" id="L221">		gameLayers = client.getStaticGameLayers();</span>

<span class="nc" id="L223">		sw = getWidth();</span>
<span class="nc" id="L224">		sh = getHeight();</span>

<span class="nc" id="L226">		x = 0;</span>
<span class="nc" id="L227">		y = 0;</span>
<span class="nc" id="L228">		svx = -sw / 2;</span>
<span class="nc" id="L229">		svy = -sh / 2;</span>
<span class="nc" id="L230">		dvx = 0;</span>
<span class="nc" id="L231">		dvy = 0;</span>

<span class="nc" id="L233">		speed = 0;</span>

		// Drawing is done in EDT
<span class="nc" id="L236">		texts = Collections.synchronizedList(new LinkedList&lt;RemovableSprite&gt;());</span>
<span class="nc" id="L237">		staticSprites = Collections.synchronizedList(new LinkedList&lt;RemovableSprite&gt;());</span>

		// create ground
<span class="nc" id="L240">		ground = new GroundContainer(client, this, this);</span>

		// register native event handler
<span class="nc" id="L243">		addMouseListener(ground);</span>
<span class="nc" id="L244">		addMouseWheelListener(ground);</span>
<span class="nc" id="L245">		addMouseMotionListener(ground);</span>
		/*
		 * Ignore OS level repaint requests to help systems that create too
		 * many of those. In game DnD is done within AWT so that is not
		 * affected.
		 */
<span class="nc" id="L251">		setIgnoreRepaint(true);</span>
<span class="nc" id="L252">		client.getGameObjects().addGameObjectListener(this);</span>
<span class="nc" id="L253">	}</span>
	
	/**
	 * The canvas can be resized using a split pane, or with window size changes
	 * if screen scaling is used. This is for adjusting the internal parameters
	 * for the change. 
	 */
	private void onResized() {
<span class="nc" id="L261">		Dimension screenSize = stendhal.getDisplaySize();</span>
<span class="nc" id="L262">		sw = getWidth();</span>
<span class="nc" id="L263">		sh = getHeight();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">		if (useScaling) {</span>
<span class="nc" id="L265">			double xScale = sw / screenSize.getWidth();</span>
<span class="nc" id="L266">			double yScale = sh / screenSize.getHeight();</span>
			// Scale by the dimension that needs more scaling
<span class="nc" id="L268">			scale = Math.max(xScale, yScale);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">			if (Math.abs(scale - 1.0) &gt; 0.0001) {</span>
<span class="nc" id="L270">				useTripleBuffer = true;</span>
			} else {
<span class="nc" id="L272">				useTripleBuffer = false;</span>
<span class="nc" id="L273">				buffer = null;</span>
			}
<span class="nc" id="L275">		} else {</span>
<span class="nc" id="L276">			sw = Math.min(sw, screenSize.width);</span>
<span class="nc" id="L277">			sh = Math.min(sh, screenSize.height);</span>
<span class="nc" id="L278">			useTripleBuffer = false;</span>
<span class="nc" id="L279">			buffer = null;</span>
		}
		// Reset the view so that the player is in the center
<span class="nc" id="L282">		calculateView(x, y);</span>
<span class="nc" id="L283">		center();</span>
<span class="nc" id="L284">	}</span>
	
	/**
	 * Set whether the screen should be drawn scaled, or in native resolution.
	 *  
	 * @param useScaling if &lt;code&gt;true&lt;/code&gt; the screen will scale the view
	 * 	will be scaled to fit the screen size, otherwise it will be drawn using
	 * 	the native resolution.
	 */
	public void setUseScaling(boolean useScaling) {
<span class="nc" id="L294">		this.useScaling = useScaling;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		if (!useScaling) {</span>
<span class="nc" id="L296">			scale = 1.0;</span>
<span class="nc" id="L297">			useTripleBuffer = false;</span>
<span class="nc" id="L298">			buffer = null;</span>
		} else {
<span class="nc" id="L300">			onResized();</span>
		}
<span class="nc" id="L302">	}</span>
	
	/**
	 * Check if the screen uses scaling. Note that if the native resolution
	 * is in use, the screen size &lt;b&gt;must not&lt;/b&gt; be allowed to grow larger than
	 * &lt;code&gt;standhal.getScreenSize()&lt;/code&gt;.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the graphics are scaled to the screen size,
	 * 	&lt;code&gt;false&lt;/code&gt; if the native resolution is used
	 */
	public boolean isScaled() {
<span class="nc" id="L313">		return useScaling;</span>
	}

	/**
	 * Set the default [singleton] screen.
	 *
	 * @param screen
	 *            The screen.
	 */
	public static void setDefaultScreen(final GameScreen screen) {
<span class="nc" id="L323">		GameScreen.screen = screen;</span>
<span class="nc" id="L324">	}</span>

	/** @return the GameScreen object. */
	public static GameScreen get() {
<span class="nc" id="L328">		return screen;</span>
	}

	/** @return screen width in world units. */
	private int getViewWidth() {
<span class="nc" id="L333">		return (int) Math.ceil(sw / (SIZE_UNIT_PIXELS * scale));</span>
	}

	/** @return screen height in world units .*/
	private int getViewHeight() {
<span class="nc" id="L338">		return (int) Math.ceil(sh / (SIZE_UNIT_PIXELS * scale));</span>
	}
	
	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#nextFrame()
	 */
	@Override
	public void nextFrame() {
<span class="nc" id="L348">		adjustView();</span>
<span class="nc" id="L349">	}</span>
	
	/**
	 * Get the achievement box factory.
	 * 
	 * @return factory
	 */
	private AchievementBoxFactory getAchievementFactory() {
<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (achievementBoxFactory == null) {</span>
<span class="nc" id="L358">			achievementBoxFactory = new AchievementBoxFactory();</span>
		}
<span class="nc" id="L360">		return achievementBoxFactory;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#addEntity(games.stendhal.client.entity.Entity)
	 */
	@Override
	public void addEntity(final IEntity entity) {
<span class="nc" id="L370">		EntityView&lt;IEntity&gt; view = viewManager.addEntity(entity);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">		if (view != null) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">			if (view instanceof Entity2DView) {</span>
<span class="nc" id="L373">				final Entity2DView&lt;?&gt; inspectable = (Entity2DView&lt;?&gt;) view;</span>
				
<span class="nc" id="L375">				inspectable.setInspector(ground);</span>
			}
<span class="nc bnc" id="L377" title="All 2 branches missed.">			if (entity.isUser()) {</span>
<span class="nc" id="L378">				SwingUtilities.invokeLater(new Runnable() {</span>
					@Override
					public void run() {
<span class="nc" id="L381">						center();</span>
<span class="nc" id="L382">					}</span>
				});
			}
		}
<span class="nc" id="L386">	}</span>
	
	/**
	 * Add a map wide visual effect.
	 * 
	 * @param effect effect renderer
	 */
	public void addEffect(final EffectLayer effect) {
<span class="nc" id="L394">		SwingUtilities.invokeLater(new Runnable() {</span>
			@Override
			public void run() {
<span class="nc" id="L397">				globalEffects.add(effect);	</span>
<span class="nc" id="L398">			}</span>
		});
<span class="nc" id="L400">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#removeEntity(games.stendhal.client.entity.Entity)
	 */
	@Override
	public void removeEntity(final IEntity entity) {
<span class="nc" id="L409">		viewManager.removeEntity(entity);</span>
<span class="nc" id="L410">	}</span>

	/**
	 * Update the view position to center the target position.
	 */
	private void adjustView() {
		/*
		 * Already centered?
		 */
<span class="nc bnc" id="L419" title="All 4 branches missed.">		if ((dvx == 0) &amp;&amp; (dvy == 0)) {</span>
<span class="nc" id="L420">			return;</span>
		}

<span class="nc" id="L423">		final int sx = convertWorldXToScaledScreen(x) - getScreenViewX() + SIZE_UNIT_PIXELS / 2;</span>
<span class="nc" id="L424">		final int sy = convertWorldYToScaledScreen(y) - getScreenViewY() + SIZE_UNIT_PIXELS / 2;</span>

<span class="nc bnc" id="L426" title="All 8 branches missed.">		if ((sx &lt; 0) || (sx &gt;= sw) || (sy &lt; -SIZE_UNIT_PIXELS) || (sy &gt; sh)) {</span>
			/*
			 * If off screen, just center
			 */
<span class="nc" id="L430">			center();</span>
		} else {
<span class="nc" id="L432">			calculatePanningSpeed();</span>

			/*
			 * Moving?
			 */
<span class="nc bnc" id="L437" title="All 2 branches missed.">			if (speed != 0) {</span>
				/*
				 * Not a^2 + b^2 = c^2, but good enough
				 */
<span class="nc" id="L441">				final int scalediv = (Math.abs(dvx) + Math.abs(dvy)) * PAN_SCALE;</span>

<span class="nc" id="L443">				int dx = speed * dvx / scalediv;</span>
<span class="nc" id="L444">				int dy = speed * dvy / scalediv;</span>

				/*
				 * Don't overshoot. Don't stall.
				 */
<span class="nc bnc" id="L449" title="All 2 branches missed.">				if (dvx &lt; 0) {</span>
<span class="nc" id="L450">					dx = MathHelper.clamp(dx, dvx, -1);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">				} else if (dvx &gt; 0) {</span>
<span class="nc" id="L452">					dx = MathHelper.clamp(dx, 1, dvx);</span>
				}

<span class="nc bnc" id="L455" title="All 2 branches missed.">				if (dvy &lt; 0) {</span>
<span class="nc" id="L456">					dy = MathHelper.clamp(dy, dvy, -1);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">				} else if (dvy &gt; 0) {</span>
<span class="nc" id="L458">					dy = MathHelper.clamp(dy, 1, dvy);</span>
				}

				/*
				 * Adjust view
				 */
<span class="nc" id="L464">				svx += dx;</span>
<span class="nc" id="L465">				dvx -= dx;</span>

<span class="nc" id="L467">				svy += dy;</span>
<span class="nc" id="L468">				dvy -= dy;</span>
			}
		}
<span class="nc" id="L471">	}</span>
	
	/**
	 * Calculate the target speed for moving the view position. The farther
	 * away, the faster.
	 */
	private void calculatePanningSpeed() {
<span class="nc" id="L478">		final int dux = dvx / PAN_INERTIA;</span>
<span class="nc" id="L479">		final int duy = dvy / PAN_INERTIA;</span>

<span class="nc" id="L481">		final int tspeed = ((dux * dux) + (duy * duy)) * PAN_SCALE;</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">		if (speed &gt; tspeed) {</span>
<span class="nc" id="L484">			speed = (2 * speed + tspeed) / 3;</span>

			/*
			 * Don't stall
			 */
<span class="nc bnc" id="L489" title="All 4 branches missed.">			if ((dvx != 0) || (dvy != 0)) {</span>
<span class="nc" id="L490">				speed = Math.max(speed, 1);</span>
			}
<span class="nc bnc" id="L492" title="All 2 branches missed.">		} else if (speed &lt; tspeed) {</span>
<span class="nc" id="L493">			speed += 2;</span>
		}
<span class="nc" id="L495">	}</span>

	/**
	 * Updates the target position of the view center.
	 * Prefer top left if the map is smaller than the screen.
	 * 
	 * @param x preferred x of center, if the map is large enough
	 * @param y preferred y of center, if the map is large enough
	 */
	private void calculateView(int x, int y) {
		// Coordinates for a screen centered on player
<span class="nc" id="L506">		int cvx = (int) ((x * SIZE_UNIT_PIXELS) + (SIZE_UNIT_PIXELS / 2) - (sw / 2) / scale);</span>
<span class="nc" id="L507">		int cvy = (int) ((y * SIZE_UNIT_PIXELS) + (SIZE_UNIT_PIXELS / 2) - (sh / 2) / scale);</span>

		/*
		 * Keep the world within the screen view
		 */
<span class="nc" id="L512">		final int maxX = (int) (ww * SIZE_UNIT_PIXELS - sw / scale);</span>
<span class="nc" id="L513">		cvx = MathHelper.clamp(cvx, 0, maxX);</span>
		
<span class="nc" id="L515">		final int maxY = (int) (wh * SIZE_UNIT_PIXELS - sh / scale);</span>
<span class="nc" id="L516">		cvy = MathHelper.clamp(cvy, 0, maxY);</span>
		
		// Differences from center
<span class="nc" id="L519">		dvx = cvx - svx;</span>
<span class="nc" id="L520">		dvy = cvy - svy;</span>
<span class="nc" id="L521">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#center()
	 */
	@Override
	public void center() {
<span class="nc" id="L530">		svx += dvx;</span>
<span class="nc" id="L531">		svy += dvy;</span>

<span class="nc" id="L533">		dvx = 0;</span>
<span class="nc" id="L534">		dvy = 0;</span>

<span class="nc" id="L536">		speed = 0;</span>
<span class="nc" id="L537">	}</span>
	
	@Override
	public void paintImmediately(int x, int y, int w, int h) {
		/*
		 * Try to keep the old screen while the user is switching maps.
		 * 
		 * NOTE: Relies on the repaint() requests to eventually come to this,
		 * so if swing internals change some time in the future, a new solution
		 * may be needed.
		 */
<span class="nc bnc" id="L548" title="All 2 branches missed.">		if (StendhalClient.get().tryAcquireDrawingSemaphore()) {</span>
			try {
<span class="nc" id="L550">				super.paintImmediately(x, y, w, h);</span>
			} finally {
<span class="nc" id="L552">				StendhalClient.get().releaseDrawingSemaphore();</span>
<span class="nc" id="L553">			}</span>
		}
<span class="nc" id="L555">	}</span>
	
	@Override
	public void paintComponent(final Graphics g) {
<span class="nc bnc" id="L559" title="All 2 branches missed.">		if (StendhalClient.get().isInTransfer()) {</span>
			/*
			 * A hack to prevent proper drawing during zone change when the draw
			 * request comes from paintChildren() of the parent. Those are not
			 * caught by the paintImmediately() wrapper. Prevents entity view
			 * images from being initialized before zone coloring is ready.
			 */
<span class="nc" id="L566">			g.setColor(Color.BLACK);</span>
<span class="nc" id="L567">			g.fillRect(0, 0, getWidth(), getHeight());</span>
<span class="nc" id="L568">			return;</span>
		}
		
<span class="nc" id="L571">		Graphics2D g2d = (Graphics2D) g;</span>
		
<span class="nc" id="L573">		Graphics2D graphics = (Graphics2D) g2d.create();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">		if (graphics.getClipBounds() == null) {</span>
<span class="nc" id="L575">			graphics.setClip(0, 0, getWidth(), getHeight());</span>
		}
<span class="nc" id="L577">		int xAdjust = -getScreenViewX();</span>
<span class="nc" id="L578">		int yAdjust = -getScreenViewY();</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">		if (useTripleBuffer) {</span>
			/*
			 * Do the scaling in one pass to avoid artifacts at tile borders.
			 */
<span class="nc" id="L584">			graphics.scale(scale, scale);</span>
<span class="nc" id="L585">			graphics.translate(xAdjust, yAdjust);</span>
<span class="nc" id="L586">			graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span>
<span class="nc" id="L587">			int width = stendhal.getDisplaySize().width;</span>
<span class="nc" id="L588">			int height = stendhal.getDisplaySize().height;</span>
			do {
<span class="nc" id="L590">				GraphicsConfiguration gc = getGraphicsConfiguration();</span>
<span class="nc bnc" id="L591" title="All 4 branches missed.">				if ((buffer == null) || (buffer.validate(gc) == VolatileImage.IMAGE_INCOMPATIBLE)) {</span>
<span class="nc" id="L592">					buffer = createVolatileImage(width, height);</span>
				}
<span class="nc" id="L594">				Graphics2D gr = buffer.createGraphics();</span>
<span class="nc" id="L595">				gr.setClip(0, 0, width, height);</span>
<span class="nc" id="L596">				renderScene(gr, xAdjust, yAdjust);</span>
<span class="nc" id="L597">				graphics.drawImage(buffer, -xAdjust, -yAdjust, null);</span>
<span class="nc" id="L598">				gr.dispose();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			} while (buffer.contentsLost());</span>
<span class="nc" id="L600">		} else {</span>
<span class="nc" id="L601">			renderScene(graphics, xAdjust, yAdjust);</span>
		}
		
		// Don't scale text to keep it readable
<span class="nc" id="L605">		drawText(g2d);</span>

<span class="nc" id="L607">		paintOffLineIfNeeded(g2d);</span>
<span class="nc" id="L608">		graphics.dispose();</span>
<span class="nc" id="L609">	}</span>
	
	/**
	 * Render the scalable parts of the screen.
	 * 
	 * @param g graphics
	 * @param xAdjust x coordinate offset
	 * @param yAdjust y coordinate offset
	 */
	private void renderScene(Graphics2D g, int xAdjust, int yAdjust) {
		// Adjust the graphics object so that the drawn objects do not need to
		// know about converting the position to screen
<span class="nc" id="L621">		g.translate(xAdjust, yAdjust);</span>
		
		// Restrict the drawn area by the clip bounds. Smaller than gamescreen
		// draw requests can come for example from dragging items
<span class="nc" id="L625">		int startTileX = Math.max(0, (int) getViewX());</span>
<span class="nc" id="L626">		int startTileY = Math.max(0, (int) getViewY());</span>
		
<span class="nc" id="L628">		Rectangle clip = g.getClipBounds();</span>
<span class="nc" id="L629">		startTileX = Math.max(startTileX, clip.x / IGameScreen.SIZE_UNIT_PIXELS);</span>
<span class="nc" id="L630">		startTileY = Math.max(startTileY, clip.y / IGameScreen.SIZE_UNIT_PIXELS);</span>
<span class="nc" id="L631">		int layerWidth = getViewWidth();</span>
<span class="nc" id="L632">		int layerHeight = getViewHeight();</span>
		// +2 is needed to ensure the drawn area is covered by the tiles
<span class="nc" id="L634">		layerWidth = Math.min(layerWidth, clip.width / IGameScreen.SIZE_UNIT_PIXELS) + 2;</span>
<span class="nc" id="L635">		layerHeight = Math.min(layerHeight, clip.height / IGameScreen.SIZE_UNIT_PIXELS) + 2;</span>

<span class="nc" id="L637">		drawEndOfTheWorld(g, xAdjust, yAdjust);</span>
<span class="nc" id="L638">		viewManager.prepareViews(clip);</span>
		
<span class="nc" id="L640">		final String set = gameLayers.getAreaName();</span>
<span class="nc" id="L641">		gameLayers.drawLayers(g, set, &quot;floor_bundle&quot;, startTileX,</span>
				startTileY, layerWidth, layerHeight, &quot;blend_ground&quot;, &quot;0_floor&quot;,
				&quot;1_terrain&quot;, &quot;2_object&quot;);
		
<span class="nc" id="L645">		viewManager.draw(g);</span>

<span class="nc" id="L647">		gameLayers.drawLayers(g, set, &quot;roof_bundle&quot;, startTileX,</span>
				startTileY, layerWidth, layerHeight, &quot;blend_roof&quot;, &quot;3_roof&quot;,
				&quot;4_roof_add&quot;);
<span class="nc" id="L650">		gameLayers.drawWeather(g, startTileX, startTileY, layerWidth, layerHeight);</span>
		
		// Draw the top portion screen entities (such as HP/title bars).
<span class="nc" id="L653">		viewManager.drawTop(g);</span>
		// Effects get drawn even above title bars, so that darkening and such work
		// as expected
<span class="nc" id="L656">		Iterator&lt;EffectLayer&gt; it = globalEffects.iterator();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">		while (it.hasNext()) {</span>
<span class="nc" id="L658">			EffectLayer eff = it.next();</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">			if (!eff.isExpired()) {</span>
<span class="nc" id="L660">				eff.draw(g, startTileX, startTileY, layerWidth, layerHeight);</span>
			} else {
<span class="nc" id="L662">				it.remove();</span>
			}
<span class="nc" id="L664">		}</span>
<span class="nc" id="L665">	}</span>
	
	/**
	 * Fill with black the areas outside the map.
	 * 
	 * @param g graphics
	 * @param xAdjust x position of the screen
	 * @param yAdjust y position of the screen
	 */
	private void drawEndOfTheWorld(Graphics g, int xAdjust, int yAdjust) {
		// End of the world (map falls short of the view)?
<span class="nc bnc" id="L676" title="All 2 branches missed.">		if (xAdjust &gt; 0) {</span>
<span class="nc" id="L677">			g.setColor(Color.BLACK);</span>
<span class="nc" id="L678">			g.fillRect(0, 0, xAdjust, sh);</span>
		}

<span class="nc bnc" id="L681" title="All 2 branches missed.">		if (yAdjust &gt; 0) {</span>
<span class="nc" id="L682">			g.setColor(Color.BLACK);</span>
<span class="nc" id="L683">			g.fillRect(0, 0, sw, yAdjust);</span>
		}

<span class="nc" id="L686">		int tmpY = yAdjust + convertWorldToPixelUnits(wh);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">		if (tmpY &lt; sh) {</span>
<span class="nc" id="L688">			g.setColor(Color.BLACK);</span>
<span class="nc" id="L689">			g.fillRect(svx, tmpY, sw, sh);</span>
		}

<span class="nc" id="L692">		int tmpX = yAdjust + convertWorldToPixelUnits(ww);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">		if (tmpX &lt; sw) {</span>
<span class="nc" id="L694">			g.setColor(Color.BLACK);</span>
<span class="nc" id="L695">			g.fillRect(tmpX, svy, sw, sh);</span>
		}
<span class="nc" id="L697">	}</span>
	
	/**
	 * Draw the offline indicator, blinking, if the client is offline.
	 * 
	 * @param g graphics
	 */
	private void paintOffLineIfNeeded(Graphics g) {
		// Offline
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (offline) {</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">			if (blinkOffline &gt; 0) {</span>
<span class="nc" id="L708">				offlineIcon.draw(g, getWidth() - offlineIcon.getWidth() - OFFLINE_MARGIN,</span>
						getHeight() - offlineIcon.getHeight() - OFFLINE_MARGIN);
			}

			// Show for 20 screen draws, hide for 12
<span class="nc bnc" id="L713" title="All 2 branches missed.">			if (blinkOffline &lt; -10) {</span>
<span class="nc" id="L714">				blinkOffline = 20;</span>
			} else {
<span class="nc" id="L716">				blinkOffline--;</span>
			}
		}
<span class="nc" id="L719">	}</span>

	/**
	 * Draw the screen text bubbles.
	 * 
	 * @param g2d destination graphics
	 */
	private void drawText(final Graphics2D g2d) {
		/*
		 * Text objects know their original placement relative to the screen,
		 * not to the map. Pass them a shifted coordinate system. 
		 */
<span class="nc" id="L731">		g2d.translate(-getScreenViewX(), -getScreenViewY());</span>
		
<span class="nc" id="L733">		synchronized (texts) {</span>
<span class="nc" id="L734">			Iterator&lt;RemovableSprite&gt; it = texts.iterator();</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L736">				RemovableSprite text = it.next();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">				if (!text.shouldBeRemoved()) {</span>
<span class="nc" id="L738">					text.draw(g2d);</span>
				} else {
<span class="nc" id="L740">					it.remove();</span>
				}
<span class="nc" id="L742">			}</span>
<span class="nc" id="L743">		}</span>
		
		// Restore the coordinates
<span class="nc" id="L746">		g2d.translate(getScreenViewX(), getScreenViewY());</span>
		// These are anchored to the screen, so they can use the usual proper
		// coordinates.
<span class="nc" id="L749">		synchronized (staticSprites) {</span>
<span class="nc" id="L750">			Iterator&lt;RemovableSprite&gt; it = staticSprites.iterator();</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L752">				RemovableSprite text = it.next();</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">				if (!text.shouldBeRemoved()) {</span>
<span class="nc" id="L754">					text.draw(g2d);</span>
				} else {
<span class="nc" id="L756">					it.remove();</span>
				}
<span class="nc" id="L758">			}</span>
<span class="nc" id="L759">		}</span>
<span class="nc" id="L760">	}</span>

	/**
	 * Get the view X world coordinate.
	 *
	 * @return The X coordinate of the left side.
	 */
	private double getViewX() {
<span class="nc" id="L768">		return (double) getScreenViewX() / SIZE_UNIT_PIXELS;</span>
	}

	/**
	 * Get the view Y world coordinate.
	 *
	 * @return The Y coordinate of the left side.
	 */
	private double getViewY() {
<span class="nc" id="L777">		return (double) getScreenViewY() / SIZE_UNIT_PIXELS;</span>
	}

	/**
	 * Sets the world size.
	 *
	 * @param width The world width.
	 * @param height The height width.
	 */
	private void setMaxWorldSize(final double width, final double height) {
<span class="nc" id="L787">		ww = (int) width;</span>
<span class="nc" id="L788">		wh = (int) height;</span>
<span class="nc" id="L789">		calculateView(x, y);</span>
<span class="nc" id="L790">		center();</span>
<span class="nc" id="L791">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#setOffline(boolean)
	 */
	@Override
	public void setOffline(final boolean offline) {
<span class="nc" id="L800">		this.offline = offline;</span>
<span class="nc" id="L801">	}</span>
	
	/**
	 * Adds a text bubble at a give position.
	 * 
	 * @param sprite 
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param textLength length of the text in characters
	 */
	public void addTextBox(Sprite sprite, double x, double y, int textLength) {
<span class="nc" id="L812">		int sx = convertWorldXToScaledScreen(x);</span>
<span class="nc" id="L813">		int sy = convertWorldYToScaledScreen(y);</span>
		// Point alignment: left, bottom
<span class="nc" id="L815">		sy -= sprite.getHeight();</span>

<span class="nc" id="L817">		sx = keepSpriteOnMapX(sprite, sx);</span>
<span class="nc" id="L818">		sy = keepSpriteOnMapY(sprite, sy);</span>
		
		/*
		 * Adjust the position of boxes placed at the same point to make it
		 * clear for the player there are more than one.
		 */
<span class="nc" id="L824">		boolean found = true;</span>
<span class="nc" id="L825">		int tries = 0;</span>

<span class="nc bnc" id="L827" title="All 2 branches missed.">		while (found) {</span>
<span class="nc" id="L828">			found = false;</span>

<span class="nc" id="L830">			synchronized (texts) {</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">				for (final RemovableSprite item : texts) {</span>
<span class="nc bnc" id="L832" title="All 4 branches missed.">					if ((item.getX() == sx) &amp;&amp; (item.getY() == sy)) {</span>
<span class="nc" id="L833">						found = true;</span>
<span class="nc" id="L834">						sy += SIZE_UNIT_PIXELS / 2;</span>
<span class="nc" id="L835">						sy = keepSpriteOnMapY(sprite, sy);</span>
<span class="nc" id="L836">						break;</span>
					}
<span class="nc" id="L838">				}</span>
<span class="nc" id="L839">			}</span>
			
<span class="nc" id="L841">			tries++;</span>
			// give up, if no location found in a reasonable amount of tries
<span class="nc bnc" id="L843" title="All 2 branches missed.">			if (tries &gt; 20) {</span>
<span class="nc" id="L844">				break;</span>
			}
		}

<span class="nc" id="L848">		texts.add(new RemovableSprite(sprite, sx, sy, Math.max(</span>
				RemovableSprite.STANDARD_PERSISTENCE_TIME, textLength
						* RemovableSprite.STANDARD_PERSISTENCE_TIME / 50)));
<span class="nc" id="L851">	}</span>

	/**
	 * Try to keep a sprite on the map. Adjust the Y coordinate.
	 * 
	 * @param sprite sprite to keep on the map
	 * @param sy suggested Y coordinate on screen
	 * @return new Y coordinate
	 */
	private int keepSpriteOnMapY(Sprite sprite, int sy) {
<span class="nc" id="L861">		sy = Math.max(sy, 0);</span>
		/*
		 * Allow placing beyond the map, but only if the area is on the screen.
		 * Do not try to adjust the coordinates if the world size is not known
		 * yet (as in immediately after a zone change)
		 */
<span class="nc bnc" id="L867" title="All 2 branches missed.">		if (wh != 0) {</span>
<span class="nc" id="L868">			sy = Math.min(sy, Math.max(getHeight() + svy,</span>
					convertWorldYToScaledScreen(wh)) - sprite.getHeight());
		}
<span class="nc" id="L871">		return sy;</span>
	}

	/**
	 * Try to keep a sprite on the map. Adjust the X coordinate.
	 * 
	 * @param sprite sprite to keep on the map
	 * @param sx suggested X coordinate on screen
	 * @return new X coordinate
	 */
	private int keepSpriteOnMapX(Sprite sprite, int sx) {
<span class="nc" id="L882">		sx = Math.max(sx, 0);</span>
		/*
		 * Allow placing beyond the map, but only if the area is on the screen.
		 * Do not try to adjust the coordinates if the world size is not known
		 * yet (as in immediately after a zone change)
		 */
<span class="nc bnc" id="L888" title="All 2 branches missed.">		if (ww != 0) {</span>
<span class="nc" id="L889">			sx = Math.min(sx, Math.max(getWidth() + svx, convertWorldXToScaledScreen(ww)) - sprite.getWidth());</span>
		}
<span class="nc" id="L891">		return sx;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#removeText(games.stendhal.client.gui.j2d.Text)
	 */
	@Override
	public void removeText(final RemovableSprite entity) {
<span class="nc" id="L901">		texts.remove(entity);</span>
<span class="nc" id="L902">		staticSprites.remove(entity);</span>
<span class="nc" id="L903">	}</span>

	/**
	 * Remove all map objects.
	 */
	private void removeAllObjects() {
<span class="nc" id="L909">		logger.debug(&quot;CLEANING screen object list&quot;);</span>
<span class="nc" id="L910">		texts.clear();</span>
		// staticSprites contents are not zone specific, so don't clear those
<span class="nc" id="L912">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#clearTexts()
	 */
	@Override
	public void clearTexts() {
<span class="nc" id="L921">		texts.clear();</span>
<span class="nc" id="L922">		staticSprites.clear();</span>
<span class="nc" id="L923">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#getEntityViewAt(double, double)
	 */
	@Override
	public EntityView&lt;?&gt; getEntityViewAt(final double x, final double y) {
<span class="nc" id="L932">		final int sx = convertWorldToPixelUnits(x);</span>
<span class="nc" id="L933">		final int sy = convertWorldToPixelUnits(y);</span>
<span class="nc" id="L934">		return viewManager.getEntityViewAt(x, y, sx, sy);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#getMovableEntityViewAt(double,
	 *      double)
	 */
	@Override
	public EntityView&lt;?&gt; getMovableEntityViewAt(final double x, final double y) {
<span class="nc" id="L945">		final int sx = convertWorldToPixelUnits(x);</span>
<span class="nc" id="L946">		final int sy = convertWorldToPixelUnits(y);</span>
<span class="nc" id="L947">		return viewManager.getMovableEntityViewAt(x, y, sx, sy);</span>
	}

	/*
	 * (non-Javadoc)
	 * @see games.stendhal.client.IGameScreen#getTextAt(int, int)
	 */
	@Override
	public RemovableSprite getTextAt(final int x, final int y) {
		// staticTexts are drawn on top of the others; those in the end of the
		// lists are above preceding texts
<span class="nc" id="L958">		synchronized (staticSprites) {</span>
<span class="nc" id="L959">			final ListIterator&lt;RemovableSprite&gt; it = staticSprites.listIterator(staticSprites.size());</span>

<span class="nc bnc" id="L961" title="All 2 branches missed.">			while (it.hasPrevious()) {</span>
<span class="nc" id="L962">				final RemovableSprite text = it.previous();</span>

<span class="nc bnc" id="L964" title="All 2 branches missed.">				if (text.getArea().contains(x, y)) {</span>
<span class="nc" id="L965">					return text;</span>
				}
<span class="nc" id="L967">			}</span>
<span class="nc" id="L968">		}</span>
		// map pixel coordinates
<span class="nc" id="L970">		final int tx = x + svx;</span>
<span class="nc" id="L971">		final int ty = y + svy;</span>
<span class="nc" id="L972">		synchronized (texts) {</span>
<span class="nc" id="L973">			final ListIterator&lt;RemovableSprite&gt; it = texts.listIterator(texts.size());</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">			while (it.hasPrevious()) {</span>
<span class="nc" id="L976">				final RemovableSprite text = it.previous();</span>

<span class="nc bnc" id="L978" title="All 2 branches missed.">				if (text.getArea().contains(tx, ty)) {</span>
<span class="nc" id="L979">					return text;</span>
				}
<span class="nc" id="L981">			}</span>
<span class="nc" id="L982">		}</span>

<span class="nc" id="L984">		return null;</span>
	}
	
	/**
	 * Convert a world x coordinate to &lt;em&gt;raw&lt;/em&gt; (native resolution)
	 * screen x coordinate.
	 * 
	 * @param x world x coordinate
	 * @return pixel x coordinate on the screen
	 */
	private int convertWorldXToScaledScreen(double x) {
<span class="nc" id="L995">		return (int) (convertWorldToPixelUnits(x - svx / (double) SIZE_UNIT_PIXELS) * scale) + svx;</span>
	}
	
	/**
	 * Convert a world y coordinate to &lt;em&gt;raw&lt;/em&gt; (native resolution)
	 * screen y coordinate.
	 * 
	 * @param y world y coordinate
	 * @return pixel y coordinate on the screen
	 */
	private int convertWorldYToScaledScreen(double y) {
<span class="nc" id="L1006">		return (int) (convertWorldToPixelUnits(y - svy / (double) SIZE_UNIT_PIXELS) * scale) + svy;</span>
	}

	/**
	 * Convert a world unit value to pixel units.
	 *
	 * @param w World value.
	 *
	 * @return A screen value (in pixels).
	 */
	private int convertWorldToPixelUnits(final double w) {
<span class="nc" id="L1017">		return (int) (w * SIZE_UNIT_PIXELS);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#convertScreenViewToWorld(java.awt.Point)
	 */
	@Override
	public Point2D convertScreenViewToWorld(final Point p) {
<span class="nc" id="L1027">		return convertScreenViewToWorld(p.x, p.y);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#convertScreenViewToWorld(int, int)
	 */
	@Override
	public Point2D convertScreenViewToWorld(final int x, final int y) {
<span class="nc" id="L1037">		return new Point.Double(((x / scale) + getScreenViewX()) / SIZE_UNIT_PIXELS,</span>
				((y / scale) + getScreenViewY()) / SIZE_UNIT_PIXELS);
	}

	/**
	 * Get the view X screen coordinate.
	 *
	 * @return The X coordinate of the left side.
	 */
	private int getScreenViewX() {
<span class="nc" id="L1047">		return svx;</span>
	}

	/**
	 * Get the view Y screen coordinate.
	 *
	 * @return The Y coordinate of the left side.
	 */
	private int getScreenViewY() {
<span class="nc" id="L1056">		return svy;</span>
	}

	//
	// PositionChangeListener
	//

	/*
	 * (non-Javadoc)
	 *
	 * @see games.stendhal.client.IGameScreen#positionChanged(double, double)
	 */
	@Override
	public void positionChanged(final double x, final double y) {
<span class="nc" id="L1070">		final int ix = (int) x;</span>
<span class="nc" id="L1071">		final int iy = (int) y;</span>

		/*
		 * Save CPU cycles
		 */
<span class="nc bnc" id="L1076" title="All 4 branches missed.">		if ((ix != this.x) || (iy != this.y)) {</span>
<span class="nc" id="L1077">			this.x = ix;</span>
<span class="nc" id="L1078">			this.y = iy;</span>

<span class="nc" id="L1080">			calculateView(ix, iy);</span>
		}
<span class="nc" id="L1082">	}</span>
	
	@Override
	public void dropEntity(IEntity entity, int amount, Point point) {
		// Just pass it to the ground container
<span class="nc" id="L1087">		ground.dropEntity(entity, amount, point);</span>
<span class="nc" id="L1088">	}</span>

	/**
	 * Draw a box for a reached achievement with given title, description and
	 * category.
	 * 
	 * @param title title of the achievement
	 * @param description achievement description
	 * @param category achievement category
	 */
	public void addAchievementBox(String title, String description,
			String category) {
<span class="nc" id="L1100">		final Sprite sprite = getAchievementFactory().createAchievementBox(title, description, category);</span>
		
		/*
		 * Keep the achievements a bit longer on the screen. They do not leave
		 * a line to the chat log, so we give the player a bit more time to
		 * admire her prowess.
		 */
<span class="nc" id="L1107">		addStaticSprite(sprite, 2 * RemovableSprite.STANDARD_PERSISTENCE_TIME, 0);</span>
<span class="nc" id="L1108">	}</span>
	
	/**
	 * Add a text box bound to the bottom of the screen, with a timeout
	 * dependent on the text length.
	 * 
	 * @param sprite text box sprite
	 * @param textLength text length in characters
	 * @param priority importance of the message to keep it above others
	 */
	public void addStaticText(Sprite sprite, int textLength, int priority) {
<span class="nc" id="L1119">		addStaticSprite(sprite,</span>
				Math.max(RemovableSprite.STANDARD_PERSISTENCE_TIME,
				textLength * RemovableSprite.STANDARD_PERSISTENCE_TIME / 50),
				priority);
<span class="nc" id="L1123">	}</span>
	
	/**
	 * Add a sprite anchored to the screen bottom.
	 * 
	 * @param sprite sprite
	 * @param persistTime time to stay on the screen before being automatically
	 * 	removed
	 *  @param priority importance of the message to keep it above others
	 */
	private void addStaticSprite(Sprite sprite, long persistTime, int priority) {
<span class="nc" id="L1134">		int x = (getWidth() - sprite.getWidth()) / 2;</span>
<span class="nc" id="L1135">		int y = getHeight() - sprite.getHeight();</span>
<span class="nc" id="L1136">		RemovableSprite msg = new RemovableSprite(sprite, x, y, persistTime);</span>
<span class="nc" id="L1137">		msg.setPriority(priority);</span>
<span class="nc" id="L1138">		staticSprites.add(msg);</span>
<span class="nc" id="L1139">		Collections.sort(staticSprites);</span>
<span class="nc" id="L1140">	}</span>
	
	@Override
	public void onZoneUpdate(Zone zone) {
<span class="nc" id="L1144">		viewManager.resetViews();</span>
<span class="nc" id="L1145">	}</span>

	@Override
	public void onZoneChange(Zone zone) {
<span class="nc" id="L1149">		removeAllObjects();</span>
<span class="nc" id="L1150">		SwingUtilities.invokeLater(new Runnable() {</span>
			@Override
			public void run() {
<span class="nc" id="L1153">				globalEffects.clear();	</span>
<span class="nc" id="L1154">			}</span>
		});
<span class="nc" id="L1156">	}</span>
	
	@Override
	public void onZoneChangeCompleted(final Zone zone) {
<span class="nc" id="L1160">		SwingUtilities.invokeLater(new Runnable() {</span>
			@Override
			public void run() {
<span class="nc" id="L1163">				setMaxWorldSize(zone.getWidth(), zone.getHeight());</span>
<span class="nc" id="L1164">			}</span>
		});
		// Change layers here ?
<span class="nc" id="L1167">	}</span>

	/**
	 * Switch to spell casting triggered by a key event.
	 * 
	 * @param e triggering key event
	 */
	public void switchToSpellCasting(KeyEvent e) {
<span class="nc" id="L1175">		RPObject spell = findSpell(e);</span>
		// only if a spell was found switch to spell casting
		// i.e. Ctrl + 9 was issued, but player only has 8 spell would return null
<span class="nc bnc" id="L1178" title="All 2 branches missed.">		if (spell != null) {</span>
<span class="nc" id="L1179">			switchToSpellCastingState(spell);</span>
		}
<span class="nc" id="L1181">	}</span>

	/**
	 * Switch to spell casting with an already chosen spell.
	 * 
	 * @param spell the chosen spell
	 */
	public void switchToSpellCastingState(RPObject spell) {
<span class="nc" id="L1189">		SpellCastingGroundContainerMouseState newState = new SpellCastingGroundContainerMouseState(this.ground);</span>
<span class="nc" id="L1190">		this.ground.setNewMouseHandlerState(newState);</span>
<span class="nc" id="L1191">		newState.setSpell(spell);</span>
<span class="nc" id="L1192">	}</span>
	
	/**
	 * Find spell corresponding to a key.
	 * 
	 * @param e key
	 * @return spell, or &lt;code&gt;null&lt;/code&gt; if the key does not match any spell
	 */
	private RPObject findSpell(KeyEvent e) {
<span class="nc" id="L1201">		RPObject player = StendhalClient.get().getPlayer();</span>
<span class="nc" id="L1202">		Integer position = keyEventMapping.get(e.getKeyCode());</span>
<span class="nc" id="L1203">		RPSlot slot = player.getSlot(&quot;spells&quot;);</span>
<span class="nc" id="L1204">		Integer counter = Integer.valueOf(1);</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">		for (RPObject spell : slot) {</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">			if (counter.equals(position)) {</span>
<span class="nc" id="L1207">				return spell;</span>
			}
<span class="nc" id="L1209">			counter = Integer.valueOf(counter.intValue() + 1);</span>
<span class="nc" id="L1210">		}</span>
<span class="nc" id="L1211">		return null;</span>
	}

	@Override
	public boolean canAccept(IEntity entity) {
<span class="nc bnc" id="L1216" title="All 4 branches missed.">		if ((entity instanceof Item) || (entity instanceof Corpse)) {</span>
<span class="nc" id="L1217">			return true;</span>
		}
<span class="nc" id="L1219">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>