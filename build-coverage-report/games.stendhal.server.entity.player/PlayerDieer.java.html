<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PlayerDieer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity.player</a> &gt; <span class="el_source">PlayerDieer.java</span></div><h1>PlayerDieer.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                   (C) Copyright 2003-2010 - Stendhal                    *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.server.entity.player;

import games.stendhal.common.NotificationType;
import games.stendhal.common.Rand;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.server.core.engine.ItemLogger;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.Killer;
import games.stendhal.server.entity.PassiveEntity;
import games.stendhal.server.entity.creature.Pet;
import games.stendhal.server.entity.creature.RaidCreature;
import games.stendhal.server.entity.creature.Sheep;
import games.stendhal.server.entity.item.Corpse;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.item.RingOfLife;
import games.stendhal.server.entity.item.StackableItem;
import games.stendhal.server.entity.slot.Slots;

import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import marauroa.common.Pair;
import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;

import org.apache.log4j.Logger;

/**
 * Handles death of players.
 *
 * @author hendrik
 */
public class PlayerDieer {
	/** The name of the zone placed in when killed. */
	public static final String DEFAULT_DEAD_AREA = &quot;int_afterlife&quot;;

<span class="fc" id="L53">	private static final Logger logger = Logger.getLogger(PlayerDieer.class);</span>
	private final Player player;

	private List&lt;Item&gt; drops;
	// it is not crazy to have a number of drops as well as a drops list
	// because there will be one entry  in the drops list for each item
	// but could be more than one stackable item per entry
	// i need the number of drops for saying it/them at the end.
	private int numberOfDrops;

<span class="fc" id="L63">	public PlayerDieer(final Player player) {</span>
<span class="fc" id="L64">		this.player = player;</span>
<span class="fc" id="L65">	}</span>


	public void onDead(final Killer killer) {
<span class="fc" id="L69">		player.put(&quot;dead&quot;, &quot;&quot;);</span>
<span class="fc" id="L70">		logger.debug(&quot;ondeadstart&quot;);</span>
<span class="fc" id="L71">		abondonPetsAndSheep();</span>

<span class="fc" id="L73">		player.getStatusList().removeAll();</span>

<span class="fc" id="L75">		double penaltyFactor = 1.0;</span>

		// only lose skills if creature is a spawned creature and not one from /summon or Plague
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">		if (!(killer instanceof RaidCreature)) {</span>
<span class="fc" id="L79">			logger.debug(&quot;noraidcreature&quot;);</span>
<span class="fc" id="L80">			logger.debug(&quot;player karma is &quot; + player.getKarma());</span>
   			double karma;
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">			if (player.isBadBoy()) {</span>
			    // don't allow PKers to use good karma to help against death penalty
			    // if they had positive karma, this will return 0 (i.e. no change to the normal death penalty)
<span class="nc" id="L85">				karma = player.useKarma(-100.0, 0.0);</span>
			} else {
<span class="fc" id="L87">				karma = player.useKarma(-100.0, 100.0);</span>
			}
<span class="fc" id="L89">			logger.debug(&quot;karma selected: &quot; + karma);</span>
			// scale down to between -1 and 1, as the penalty factor is scaled to 1 (we will also need to scale again before adding to penaltyFactor)
<span class="fc" id="L91">			karma = karma / 100.0;</span>

<span class="fc" id="L93">			final List&lt;RingOfLife&gt; ringList = player.getAllEquippedWorkingRingOfLife();</span>
			// A very unlucky player might drop the ring too
<span class="fc bfc" id="L95" title="All 2 branches covered.">			for (Item item : drops) {</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">				if (item instanceof RingOfLife) {</span>
<span class="fc" id="L97">					RingOfLife ring = (RingOfLife) item;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">					if (!ring.isBroken()) {</span>
<span class="fc" id="L99">						ringList.add((RingOfLife) item);</span>
					}
				}
<span class="fc" id="L102">			}</span>

<span class="fc" id="L104">			logger.debug(&quot;ringlist &quot; + ringList);</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">			if (ringList.isEmpty()) {</span>
			    // if player has positive karma, then they will lose between 0% and 10% skills - less than if karma was ignored
			    // if player has negative karma, they lose between 10% and 20% skills - more than if karma was ignored
<span class="fc" id="L109">			    penaltyFactor = 0.9 + (karma / 10.0);</span>
<span class="fc" id="L110">			    logger.debug(&quot;penaltyFactor: &quot; + penaltyFactor);</span>
			} else {
			    // if player has positive karma, then they will lose between 0% and 1% skills - less than if karma ignored
			    // if player has negative karma, they lose between 1% and 2% skills - more than if karma was ignored
				// Use up a random ring
<span class="fc" id="L115">				Rand.rand(ringList).damage();</span>
<span class="fc" id="L116">				penaltyFactor = 0.99 + (karma / 100.0);</span>
			}

			// round to 3 decimal places (i.e as a percentage it will be one decimal place)
<span class="fc" id="L120">			penaltyFactor = (double) Math.round(penaltyFactor * 1000) / 1000;</span>

			// note on karma: players can only hit the maximums of these ranges if they themselves had over 100 Karma, less than -100 karma, respectively.
			// and even then, some chance will mean they are not guaranteed to hit the maximum
			// (just because we call useKarma(-100.0,100.0) doesn't mean that a player with over 100.0 karma will get 100.0 used. He is just more likely to get 100.0 used.)

			// Using subXP() instead of using setXP() directly to get the level
			// checks correctly done. setXP() can not do the magic unlike setAtkXP()
			// &amp; setDEFXP() because it's used by creatures as well
<span class="fc" id="L129">			player.subXP((int) Math.round(player.getXP() * (1 - penaltyFactor)));</span>
<span class="fc" id="L130">			player.setAtkXP((int) Math.round(player.getAtkXP() * penaltyFactor));</span>
<span class="fc" id="L131">			player.setDefXP((int) Math.round(player.getDefXP() * penaltyFactor));</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">			if (killer instanceof Player) {</span>
<span class="fc" id="L133">								Player playerKiller = (Player) killer;</span>
<span class="fc" id="L134">								handlePlayerKiller(playerKiller);</span>
			}
<span class="fc" id="L136">			player.update();</span>
		}

		// this is for telling the player what % of their old value, the skills are now. so, some loss of precision is ok
		// but we don't want to say it is 100% when it is not.
		final String skillPercentage;
<span class="pc bpc" id="L142" title="1 of 4 branches missed.">		if (penaltyFactor &gt; 0.99 &amp;&amp; penaltyFactor &lt; 1) {</span>
<span class="fc" id="L143">			skillPercentage = String.format(&quot;%.1f&quot;,penaltyFactor * 100.0);</span>
		} else {
<span class="fc" id="L145">			skillPercentage = String.format(&quot;%.0f&quot;,penaltyFactor * 100.0);</span>
		}
<span class="fc" id="L147">		player.setHP(player.getBaseHP());</span>

<span class="fc" id="L149">		player.returnToOriginalOutfit();</span>

		// After a tangle with the grim reaper, give some karma,
		// but limit abuse
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		if (player.getKarma() &lt; 75.0) {</span>
<span class="fc" id="L154">			player.addKarma(100.0);</span>
		}

<span class="fc" id="L157">		String zoneinfo = player.getZone().describe();</span>
<span class="fc" id="L158">		String locationmsg = &quot;You died &quot; + zoneinfo;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">		if(!player.getZone().isInterior()) {</span>
			// only tell the more precise location inside the zone if it's not an interior
<span class="nc" id="L161">			int x = player.getZone().getWidth();</span>
<span class="nc" id="L162">			int y = player.getZone().getHeight();</span>
<span class="nc" id="L163">			int lastx = player.getX();</span>
<span class="nc" id="L164">			int lasty = player.getY();</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">			String northsouth = (lasty &lt; y/3) ? &quot;north &quot; : ( (lasty &gt; 2*y/3) ? &quot;south &quot; : &quot;&quot;);</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">			String eastwest = (lastx &lt; x/3) ? &quot;west&quot; : ( (lastx &gt; 2*x/3) ? &quot;east&quot; : &quot;&quot;);</span>
<span class="nc" id="L167">			String pos = (northsouth + eastwest);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">			if (pos.equals(&quot;&quot;)) {</span>
<span class="nc" id="L169">				pos = &quot;center&quot;;</span>
			}
<span class="nc" id="L171">			locationmsg += &quot; in the &quot; + pos + &quot; part&quot;;</span>
		}
<span class="fc" id="L173">		respawnInAfterLife();</span>

<span class="fc" id="L175">		player.sendPrivateText(NotificationType.INFORMATION, locationmsg +&quot;.&quot;);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (numberOfDrops &gt; 0) {</span>
<span class="fc" id="L177">			Collection&lt;String&gt; strings = new LinkedList&lt;String&gt;();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">			for (Item item : this.drops) {</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">				if (item instanceof StackableItem) {</span>
<span class="nc" id="L180">					StackableItem si = (StackableItem) item;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">					if (si.getQuantity() &gt; 1) {</span>
<span class="nc" id="L182">						StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L183">						sb.append(si.getQuantity());</span>
<span class="nc" id="L184">						sb.append(&quot; &quot;);</span>
<span class="nc" id="L185">						sb.append(Grammar.plural(si.getName()));</span>
<span class="nc" id="L186">						strings.add(sb.toString());</span>
					}
<span class="nc bnc" id="L188" title="All 2 branches missed.">					if (si.getQuantity() == 1) {</span>
<span class="nc" id="L189">						strings.add(Grammar.a_noun(si.getName()));</span>
					}
<span class="nc" id="L191">				} else {</span>
<span class="fc" id="L192">					strings.add(Grammar.a_noun(item.getName()));</span>
				}
<span class="fc" id="L194">			}</span>
<span class="fc" id="L195">			player.sendPrivateText(NotificationType.NEGATIVE, &quot;Your corpse contains &quot; + Grammar.enumerateCollection(strings) + &quot;, but you may be able to retrieve &quot; + Grammar.itthem(numberOfDrops) + &quot;. Your skills are &quot; + skillPercentage + &quot;% of their old value.&quot;);</span>
<span class="fc" id="L196">		} else {</span>
<span class="fc" id="L197">			player.sendPrivateText(NotificationType.POSITIVE, &quot;You were lucky and dropped no items when you died. Your skills are &quot; + skillPercentage + &quot;% of their old value.&quot;);</span>
		}
<span class="fc" id="L199">	}</span>

	private void handlePlayerKiller(final Player playerKiller) {
		// Do not punish on suicide. (That happen at least with club of thorns).
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">		if (playerKiller != player) {</span>
<span class="fc" id="L204">			playerKiller.setLastPlayerKill(System.currentTimeMillis());</span>
		}
<span class="fc" id="L206">	}</span>

	private void respawnInAfterLife() {
<span class="fc" id="L209">		final StendhalRPZone zone = SingletonRepository.getRPWorld().getZone(DEFAULT_DEAD_AREA);</span>

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		if (zone == null) {</span>
<span class="fc" id="L212">			logger.error(&quot;Unable to find dead area [&quot; + DEFAULT_DEAD_AREA</span>
					+ &quot;] for player: &quot; + player.getName());
		} else {
<span class="nc bnc" id="L215" title="All 2 branches missed.">			if (!zone.placeObjectAtEntryPoint(player)) {</span>
<span class="nc" id="L216">				logger.error(&quot;Unable to place player in zone &quot; + zone + &quot;: &quot;</span>
						+ player.getName());
			}
		}
<span class="fc" id="L220">	}</span>

	private void abondonPetsAndSheep() {
<span class="fc" id="L223">		final Sheep sheep = player.getSheep();</span>

<span class="pc bpc" id="L225" title="1 of 2 branches missed.">		if (sheep != null) {</span>
<span class="nc" id="L226">			player.removeSheep(sheep);</span>
		}

<span class="fc" id="L229">		final Pet pet = player.getPet();</span>

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">		if (pet != null) {</span>
<span class="nc" id="L232">			player.removePet(pet);</span>
		}
<span class="fc" id="L234">	}</span>

	protected void dropItemsOn(final Corpse corpse) {
		// drop at least 1 and at most 4 items
<span class="fc" id="L238">		final int maxItemsToDrop = Rand.rand(4);</span>
<span class="fc" id="L239">		final List&lt;Pair&lt;RPObject, RPSlot&gt;&gt; objects = retrieveAllDroppableObjects();</span>
<span class="fc" id="L240">		drops = new LinkedList&lt;Item&gt;();</span>
<span class="fc" id="L241">		numberOfDrops = 0;</span>
<span class="fc" id="L242">		Collections.shuffle(objects);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		for (int i = 0; i &lt; maxItemsToDrop; i++) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">			if (!objects.isEmpty()) {</span>
<span class="fc" id="L245">				final Pair&lt;RPObject, RPSlot&gt; object = objects.remove(0);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">				if (object.first() instanceof StackableItem) {</span>
<span class="nc" id="L247">					final StackableItem item = (StackableItem) object.first();</span>

					// We won't drop the full quantity, but only a
					// percentage.
					// Get a random percentage between 25 % and 75 % to drop
<span class="nc" id="L252">					final double percentage = (Rand.rand(50) + 25) / 100.0;</span>
<span class="nc" id="L253">					final int quantityToDrop = (int) Math.round(item.getQuantity()</span>
							* percentage);

<span class="nc bnc" id="L256" title="All 2 branches missed.">					if (quantityToDrop &gt; 0) {</span>
<span class="nc" id="L257">						final StackableItem itemToDrop = item.splitOff(quantityToDrop);</span>
<span class="nc" id="L258">						new ItemLogger().splitOff(player, item, itemToDrop, quantityToDrop);</span>
<span class="nc" id="L259">						new ItemLogger().equipAction(player, itemToDrop,</span>
							new String[]{&quot;slot&quot;, player.getName(), object.second().getName()},
							new String[]{&quot;slot&quot;, player.getName(), &quot;content&quot;});
<span class="nc" id="L262">						corpse.add(itemToDrop);</span>
<span class="nc" id="L263">						numberOfDrops += quantityToDrop;</span>
<span class="nc" id="L264">						drops.add(itemToDrop);</span>
					}
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">				} else if (object.first() instanceof Item) {</span>
<span class="fc" id="L267">					Item justItem = (Item) object.first();</span>
<span class="fc" id="L268">					object.second().remove(object.first().getID());</span>
<span class="fc" id="L269">					new ItemLogger().equipAction(player, (Entity) object.first(),</span>
									new String[]{&quot;slot&quot;, player.getName(), object.second().getName()},
									new String[]{&quot;slot&quot;, player.getName(), &quot;content&quot;});

<span class="fc" id="L273">					corpse.add((PassiveEntity) object.first());</span>
<span class="fc" id="L274">					numberOfDrops += 1;</span>
<span class="fc" id="L275">					drops.add(justItem);</span>
				}
			}
		}
<span class="fc" id="L279">	}</span>

	/**
	 *
	 * @return a list of all Items in RPEntity carrying slots that can be dropped
	 */
	private List&lt;Pair&lt;RPObject, RPSlot&gt;&gt; retrieveAllDroppableObjects() {
<span class="fc" id="L286">		final List&lt;Pair&lt;RPObject, RPSlot&gt;&gt; objects = new LinkedList&lt;Pair&lt;RPObject, RPSlot&gt;&gt;();</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">		for (RPSlot slot : player.slots(Slots.CARRYING)) {</span>

			// a list that will contain the objects that could
			// be dropped.
<span class="fc bfc" id="L292" title="All 2 branches covered.">			for (final RPObject objectInSlot : slot) {</span>
<span class="fc" id="L293">				addDroppableObjects(objectInSlot, objects);</span>
<span class="fc" id="L294">			}</span>
<span class="fc" id="L295">		}</span>
<span class="fc" id="L296">		return objects;</span>
	}

	/**
	 * Add any droppable objects inside an object, including the object itself
	 * if it's droppable and empty. The contents are scanned recursively.
	 *
	 * @param obj
	 * @param list
	 */
	private void addDroppableObjects(RPObject obj, List&lt;Pair&lt;RPObject, RPSlot&gt;&gt; list) {
<span class="fc" id="L307">		boolean droppable = true;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">		for (RPSlot slot : obj.slots()) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">			for (RPObject subobj : slot) {</span>
<span class="nc" id="L310">				addDroppableObjects(subobj, list);</span>
				// Don't drop containers, if they are not empty
<span class="nc" id="L312">				droppable = false;</span>
<span class="nc" id="L313">			}</span>
<span class="nc" id="L314">		}</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">		if (obj instanceof Item) {</span>
<span class="fc" id="L316">			Item item = (Item) obj;</span>
			// don't drop special quest rewards as there is no way to
			// get them again
<span class="pc bpc" id="L319" title="2 of 4 branches missed.">			if (item.isBound() || item.isUndroppableOnDeath()) {</span>
<span class="nc" id="L320">				droppable = false;</span>
			}
		}
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">		if (droppable) {</span>
<span class="fc" id="L324">			list.add(new Pair&lt;RPObject, RPSlot&gt;(obj, obj.getContainerSlot()));</span>
		}
<span class="fc" id="L326">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>