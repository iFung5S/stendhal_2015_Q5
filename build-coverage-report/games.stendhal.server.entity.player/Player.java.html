<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Player.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.server.entity.player</a> &gt; <span class="el_source">Player.java</span></div><h1>Player.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *					(C) Copyright 2003-2015 - Arianne					   *
 ***************************************************************************
 ***************************************************************************
 *																		   *
 *	 This program is free software; you can redistribute it and/or modify  *
 *	 it under the terms of the GNU General Public License as published by  *
 *	 the Free Software Foundation; either version 2 of the License, or	   *
 *	 (at your option) any later version.								   *
 *																		   *
 ***************************************************************************/
package games.stendhal.server.entity.player;

import static games.stendhal.common.NotificationType.getServerNotificationType;
import static games.stendhal.common.constants.Actions.ADMINLEVEL;
import static games.stendhal.common.constants.Actions.AUTOWALK;
import static games.stendhal.common.constants.Actions.AWAY;
import static games.stendhal.common.constants.Actions.GHOSTMODE;
import static games.stendhal.common.constants.Actions.GRUMPY;
import static games.stendhal.common.constants.Actions.INVISIBLE;
import static games.stendhal.common.constants.Actions.TELECLICKMODE;
import games.stendhal.common.Direction;
import games.stendhal.common.ItemTools;
import games.stendhal.common.KeyedSlotUtil;
import games.stendhal.common.Level;
import games.stendhal.common.NotificationType;
import games.stendhal.common.TradeState;
import games.stendhal.common.Version;
import games.stendhal.common.constants.Nature;
import games.stendhal.common.constants.SoundLayer;
import games.stendhal.common.constants.Testing;
import games.stendhal.common.grammar.Grammar;
import games.stendhal.common.parser.WordList;
import games.stendhal.server.core.engine.GameEvent;
import games.stendhal.server.core.engine.SingletonRepository;
import games.stendhal.server.core.engine.StendhalRPZone;
import games.stendhal.server.core.events.TurnListener;
import games.stendhal.server.core.events.TurnNotifier;
import games.stendhal.server.core.events.TutorialNotifier;
import games.stendhal.server.core.events.UseListener;
import games.stendhal.server.core.rp.StendhalRPAction;
import games.stendhal.server.core.rp.achievement.AchievementNotifier;
import games.stendhal.server.entity.Entity;
import games.stendhal.server.entity.Killer;
import games.stendhal.server.entity.Outfit;
import games.stendhal.server.entity.RPEntity;
import games.stendhal.server.entity.creature.DomesticAnimal;
import games.stendhal.server.entity.creature.Pet;
import games.stendhal.server.entity.creature.Sheep;
import games.stendhal.server.entity.item.Corpse;
import games.stendhal.server.entity.item.Item;
import games.stendhal.server.entity.item.RingOfLife;
import games.stendhal.server.entity.npc.behaviour.impl.OutfitChangerBehaviour.ExpireOutfit;
import games.stendhal.server.entity.slot.Slots;
import games.stendhal.server.entity.status.StatusType;
import games.stendhal.server.events.PrivateTextEvent;
import games.stendhal.server.events.SoundEvent;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;

import marauroa.common.game.RPObject;
import marauroa.common.game.RPSlot;
import marauroa.common.game.SyntaxException;

import org.apache.log4j.Logger;

public class Player extends RPEntity implements UseListener {

	private static final String LAST_PLAYER_KILL_TIME = &quot;last_player_kill_time&quot;;
<span class="fc" id="L79">	private static final String[] RECOLORABLE_OUTFIT_PARTS = { &quot;detail&quot;,</span>
			&quot;dress&quot;, &quot;hair&quot;, &quot;body&quot;, &quot;head&quot;, &quot;eyes&quot; };

	/** the logger instance. */
<span class="fc" id="L83">	private static final Logger logger = Logger.getLogger(Player.class);</span>

	/**
	 * A random generator (for karma payout).
	 */
<span class="fc" id="L88">	private static final Random KARMA_RANDOMIZER = new Random();</span>

	/**
	 * Currently active client directions (in oldest-newest order).
	 */
	private final List&lt;Direction&gt; directions;

	/**
	 * Karma (luck).
	 */
	private double karma;
	/**
	 * number of successful trades
	 */
	private int tradescore;

	/**
	 * List of portals that have been &quot;unlocked&quot; for this player.
	 */
	private final List&lt;Integer&gt; unlockedPortals;

<span class="fc" id="L109">	private final PlayerQuests quests = new PlayerQuests(this);</span>
<span class="fc" id="L110">	private final PlayerDieer dieer = new PlayerDieer(this);</span>
<span class="fc" id="L111">	private final PlayerTrade trade = new PlayerTrade(this);</span>
<span class="fc" id="L112">	private final KillRecording killRec = new KillRecording(this);</span>
<span class="fc" id="L113">	private final PetOwner petOwner = new PetOwner(this);</span>
<span class="fc" id="L114">	private final PlayerLootedItemsHandler itemCounter = new PlayerLootedItemsHandler(</span>
			this);

	/**
	 * The number of minutes that this player has been logged in on the server.
	 */
	private int age;

	/**
	 * The last player who privately talked to this player using the /tell
	 * command. It needs to be stored non-persistently so that /answer can be
	 * used.
	 */
	private String lastPrivateChatterName;

	private final PlayerChatBucket chatBucket;

	/**
	 * all identifiers of reached achievements, filled on login of player
	 */
	private Set&lt;String&gt; reachedAchievements;

	/**
	 * preferred language
	 */
	private String language;

	/**
	 * version of the client
	 */
	private String clientVersion;
	/**
	 * The turn when the player last time pushed something.
	 */
	private int turnOfLastPush;
	/**
	 * The turn the player started moving using the keyboard. Used for detecting
	 * quick presses ment to move one tile.
	 */
	private int startMoveTurn;

	/**
	 * last client action timestamp
	 */
<span class="fc" id="L158">	private long lastClientActionTimestamp = System.currentTimeMillis();</span>

	public static void generateRPClass() {
		try {
<span class="fc" id="L162">			PlayerRPClass.generateRPClass();</span>
<span class="nc" id="L163">		} catch (final SyntaxException e) {</span>
<span class="nc" id="L164">			logger.error(&quot;cannot generateRPClass&quot;, e);</span>
<span class="fc" id="L165">		}</span>
<span class="fc" id="L166">	}</span>

	public static Player createZeroLevelPlayer(final String characterName,
			RPObject template) {
		/*
		 * TODO: Update to use Player and RPEntity methods.
		 */
<span class="fc" id="L173">		final Player player = new Player(new RPObject());</span>
<span class="fc" id="L174">		player.setID(RPObject.INVALID_ID);</span>

<span class="fc" id="L176">		player.put(&quot;type&quot;, &quot;player&quot;);</span>
<span class="fc" id="L177">		player.put(&quot;name&quot;, characterName);</span>
<span class="fc" id="L178">		player.put(&quot;base_hp&quot;, 100);</span>
<span class="fc" id="L179">		player.put(&quot;hp&quot;, 100);</span>
<span class="fc" id="L180">		player.put(&quot;atk&quot;, 10);</span>
<span class="fc" id="L181">		player.put(&quot;atk_xp&quot;, 0);</span>
<span class="fc" id="L182">		player.put(&quot;def&quot;, 10);</span>
<span class="fc" id="L183">		player.put(&quot;def_xp&quot;, 0);</span>
		/* TODO: Remove condition after ranged stat testing is finished. */
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if (Testing.COMBAT) {</span>
<span class="nc" id="L186">			player.put(&quot;ratk&quot;, 10);</span>
<span class="nc" id="L187">			player.put(&quot;ratk_xp&quot;, 0);</span>
		}
<span class="fc" id="L189">		player.put(&quot;level&quot;, 0);</span>
<span class="fc" id="L190">		player.setXP(0);</span>

		// define outfit
<span class="fc" id="L193">		Outfit outfit = null;</span>
<span class="pc bpc" id="L194" title="3 of 4 branches missed.">		if (template != null &amp;&amp; template.has(&quot;outfit&quot;)) {</span>
<span class="nc" id="L195">			outfit = new Outfit(template.getInt(&quot;outfit&quot;));</span>
		}

<span class="pc bpc" id="L198" title="3 of 4 branches missed.">		if (outfit == null || !outfit.isChoosableByPlayers()) {</span>
<span class="fc" id="L199">			outfit = Outfit.getRandomOutfit();</span>
		}
<span class="fc" id="L201">		player.setOutfit(outfit);</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">		for (final String slot : Arrays.asList(&quot;armor&quot;, &quot;rhand&quot;)) {</span>
<span class="fc" id="L204">			player.addSlot(slot);</span>
<span class="fc" id="L205">		}</span>

<span class="fc" id="L207">		player.update();</span>
<span class="fc" id="L208">		Entity entity = SingletonRepository.getEntityManager().getItem(</span>
				&quot;leather armor&quot;);
<span class="fc" id="L210">		RPSlot slot = player.getSlot(&quot;armor&quot;);</span>
<span class="fc" id="L211">		slot.add(entity);</span>

<span class="fc" id="L213">		entity = SingletonRepository.getEntityManager().getItem(&quot;club&quot;);</span>
<span class="fc" id="L214">		slot = player.getSlot(&quot;rhand&quot;);</span>
<span class="fc" id="L215">		slot.add(entity);</span>

<span class="fc" id="L217">		return player;</span>
	}

	public static void destroy(final Player player) {
<span class="nc" id="L221">		final String name = player.getName();</span>

<span class="nc" id="L223">		player.getPetOwner().destroy();</span>
<span class="nc" id="L224">		player.stop();</span>
<span class="nc" id="L225">		player.stopAttack();</span>
<span class="nc" id="L226">		player.trade.cancelTradeBecauseOfLogout();</span>

		/*
		 * Normally a zoneid attribute shouldn't logically exist after an entity
		 * is removed from a zone, but we need to keep it for players so that it
		 * can be serialised.
		 * 
		 * TODO: Find a better way to decouple &quot;active&quot; zone info from &quot;resume&quot;
		 * zone info, or save just before removing from zone instead.
		 */

<span class="nc" id="L237">		player.getZone().remove(player);</span>

<span class="nc" id="L239">		player.disconnected = true;</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">		if (name != null) {</span>
<span class="nc" id="L242">			WordList.getInstance().unregisterSubjectName(name);</span>
		}
<span class="nc" id="L244">	}</span>

	public Player(final RPObject object) {
<span class="fc" id="L247">		super(object);</span>

<span class="fc" id="L249">		setRPClass(&quot;player&quot;);</span>
<span class="fc" id="L250">		put(&quot;type&quot;, &quot;player&quot;);</span>
		// HACK: postman as NPC
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">		if (object.has(&quot;name&quot;) &amp;&amp; object.get(&quot;name&quot;).equals(&quot;postman&quot;)) {</span>
<span class="nc" id="L253">			put(&quot;title_type&quot;, &quot;npc&quot;);</span>
		}

<span class="pc bpc" id="L256" title="1 of 2 branches missed.">		if (getAdminLevel() &gt; 1000) {</span>
<span class="nc" id="L257">			chatBucket = new AdminChatBucket();</span>
		} else {
<span class="fc" id="L259">			chatBucket = new PlayerChatBucket();</span>
		}

<span class="fc" id="L262">		setSize(1, 1);</span>

<span class="fc" id="L264">		directions = new ArrayList&lt;Direction&gt;();</span>

		// Beginner's luck (unless overridden by update)
<span class="fc" id="L267">		karma = 10.0;</span>
<span class="fc" id="L268">		tradescore = 0;</span>
<span class="fc" id="L269">		baseSpeed = 1.0;</span>
<span class="fc" id="L270">		update();</span>
		// Ensure that players do not accidentally get stored with zones
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">		if (isStorable()) {</span>
<span class="nc" id="L273">			unstore();</span>
<span class="nc" id="L274">			logger.error(&quot;Player &quot; + getName() + &quot; was marked storable.&quot;,</span>
					new Throwable());
		}

<span class="fc" id="L278">		unlockedPortals = new LinkedList&lt;Integer&gt;();</span>

		/* TODO: Remove condition when ranged stat testing is finished. */
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">		if (Testing.COMBAT) {</span>
			/*
			 * TODO: Remove if VOLATILE definition is removed from &quot;ratk&quot; and
			 * &quot;ratk_xp&quot; attributes.
			 */
<span class="nc bnc" id="L286" title="All 2 branches missed.">			if (!this.has(&quot;ratk_xp&quot;)) {</span>
				/*
				 * If an existing character does not have ranged stat set it at
				 * same level and experience as new character.
				 */
<span class="nc" id="L291">				this.put(&quot;ratk&quot;, 10);</span>
<span class="nc" id="L292">				this.put(&quot;ratk_xp&quot;, 0);</span>

				/*
				 * if player's current level is 20 or higher give a buffer based
				 * on about 25% of current atk experience.
				 */
<span class="nc bnc" id="L298" title="All 2 branches missed.">				if (this.getLevel() &gt; 19) {</span>
					/*
					 * Using setRatkXPinternal() instead of setRatkXP() here to
					 * avoid multiple calls to updateModifiedAttributes().
					 */
					// FIXME: Is this formula accurate?
<span class="nc" id="L304">					this.setRatkXPInternal((int) (this.getAtkXP() * 0.0026),</span>
							false);
				}
			}
		}

<span class="fc" id="L310">		updateModifiedAttributes();</span>
<span class="fc" id="L311">	}</span>

	/**
	 * Add an active client direction.
	 *
	 * @param direction
	 *            direction
	 */
	public void addClientDirection(final Direction direction) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">		if (hasPath()) {</span>
<span class="nc" id="L321">			clearPath();</span>
		}

<span class="nc" id="L324">		startMoveTurn = SingletonRepository.getRuleProcessor().getTurn();</span>
<span class="nc" id="L325">		directions.remove(direction);</span>
<span class="nc" id="L326">		directions.add(direction);</span>
<span class="nc" id="L327">	}</span>

	/**
	 * Remove an active client direction.
	 *
	 * @param direction
	 *            direction
	 */
	public void removeClientDirection(final Direction direction) {
<span class="nc" id="L336">		directions.remove(direction);</span>
<span class="nc" id="L337">	}</span>

	/**
	 * Apply the most recent active client direction.
	 *
	 * @param stopOnNone
	 *            Stop movement if no (valid) directions are active if
	 *            &lt;code&gt;true&lt;/code&gt;.
	 */
	public void applyClientDirection(final boolean stopOnNone) {
		int size;
		Direction direction;

		/*
		 * For now just take last direction.
		 * 
		 * Eventually try each (last-to-first) until a non-blocked one is found
		 * (if any).
		 */
<span class="fc" id="L356">		size = directions.size();</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">		if (size != 0) {</span>
<span class="nc" id="L358">			direction = directions.get(size - 1);</span>

			// as an effect of the poisoning, the player's controls
			// are switched to make it difficult to navigate.
<span class="nc bnc" id="L362" title="All 4 branches missed.">			if (hasStatus(StatusType.POISONED) || has(&quot;status_confuse&quot;)) {</span>
<span class="nc" id="L363">				direction = direction.oppositeDirection();</span>
			}

<span class="nc" id="L366">			setDirection(direction);</span>
<span class="nc" id="L367">			setSpeed(getBaseSpeed());</span>
		}
<span class="fc" id="L369">	}</span>

	@Override
	public boolean isObstacle(final Entity entity) {
<span class="fc bfc" id="L373" title="All 2 branches covered.">		if (entity instanceof Player) {</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">			if (getZone().getName().equals(PlayerDieer.DEFAULT_DEAD_AREA)) {</span>
<span class="nc" id="L375">				return false;</span>
			}
		}

<span class="fc" id="L379">		return super.isObstacle(entity);</span>
	}

	/**
	 * Request stopping the player, unless the player started moving the same
	 * turn. Intended for client initiated stops, that should not prevent the
	 * player moving one tile with a quick key press.
	 */
	public void requestStop() {
<span class="fc" id="L388">		int turn = SingletonRepository.getRuleProcessor().getTurn();</span>

<span class="pc bpc" id="L390" title="1 of 2 branches missed.">		if (turn != startMoveTurn) {</span>
<span class="nc" id="L391">			stop();</span>
		} else {
<span class="fc" id="L393">			TurnNotifier.get().notifyInTurns(1, new TurnListener() {</span>
				@Override
				public void onTurnReached(int currentTurn) {
					/*
					 * Check the turn again. The player may have sent yet
					 * another move command, and we do not want to cancel that.
					 */
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">					if (currentTurn != startMoveTurn) {</span>
<span class="fc" id="L401">						stop();</span>
					}
<span class="fc" id="L403">				}</span>
			});
		}
<span class="fc" id="L406">	}</span>

	/**
	 * Stop and clear any active directions.
	 */
	@Override
	public void stop() {
		/* Bypass stopping the player if autoWalkState is &lt;b&gt;true&lt;/b&gt;. */
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">		if (!this.has(AUTOWALK)) {</span>
<span class="fc" id="L415">			directions.clear();</span>
<span class="fc" id="L416">			super.stop();</span>
		}
<span class="fc" id="L418">	}</span>

	/**
	 * Get the away message.
	 *
	 * @return The away message, or &lt;code&gt;null&lt;/code&gt; if unset.
	 */
	public String getAwayMessage() {
<span class="fc" id="L426">		return get(AWAY);</span>
	}

	/**
	 * Set the away message.
	 *
	 * @param message
	 *            An away message, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public void setAwayMessage(final String message) {
<span class="fc bfc" id="L436" title="All 2 branches covered.">		if (message != null) {</span>
<span class="fc" id="L437">			put(AWAY, message);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">		} else if (has(AWAY)) {</span>
<span class="nc" id="L439">			remove(AWAY);</span>
		}
<span class="fc" id="L441">	}</span>

	/**
	 * Get the grumpy message.
	 *
	 * @return The grumpy message, or &lt;code&gt;null&lt;/code&gt; if unset.
	 */
	public String getGrumpyMessage() {
<span class="fc" id="L449">		return get(GRUMPY);</span>
	}

	/**
	 * Set the grumpy message.
	 *
	 * @param message
	 *            A grumpy message, or &lt;code&gt;null&lt;/code&gt;.
	 */
	public void setGrumpyMessage(final String message) {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">		if (message != null) {</span>
<span class="fc" id="L460">			put(GRUMPY, message);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">		} else if (has(GRUMPY)) {</span>
<span class="nc" id="L462">			remove(GRUMPY);</span>
		}

<span class="fc" id="L465">	}</span>

	/**
	 * Give the player some karma (good or bad).
	 *
	 * @param karmaToAdd
	 *            An amount of karma to add/subtract.
	 */
	@Override
	public void addKarma(final double karmaToAdd) {
<span class="fc" id="L475">		this.karma += karmaToAdd;</span>

<span class="fc" id="L477">		put(&quot;karma&quot;, this.karma);</span>
<span class="fc" id="L478">		new GameEvent(this.getName(), &quot;added karma&quot;,</span>
				Integer.toString((int) karmaToAdd),
				Integer.toString((int) karma)).raise();
<span class="fc" id="L481">	}</span>

	/**
	 * Get the current amount of karma.
	 *
	 * @return The current amount of karma.
	 *
	 * @see #addKarma(double)
	 */
	@Override
	public double getKarma() {
<span class="fc" id="L492">		return karma;</span>
	}

	/**
	 * Use some of the player's karma. A positive value indicates good
	 * luck/energy. A negative value indicates bad luck/energy. A value of zero
	 * should cause no change on an action or outcome.
	 *
	 * @param scale
	 *            A positive number.
	 *
	 * @return A number between -scale and scale.
	 */
	@Override
	public double useKarma(final double scale) {
<span class="fc" id="L507">		return useKarma(-scale, scale);</span>
	}

	/**
	 * Use some of the player's karma. A positive value indicates good
	 * luck/energy. A negative value indicates bad luck/energy. A value of zero
	 * should cause no change on an action or outcome. The granularity is
	 * &lt;code&gt;0.01&lt;/code&gt; (%1 unit).
	 *
	 * @param negLimit
	 *            The lowest negative value returned.
	 * @param posLimit
	 *            The highest positive value returned.
	 *
	 * @return A number within negLimit &amp;lt;= 0 &amp;lt;= posLimit.
	 */
	@Override
	public double useKarma(final double negLimit, final double posLimit) {
<span class="fc" id="L525">		return useKarma(negLimit, posLimit, 0.01);</span>
	}

	/**
	 * Use some of the player's karma. A positive value indicates good
	 * luck/energy. A negative value indicates bad luck/energy. A value of zero
	 * should cause no change on an action or outcome.
	 *
	 * @param negLimit
	 *            The lowest negative value returned.
	 * @param posLimit
	 *            The highest positive value returned.
	 * @param granularity
	 *            The amount that any extracted karma is a multiple of.
	 *
	 * @return A number within negLimit &amp;lt;= 0 &amp;lt;= posLimit.
	 */
	@Override
	public double useKarma(final double negLimit, final double posLimit,
			final double granularity) {
		double limit;
		double score;

<span class="pc bpc" id="L548" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L549">			logger.debug(&quot;karma request: &quot; + negLimit + &quot; &lt;= x &lt;= &quot; + posLimit);</span>
		}

		/*
		 * Positive or Negative?
		 */
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">		if (karma &lt; 0.0) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">			if (negLimit &gt;= 0.0) {</span>
<span class="nc" id="L557">				return 0.0;</span>
			}

<span class="nc" id="L560">			limit = Math.max(negLimit, karma);</span>
		} else {
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">			if (posLimit &lt;= 0.0) {</span>
<span class="nc" id="L563">				return 0.0;</span>
			}

<span class="fc" id="L566">			limit = Math.min(posLimit, karma);</span>
		}

<span class="pc bpc" id="L569" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L570">			logger.debug(&quot;karma limit: &quot; + limit);</span>
		}

		/*
		 * Give at least 20% of possible payout
		 */
<span class="fc" id="L576">		score = (0.2 + KARMA_RANDOMIZER.nextDouble() * 0.8) * limit;</span>

		/*
		 * Clip to granularity. Use floor() instead of round() so that the
		 * player never uses more karma than she has.
		 */
<span class="fc" id="L582">		score = Math.floor(score / granularity) * granularity;</span>

		/*
		 * with a lucky charm you use up less karma to be just as lucky
		 */
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">		if (this.isEquipped(&quot;lucky charm&quot;)) {</span>
<span class="nc" id="L588">			karma -= 0.5 * score;</span>
		} else {
<span class="fc" id="L590">			karma -= score;</span>
		}

<span class="pc bpc" id="L593" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L594">			logger.debug(&quot;karma given: &quot; + score);</span>
		}

<span class="fc" id="L597">		put(&quot;karma&quot;, karma);</span>

<span class="fc" id="L599">		return score;</span>
	}

	/**
	 * increments the number of successful trades by 1
	 */
	public void incrementTradescore() {
<span class="fc" id="L606">		this.tradescore += 1;</span>
<span class="fc" id="L607">		put(&quot;tradescore&quot;, this.tradescore);</span>
<span class="fc" id="L608">	}</span>

	public int getTradescore() {
<span class="fc" id="L611">		return this.tradescore;</span>
	}

	/**
	 *
	 * @return List of portals that have been unlocked for this player.
	 */
	public List&lt;Integer&gt; getUnlockedPortals() {
<span class="nc" id="L619">		return unlockedPortals;</span>
	}

	/**
	 * Removes the portal from the list of unlocked portals.
	 *
	 * @param ID
	 *            Portal's ID
	 */
	public void lockPortal(final int ID) {
<span class="nc" id="L629">		int index = unlockedPortals.size() - 1;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">		if (unlockedPortals.contains(ID)) {</span>
			// Iterate list backwards
<span class="nc bnc" id="L632" title="All 2 branches missed.">			while (index &gt;= 0) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">				if (unlockedPortals.get(index) == ID) {</span>
<span class="nc" id="L634">					unlockedPortals.remove(index);</span>
<span class="nc" id="L635">					logger.debug(&quot;Removed portal ID &quot; + Integer.toString(ID)</span>
							+ &quot; from player &quot; + getName() + &quot;.&quot;);
				}
<span class="nc" id="L638">				index -= 1;</span>
			}
		}
<span class="nc" id="L641">	}</span>

	/**
	 * Adds a portal ID to a list of &quot;unlocked&quot; portals for player.
	 *
	 * @param ID
	 *            Portal's ID
	 */
	public void unlockPortal(final int ID) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">		if (!unlockedPortals.contains(ID)) {</span>
<span class="nc" id="L651">			unlockedPortals.add(ID);</span>
<span class="nc" id="L652">			logger.debug(&quot;Added portal ID &quot; + Integer.toString(ID)</span>
					+ &quot; to unlocked portals for player &quot; + getName() + &quot;.&quot;);
		}
<span class="nc" id="L655">	}</span>

	/**
	 * Process changes that to the object attributes. This may be called several
	 * times (unfortunately) due to the requirements of the class's constructor,
	 * sometimes before prereqs are initialised.
	 */
	@Override
	public void update() {
<span class="fc" id="L664">		super.update();</span>

<span class="fc bfc" id="L666" title="All 2 branches covered.">		if (has(&quot;xp&quot;)) {</span>
			// Force level to be updated.
<span class="fc" id="L668">			updateLevel();</span>
		}

<span class="fc bfc" id="L671" title="All 2 branches covered.">		if (has(&quot;age&quot;)) {</span>
<span class="fc" id="L672">			age = getInt(&quot;age&quot;);</span>
		}

<span class="fc bfc" id="L675" title="All 2 branches covered.">		if (has(&quot;karma&quot;)) {</span>
<span class="fc" id="L676">			karma = getDouble(&quot;karma&quot;);</span>
		}
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">		if (has(&quot;tradescore&quot;)) {</span>
<span class="nc" id="L679">			tradescore = getInt(&quot;tradescore&quot;);</span>
		}
<span class="fc" id="L681">	}</span>

	/**
	 * Add a player ignore entry.
	 *
	 * @param name
	 *            The player name.
	 * @param duration
	 *            The ignore duration (in minutes), or &lt;code&gt;0&lt;/code&gt; for
	 *            infinite.
	 * @param reply
	 *            The reply.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if value changed, &lt;code&gt;false&lt;/code&gt; if there
	 *         was a problem.
	 */
	public boolean addIgnore(final String name, final int duration,
			final String reply) {
<span class="nc" id="L699">		final StringBuilder sbuf = new StringBuilder();</span>

<span class="nc bnc" id="L701" title="All 2 branches missed.">		if (duration != 0) {</span>
<span class="nc" id="L702">			sbuf.append(System.currentTimeMillis() + duration * 60000L);</span>
		}

<span class="nc" id="L705">		sbuf.append(';');</span>

<span class="nc bnc" id="L707" title="All 2 branches missed.">		if (reply != null) {</span>
<span class="nc" id="L708">			sbuf.append(reply);</span>
		}

<span class="nc" id="L711">		return setKeyedSlot(&quot;!ignore&quot;, &quot;_&quot; + name, sbuf.toString());</span>
	}

	/**
	 * Determine if a player is on the ignore list and return their reply
	 * message.
	 *
	 * @param name
	 *            The player name.
	 *
	 * @return The custom reply message (including an empty string), or
	 *         &lt;code&gt;null&lt;/code&gt; if not ignoring.
	 */
	public String getIgnore(final String name) {
<span class="nc" id="L725">		String info = getKeyedSlot(&quot;!ignore&quot;, &quot;_&quot; + name);</span>
		int i;
		long expiration;

<span class="nc bnc" id="L729" title="All 2 branches missed.">		if (info == null) {</span>
			/*
			 * Special &quot;catch all&quot; fallback
			 */
<span class="nc" id="L733">			info = getKeyedSlot(&quot;!ignore&quot;, &quot;_*&quot;);</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">			if (info == null) {</span>
<span class="nc" id="L735">				return null;</span>
			}
		}
<span class="nc" id="L738">		i = info.indexOf(';');</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">		if (i == -1) {</span>
			/*
			 * Do default
			 */
<span class="nc" id="L743">			return &quot;&quot;;</span>
		}

		/*
		 * Has expiration?
		 */
<span class="nc bnc" id="L749" title="All 2 branches missed.">		if (i != 0) {</span>
<span class="nc" id="L750">			expiration = Long.parseLong(info.substring(0, i));</span>

<span class="nc bnc" id="L752" title="All 2 branches missed.">			if (System.currentTimeMillis() &gt;= expiration) {</span>
<span class="nc" id="L753">				setKeyedSlot(&quot;!ignore&quot;, &quot;_&quot; + name, null);</span>
<span class="nc" id="L754">				return null;</span>
			}
		}

<span class="nc" id="L758">		return info.substring(i + 1);</span>
	}

	/**
	 * Remove a player ignore entry.
	 *
	 * @param name
	 *            The player name.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if value changed, &lt;code&gt;false&lt;/code&gt; if there
	 *         was a problem.
	 */
	public boolean removeIgnore(final String name) {
<span class="nc" id="L771">		return setKeyedSlot(&quot;!ignore&quot;, &quot;_&quot; + name, null);</span>
	}

	/**
	 * @return all buddy names for this player
	 */
	public Set&lt;String&gt; getIgnores() {
<span class="fc" id="L778">		Set&lt;String&gt; res = new HashSet&lt;String&gt;();</span>

<span class="pc bpc" id="L780" title="1 of 2 branches missed.">		if (!this.hasSlot(&quot;!ignore&quot;)) {</span>
<span class="fc" id="L781">			return res;</span>
		}

<span class="nc" id="L784">		RPObject ignoreObject = KeyedSlotUtil.getKeyedSlotObject(this,</span>
				&quot;!ignore&quot;);

		// character names are prefixed with an &quot;_&quot; to tell them apart from
		// generic attributes such as &quot;id&quot;.
<span class="nc bnc" id="L789" title="All 2 branches missed.">		for (String key : ignoreObject) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">			if (key.charAt(0) != '_') {</span>
<span class="nc" id="L791">				continue;</span>
			}

			// skip expired entries
<span class="nc" id="L795">			String info = ignoreObject.get(key);</span>
<span class="nc" id="L796">			int i = info.indexOf(';');</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">			if (i &gt; 0) {</span>
<span class="nc" id="L798">				long expiration = Long.parseLong(info.substring(0, i));</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">				if (System.currentTimeMillis() &gt;= expiration) {</span>
<span class="nc" id="L800">					continue;</span>
				}
			}

<span class="nc" id="L804">			res.add(key.substring(1));</span>
<span class="nc" id="L805">		}</span>

<span class="nc" id="L807">		return res;</span>
	}

	/**
	 * Get a named skills value.
	 *
	 * @param key
	 *            The skill key.
	 *
	 * @return The skill value, or &lt;code&gt;null&lt;/code&gt; if not set.
	 */
	public String getSkill(final String key) {
<span class="fc" id="L819">		return getKeyedSlot(&quot;skills&quot;, key);</span>
	}

	/**
	 * Get the current value for the skill of a magic nature
	 * 
	 * @param nature
	 *            the nature to get the skill for
	 * @return current skill value
	 */
	public int getMagicSkillXp(final Nature nature) {
<span class="fc" id="L830">		int skillValue = 0;</span>
<span class="fc" id="L831">		String skill = getSkill(nature.toString() + &quot;_xp&quot;);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">		if (skill != null) {</span>
			try {
<span class="fc" id="L834">				Integer skillInteger = Integer.parseInt(skill);</span>
<span class="fc" id="L835">				skillValue = skillInteger.intValue();</span>
<span class="fc" id="L836">			} catch (NumberFormatException e) {</span>
<span class="fc" id="L837">				logger.error(e, e);</span>
<span class="fc" id="L838">			}</span>
		}
<span class="fc" id="L840">		return skillValue;</span>
	}

	/**
	 * Increase the skill points for a magic nature by a given amount
	 * 
	 * @param nature
	 * @param amount
	 */
	public void increaseMagicSkillXp(final Nature nature, int amount) {
<span class="fc" id="L850">		int oldValue = getMagicSkillXp(nature);</span>
<span class="fc" id="L851">		int newValue = oldValue + amount;</span>
		// Handle level changes
<span class="fc" id="L853">		final int newLevel = Level.getLevel(newValue);</span>
<span class="fc" id="L854">		int oldLevel = Level.getLevel(oldValue);</span>
<span class="fc" id="L855">		final int levels = newLevel - (oldLevel - 10);</span>

		// In case we level up several levels at a single time.
<span class="fc bfc" id="L858" title="All 2 branches covered.">		for (int i = 0; i &lt; Math.abs(levels); i++) {</span>
<span class="fc" id="L859">			Integer oneup = getMagicSkill(nature) + (int) Math.signum(levels)</span>
					* 1;
			// set in map
<span class="fc" id="L862">			setSkill(nature.toString(), oneup.toString());</span>
			// log event
<span class="fc" id="L864">			new GameEvent(getName(), &quot;nature-&quot; + nature.toString(),</span>
					oneup.toString()).raise();
		}
<span class="fc" id="L867">		setSkill(nature.toString() + &quot;_xp&quot;, Integer.valueOf(newValue)</span>
				.toString());
<span class="fc" id="L869">	}</span>

	private int getMagicSkill(final Nature nature) {
<span class="fc" id="L872">		int skillLevel = 0;</span>
<span class="fc" id="L873">		String skillString = getSkill(nature.toString());</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">		if (skillString != null) {</span>
			try {
<span class="fc" id="L876">				Integer skillInteger = Integer.parseInt(skillString);</span>
<span class="fc" id="L877">				skillLevel = skillInteger.intValue();</span>
<span class="nc" id="L878">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L879">				logger.error(e, e);</span>
<span class="fc" id="L880">			}</span>
		}
<span class="fc" id="L882">		return skillLevel;</span>
	}

	/**
	 * Set a named skills value.
	 *
	 * @param key
	 *            The skill key.
	 * @param value
	 *            The skill value.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if value changed, &lt;code&gt;false&lt;/code&gt; if there
	 *         was a problem.
	 */
	public boolean setSkill(final String key, final String value) {
<span class="fc" id="L897">		return setKeyedSlot(&quot;skills&quot;, key, value);</span>
	}

	/**
	 * Get a keyed string value on a named slot.
	 *
	 * @param name
	 *            The slot name.
	 * @param key
	 *            The value key.
	 *
	 * @return The keyed value of the slot, or &lt;code&gt;null&lt;/code&gt; if not set.
	 */
	public String getKeyedSlot(final String name, final String key) {
<span class="fc" id="L911">		return KeyedSlotUtil.getKeyedSlot(this, name, key);</span>
	}

	/**
	 * Set a keyed string value on a named slot.
	 *
	 * @param name
	 *            The slot name.
	 * @param key
	 *            The value key.
	 * @param value
	 *            The value to assign (or remove if &lt;code&gt;null&lt;/code&gt;).
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if value changed, &lt;code&gt;false&lt;/code&gt; if there
	 *         was a problem.
	 */
	public boolean setKeyedSlot(final String name, final String key,
			final String value) {
<span class="fc" id="L929">		return KeyedSlotUtil.setKeyedSlot(this, name, key, value);</span>
	}

	/**
	 * Get a client feature value.
	 *
	 * @param name
	 *            The feature mnemonic.
	 *
	 * @return The feature value, or &lt;code&gt;null&lt;/code&gt; is not-enabled.
	 */
	public String getFeature(final String name) {
<span class="fc" id="L941">		return get(&quot;features&quot;, name);</span>
	}

	/**
	 * Enable/disable a client feature.
	 *
	 * @param name
	 *            The feature mnemonic.
	 * @param enabled
	 *            Flag indicating if enabled.
	 */
	public void setFeature(final String name, final boolean enabled) {
<span class="fc bfc" id="L953" title="All 2 branches covered.">		if (enabled) {</span>
<span class="fc" id="L954">			setFeature(name, &quot;&quot;);</span>
		} else {
<span class="fc" id="L956">			unsetFeature(name);</span>
		}
<span class="fc" id="L958">	}</span>

	/**
	 * Sets/removes a client feature.
	 * &lt;p&gt;
	 * &lt;strong&gt;NOTE: The names and values MUST NOT contain &lt;code&gt;=&lt;/code&gt;
	 * (equals), or &lt;code&gt;:&lt;/code&gt; (colon). &lt;/strong&gt;
	 *
	 * @param name
	 *            The feature mnemonic.
	 * @param value
	 *            The feature value, or &lt;code&gt;null&lt;/code&gt; to disable.
	 */
	public void setFeature(final String name, final String value) {
<span class="fc" id="L972">		put(&quot;features&quot;, name, value);</span>
<span class="fc" id="L973">	}</span>

	/**
	 * Unset a client feature
	 *
	 * @param name
	 *            The feature mnemonic
	 */
	public void unsetFeature(final String name) {
<span class="fc" id="L982">		remove(&quot;features&quot;, name);</span>
<span class="fc" id="L983">	}</span>

	/**
	 * Determine if the entity is invisible to creatures.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if invisible.
	 */
	@Override
	public boolean isInvisibleToCreatures() {
<span class="fc" id="L992">		return has(INVISIBLE);</span>
	}

	/**
	 * Set whether this player is invisible to creatures.
	 *
	 * @param invisible
	 *            &lt;code&gt;true&lt;/code&gt; if invisible.
	 */
	public void setInvisible(final boolean invisible) {
<span class="fc bfc" id="L1002" title="All 2 branches covered.">		if (invisible) {</span>
<span class="fc" id="L1003">			put(INVISIBLE, &quot;&quot;);</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">		} else if (has(INVISIBLE)) {</span>
<span class="fc" id="L1005">			remove(INVISIBLE);</span>
		}
<span class="fc" id="L1007">	}</span>

	/**
	 * Sends a message that only this player can read. Used for messages that
	 * should not appear as sent by another player. For messages from other
	 * players (or relevant NPC messages), use sendPrivateText(PRIVMSG, text)
	 *
	 * @param text
	 *            the message.
	 */
	@Override
	public void sendPrivateText(final String text) {
<span class="fc" id="L1019">		sendPrivateText(getServerNotificationType(clientVersion), text);</span>
<span class="fc" id="L1020">	}</span>

	/**
	 * Sends a message that only this player can read.
	 *
	 * @param type
	 *            NotificationType
	 * @param text
	 *            the message.
	 */
	@Override
	public void sendPrivateText(final NotificationType type, final String text) {
<span class="fc" id="L1032">		this.addEvent(new PrivateTextEvent(type, text));</span>
<span class="fc" id="L1033">		this.notifyWorldAboutChanges();</span>
<span class="fc" id="L1034">	}</span>

	/**
	 * Sets the name of the last player who privately talked to this player
	 * using the /tell command. It needs to be stored non-persistently so that
	 * /answer can be used.
	 * 
	 * @param lastPrivateChatterName
	 */
	public void setLastPrivateChatter(final String lastPrivateChatterName) {
<span class="nc" id="L1044">		TutorialNotifier.messaged(this);</span>
<span class="nc" id="L1045">		this.lastPrivateChatterName = lastPrivateChatterName;</span>
<span class="nc" id="L1046">	}</span>

	/**
	 * Gets the name of the last player who privately talked to this player
	 * using the /tell command, or null if nobody has talked to this player
	 * since he logged in.
	 * 
	 * @return name of last player
	 */
	public String getLastPrivateChatter() {
<span class="nc" id="L1056">		return lastPrivateChatterName;</span>
	}

	/**
	 * Returns the admin level of this user. See AdministrationAction.java for
	 * details.
	 *
	 * @return adminlevel
	 */
	public int getAdminLevel() {
		// normal user are adminlevel 0.
<span class="fc bfc" id="L1067" title="All 2 branches covered.">		if (!has(ADMINLEVEL)) {</span>
<span class="fc" id="L1068">			return 0;</span>
		}
<span class="fc" id="L1070">		return getInt(ADMINLEVEL);</span>
	}

	/**
	 * Set the player's admin level.
	 *
	 * @param adminlevel
	 *            The new admin level.
	 */
	public void setAdminLevel(final int adminlevel) {
<span class="fc" id="L1080">		put(ADMINLEVEL, adminlevel);</span>
<span class="fc" id="L1081">	}</span>

	@Override
	public void rememberAttacker(final Entity attacker) {
<span class="fc" id="L1085">		TutorialNotifier.attacked(this);</span>
<span class="fc" id="L1086">		super.rememberAttacker(attacker);</span>
<span class="fc" id="L1087">	}</span>

	@Override
	public void onDead(final Killer killer, final boolean remove) {
		/*
		 * Don't try to kill disconnected players. May be triggered on damage
		 * done from turn listeners.
		 */
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">		if (isDisconnected()) {</span>
<span class="nc" id="L1096">			return;</span>
		}
		// Always use remove=false for players, as documented
		// in RPEntity.onDead()
<span class="fc" id="L1100">		super.onDead(killer, false);</span>
<span class="fc" id="L1101">		dieer.onDead(killer);</span>
<span class="fc" id="L1102">	}</span>

	@Override
	protected void dropItemsOn(final Corpse corpse) {
<span class="fc" id="L1106">		dieer.dropItemsOn(corpse);</span>
<span class="fc" id="L1107">	}</span>

	public void removeSheep(final Sheep sheep) {
<span class="nc" id="L1110">		getPetOwner().removeSheep(sheep);</span>
<span class="nc" id="L1111">	}</span>

	public void removePet(final Pet pet) {
<span class="nc" id="L1114">		getPetOwner().removePet(pet);</span>
<span class="nc" id="L1115">	}</span>

	public boolean hasSheep() {
<span class="fc" id="L1118">		return getPetOwner().hasSheep();</span>
	}

	public boolean hasPet() {
<span class="fc" id="L1122">		return getPetOwner().hasPet();</span>
	}

	/**
	 * Set the player's pet. This will also set the pet's owner.
	 *
	 * @param pet
	 *            The pet.
	 */
	public void setPet(final Pet pet) {
<span class="fc" id="L1132">		getPetOwner().setPet(pet);</span>
<span class="fc" id="L1133">	}</span>

	/**
	 * Set the player's sheep. This will also set the sheep's owner.
	 *
	 * @param sheep
	 *            The sheep.
	 */
	public void setSheep(final Sheep sheep) {
<span class="fc" id="L1142">		getPetOwner().setSheep(sheep);</span>
<span class="fc" id="L1143">	}</span>

	/**
	 * Get the player's sheep.
	 *
	 * @return The sheep.
	 */
	public Sheep getSheep() {
<span class="fc" id="L1151">		return getPetOwner().getSheep();</span>
	}

	public Pet getPet() {
<span class="fc" id="L1155">		return getPetOwner().getPet();</span>
	}

	/**
	 * Gets the number of minutes that this player has been logged in on the
	 * server.
	 * 
	 * @return age of player in minutes
	 */
	public int getAge() {
<span class="fc" id="L1165">		return age;</span>
	}

	/**
	 * Is this a new player?
	 *
	 * @return true if it is a new player, false otherwise
	 */
	public boolean isNew() {
<span class="pc bpc" id="L1174" title="7 of 8 branches missed.">		return getAge() &lt; 2 * 60 || getAtk() &lt; 15 || getDef() &lt; 15</span>
				|| getLevel() &lt; 5;
	}

	/**
	 * Sets the number of minutes that this player has been logged in on the
	 * server.
	 *
	 * @param age
	 *            minutes
	 */
	public void setAge(final int age) {
<span class="fc" id="L1186">		this.age = age;</span>
<span class="fc" id="L1187">		put(&quot;age&quot;, age);</span>
<span class="fc" id="L1188">		TutorialNotifier.aged(this, age);</span>
<span class="fc" id="L1189">		SingletonRepository.getAchievementNotifier().onAge(this);</span>
<span class="fc" id="L1190">	}</span>

	/**
	 * Updates the last pvp action time with the current time.
	 */
	public void storeLastPVPActionTime() {
<span class="nc" id="L1196">		put(&quot;last_pvp_action_time&quot;, System.currentTimeMillis());</span>
<span class="nc" id="L1197">	}</span>

	/**
	 * Returns the time the player last did an PVP action.
	 *
	 * @return time in milliseconds
	 */
	public long getLastPVPActionTime() {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">		if (has(&quot;last_pvp_action_time&quot;)) {</span>
<span class="nc" id="L1206">			return (long) Float.parseFloat(get(&quot;last_pvp_action_time&quot;));</span>
		}
<span class="nc" id="L1208">		return -1;</span>
	}

	/**
	 * Notifies this player that the given player has logged in.
	 *
	 * @param who
	 *            The name of the player who has logged in.
	 */
	public void notifyOnline(final String who) {
<span class="fc" id="L1218">		boolean found = false;</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">		if (containsKey(&quot;buddies&quot;, who)) {</span>
<span class="fc" id="L1220">			put(&quot;buddies&quot;, who, true);</span>
<span class="fc" id="L1221">			found = true;</span>
		}
<span class="fc bfc" id="L1223" title="All 2 branches covered.">		if (found) {</span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">			if (has(&quot;online&quot;)) {</span>
<span class="nc" id="L1225">				put(&quot;online&quot;, get(&quot;online&quot;) + &quot;,&quot; + who);</span>
			} else {
<span class="fc" id="L1227">				put(&quot;online&quot;, who);</span>
			}
		}
<span class="fc" id="L1230">	}</span>

	/**
	 * Notifies this player that the given player has logged out.
	 *
	 * @param who
	 *            The name of the player who has logged out.
	 */
	public void notifyOffline(final String who) {
<span class="fc" id="L1239">		boolean found = false;</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">		if (containsKey(&quot;buddies&quot;, who)) {</span>
<span class="fc" id="L1241">			put(&quot;buddies&quot;, who, false);</span>
<span class="fc" id="L1242">			found = true;</span>
		}
<span class="fc bfc" id="L1244" title="All 2 branches covered.">		if (found) {</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">			if (has(&quot;offline&quot;)) {</span>
<span class="nc" id="L1246">				put(&quot;offline&quot;, get(&quot;offline&quot;) + &quot;,&quot; + who);</span>
			} else {
<span class="fc" id="L1248">				put(&quot;offline&quot;, who);</span>
			}
		}
<span class="fc" id="L1251">	}</span>

	/**
	 * Sets the online status for a buddy in the players' buddy list
	 * 
	 * @param buddyName
	 * @param isOnline
	 *            buddy is online?
	 */
	public void setBuddyOnlineStatus(String buddyName, boolean isOnline) {
		// maps handling:
<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (containsKey(&quot;buddies&quot;, buddyName)) {</span>
<span class="nc" id="L1263">			put(&quot;buddies&quot;, buddyName, isOnline);</span>
		}
<span class="nc" id="L1265">	}</span>

	/**
	 * @return true iff this player has buddies (considers only map attribute!)
	 */
	public boolean hasBuddies() {
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">		if (hasMap(&quot;buddies&quot;)) {</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">			return !getMap(&quot;buddies&quot;).isEmpty();</span>
		}

<span class="fc" id="L1275">		return false;</span>
	}

	/**
	 * @return all buddy names for this player
	 */
	public Set&lt;String&gt; getBuddies() {
<span class="fc" id="L1282">		Set&lt;String&gt; buddies = new HashSet&lt;String&gt;();</span>

<span class="pc bpc" id="L1284" title="1 of 2 branches missed.">		if (hasMap(&quot;buddies&quot;)) {</span>
<span class="nc" id="L1285">			buddies.addAll(getMap(&quot;buddies&quot;).keySet());</span>
		}

<span class="fc" id="L1288">		return buddies;</span>
	}

	public int countBuddies() {
<span class="nc bnc" id="L1292" title="All 2 branches missed.">		if (this.hasBuddies()) {</span>
<span class="nc" id="L1293">			return getMap(&quot;buddies&quot;).size();</span>
		}

<span class="nc" id="L1296">		return 0;</span>
	}

	/**
	 * Checks whether the player has completed the given quest or not.
	 *
	 * @param name
	 *            The quest's name
	 * @return true iff the quest has been completed by the player
	 */
	public boolean isQuestCompleted(final String name) {
<span class="fc" id="L1307">		return quests.isQuestCompleted(name);</span>
	}

	/**
	 * Checks whether the player has made any progress in the given quest or
	 * not. For many quests, this is true right after the quest has been
	 * started.
	 *
	 * @param name
	 *            The quest's name
	 * @return true if the player has made any progress in the quest
	 */
	public boolean hasQuest(final String name) {
<span class="fc" id="L1320">		return quests.hasQuest(name);</span>
	}

	/**
	 * Gets the player's current status in the given quest.
	 *
	 * @param name
	 *            The quest's name
	 * @return the player's status in the quest
	 */
	public String getQuest(final String name) {
<span class="fc" id="L1331">		return quests.getQuest(name);</span>
	}

	/**
	 * Gets the player's current status in the given quest.
	 *
	 * @param name
	 *            The quest's name
	 * @param index
	 *            the index of the sub state to change (separated by &quot;;&quot;)
	 * @return the player's status in the quest
	 */
	public String getQuest(final String name, final int index) {
<span class="fc" id="L1344">		return quests.getQuest(name, index);</span>
	}

	/**
	 * Allows to store the player's current status in a quest in a string. This
	 * string may, for instance, be &quot;started&quot;, &quot;done&quot;, a semicolon- separated
	 * list of items that need to be brought/NPCs that need to be met, or the
	 * number of items that still need to be brought. Note that the string
	 * &quot;done&quot; has a special meaning: see isQuestCompleted().
	 *
	 * @param name
	 *            The quest's name
	 * @param status
	 *            the player's status in the quest. Set it to null to completely
	 *            reset the player's status for the quest.
	 */
	public void setQuest(final String name, final String status) {
<span class="fc" id="L1361">		quests.setQuest(name, status);</span>
<span class="fc" id="L1362">	}</span>

	/**
	 * Allows to store the player's current status in a quest in a string. This
	 * string may, for instance, be &quot;started&quot;, &quot;done&quot;, a semicolon- separated
	 * list of items that need to be brought/NPCs that need to be met, or the
	 * number of items that still need to be brought. Note that the string
	 * &quot;done&quot; has a special meaning: see isQuestComplete().
	 *
	 * @param name
	 *            The quest's name
	 * @param index
	 *            the index of the sub state to change (separated by &quot;;&quot;)
	 * @param status
	 *            the player's status in the quest. Set it to null to completely
	 *            reset the player's status for the quest.
	 */
	public void setQuest(final String name, final int index, final String status) {
<span class="fc" id="L1380">		quests.setQuest(name, index, status);</span>
<span class="fc" id="L1381">	}</span>

	public List&lt;String&gt; getQuests() {
<span class="fc" id="L1384">		return quests.getQuests();</span>
	}

	public void removeQuest(final String name) {
<span class="fc" id="L1388">		quests.removeQuest(name);</span>
<span class="fc" id="L1389">	}</span>

	/**
	 * Is the named quest in one of the listed states?
	 *
	 * @param name
	 *            quest
	 * @param states
	 *            valid states
	 * @return true, if the quest is in one of theses states, false otherwise
	 */
	public boolean isQuestInState(final String name, final String... states) {
<span class="fc" id="L1401">		return quests.isQuestInState(name, states);</span>
	}

	/**
	 * Is the named quest in one of the listed states?
	 *
	 * @param name
	 *            quest
	 * @param index
	 *            quest index
	 * @param states
	 *            valid states
	 * @return true, if the quest is in one of theses states, false otherwise
	 */
	public boolean isQuestInState(final String name, final int index,
			final String... states) {
<span class="fc" id="L1417">		return quests.isQuestInState(name, index, states);</span>
	}

	/**
	 * Checks if the player has ever killed a creature, with or without the help
	 * of any other player.
	 *
	 * @param name
	 *            of the creature to check.
	 * @return true iff this player has ever killed this creature.
	 */
	public boolean hasKilled(final String name) {
<span class="fc" id="L1429">		return killRec.hasKilled(name);</span>
	}

	/**
	 * Checks if the player has ever 'solo killed' a creature, i.e. without the
	 * help of any other player.
	 *
	 * @param name
	 *            of the creature to check.
	 * @return true iff this player has ever killed this creature on his own.
	 */
	public boolean hasKilledSolo(final String name) {
<span class="fc" id="L1441">		return killRec.hasKilledSolo(name);</span>
	}

	/**
	 * Checks if the player has ever 'shared killed' a creature, i.e. with the
	 * help of any other player.
	 *
	 * @param name
	 *            of the creature to check.
	 * @return true iff this player has ever killed this creature in a team.
	 */
	public boolean hasKilledShared(final String name) {
<span class="nc" id="L1453">		return killRec.hasKilledShared(name);</span>
	}

	/**
	 * Stores that the player has killed 'name' solo. Overwrites shared kills of
	 * 'name'
	 * 
	 * @param name
	 *            of the victim
	 */
	public void setSoloKill(final String name) {
<span class="fc" id="L1464">		killRec.setSoloKill(name);</span>
<span class="fc" id="L1465">	}</span>

	/**
	 * Stores that the player has killed 'name' with help of others. Does not
	 * overwrite solo kills of 'name'
	 * 
	 * @param name
	 *            of victim
	 *
	 */
	public void setSharedKill(final String name) {
<span class="fc" id="L1476">		killRec.setSharedKill(name);</span>
<span class="fc" id="L1477">	}</span>

	/**
	 * Returns how much the player has killed 'name' solo.
	 * 
	 * @param name
	 *            of the victim
	 * @return number of solo kills
	 */
	public int getSoloKill(final String name) {
<span class="fc" id="L1487">		return killRec.getSoloKill(name);</span>
	}

	/**
	 * Returns how much the player has killed 'name' with help of others.
	 * 
	 * @param name
	 *            of victim
	 * @return number of shared kills
	 */
	public int getSharedKill(final String name) {
<span class="fc" id="L1498">		return killRec.getSharedKill(name);</span>
	}

	@Override
	public String describe() {

		// A special description was specified
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">		if (hasDescription()) {</span>
<span class="nc" id="L1506">			return getDescription();</span>
		}

		// default description for player includes their name, level and play
		// time
<span class="fc" id="L1511">		final String name = getTitle();</span>
<span class="fc" id="L1512">		final int hours = age / 60;</span>
<span class="fc" id="L1513">		final int minutes = age % 60;</span>
<span class="fc" id="L1514">		final String time = hours + &quot; hours and &quot; + minutes + &quot; minutes&quot;;</span>
<span class="fc" id="L1515">		final String text = &quot;You see &quot; + name + &quot;.\n&quot; + name + &quot; is level &quot;</span>
				+ getLevel() + &quot; and has been playing &quot; + time + &quot;.&quot;;
<span class="fc" id="L1517">		final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L1518">		sb.append(text);</span>
<span class="fc" id="L1519">		final String awayMessage = getAwayMessage();</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">		if (awayMessage != null) {</span>
<span class="fc" id="L1521">			sb.append(&quot;\n&quot; + name + &quot; is away and has left a message: &quot;);</span>
<span class="fc" id="L1522">			sb.append(awayMessage);</span>
		}
<span class="fc" id="L1524">		final String grumpyMessage = getGrumpyMessage();</span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">		if (grumpyMessage != null) {</span>
<span class="fc" id="L1526">			sb.append(&quot;\n&quot; + name + &quot; is grumpy and has left a message: &quot;);</span>
<span class="fc" id="L1527">			sb.append(grumpyMessage);</span>
		}

		/* Show a sentence set by player if not away or grumpy */
<span class="fc bfc" id="L1531" title="All 4 branches covered.">		if ((awayMessage == null) &amp;&amp; (grumpyMessage == null)) {</span>
<span class="fc" id="L1532">			final String sentence = getSentence();</span>
<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">			if (!sentence.isEmpty()) {</span>
<span class="nc" id="L1534">				sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L1535">				sb.append(Grammar.suffix_s(name));</span>
<span class="nc" id="L1536">				sb.append(&quot; sentence is: \&quot;&quot; + sentence + &quot;\&quot;&quot;);</span>
			}
		}

<span class="fc" id="L1540">		return sb.toString();</span>
	}

	/**
	 * Teleports this player to the given destination.
	 *
	 * @param zone
	 *            The zone where this player should be teleported to.
	 * @param x
	 *            The destination's x coordinate
	 * @param y
	 *            The destination's y coordinate
	 * @param dir
	 *            The direction in which the player should look after
	 *            teleporting, or null if the direction shouldn't change
	 * @param teleporter
	 *            The player who initiated the teleporting, or null if no player
	 *            is responsible. This is only to give feedback if something
	 *            goes wrong. If no feedback is wanted, use null.
	 * @return true iff teleporting was successful
	 */
	public boolean teleport(final StendhalRPZone zone, final int x,
			final int y, final Direction dir, final Player teleporter) {
<span class="fc bfc" id="L1563" title="All 2 branches covered.">		if (StendhalRPAction.placeat(zone, this, x, y)) {</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">			if (dir != null) {</span>
<span class="fc" id="L1565">				this.setDirection(dir);</span>
			}
<span class="fc" id="L1567">			notifyWorldAboutChanges();</span>
<span class="fc" id="L1568">			return true;</span>
		} else {
<span class="fc" id="L1570">			final String text = &quot;Position [&quot; + x + &quot;,&quot; + y + &quot;] is occupied&quot;;</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">			if (teleporter != null) {</span>
<span class="fc" id="L1572">				teleporter.sendPrivateText(text);</span>
			} else {
<span class="fc" id="L1574">				this.sendPrivateText(text);</span>
			}
<span class="fc" id="L1576">			return false;</span>
		}

	}

	/**
	 * Called when player push entity. The entity displacement is handled by the
	 * action itself.
	 *
	 * @param entity
	 */
	public void onPush(final RPEntity entity) {
<span class="fc" id="L1588">		turnOfLastPush = SingletonRepository.getRuleProcessor().getTurn();</span>
<span class="fc" id="L1589">	}</span>

	/**
	 * Return true if player can push entity.
	 *
	 * @param entity
	 * @return true iff pushing is possible
	 */
	public boolean canPush(final RPEntity entity) {
<span class="pc bpc" id="L1598" title="1 of 4 branches missed.">		return this != entity</span>
				&amp;&amp; SingletonRepository.getRuleProcessor().getTurn()
						- turnOfLastPush &gt; 10;
	}

	@Override
	public void setOutfit(final Outfit outfit) {
<span class="fc" id="L1605">		setOutfit(outfit, false);</span>
<span class="fc" id="L1606">	}</span>

	/**
	 * Makes this player wear the given outfit. If the given outfit contains
	 * null parts, the current outfit will be kept for these parts. If the
	 * outfit change includes any colors, they should be changed &lt;b&gt;after&lt;/b&gt;
	 * calling this.
	 *
	 * @param outfit
	 *            The new outfit.
	 * @param temporary
	 *            If true, the original outfit will be stored so that it can be
	 *            restored later.
	 */
	public void setOutfit(final Outfit outfit, final boolean temporary) {
		// if the new outfit is temporary and the player is not wearing
		// a temporary outfit already, store the current outfit in a
		// second slot so that we can return to it later.
<span class="pc bpc" id="L1624" title="1 of 4 branches missed.">		if (temporary &amp;&amp; !has(&quot;outfit_org&quot;)) {</span>
<span class="fc" id="L1625">			put(&quot;outfit_org&quot;, get(&quot;outfit&quot;));</span>

			// remember the old color selections.
<span class="fc bfc" id="L1628" title="All 2 branches covered.">			for (String part : RECOLORABLE_OUTFIT_PARTS) {</span>
<span class="fc" id="L1629">				String tmp = part + &quot;_orig&quot;;</span>
<span class="fc" id="L1630">				String color = get(&quot;outfit_colors&quot;, part);</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">				if (color != null) {</span>
<span class="fc" id="L1632">					put(&quot;outfit_colors&quot;, tmp, color);</span>
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">					if (!&quot;hair&quot;.equals(part)) {</span>
<span class="fc" id="L1634">						remove(&quot;outfit_colors&quot;, part);</span>
					}
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">				} else if (has(&quot;outfit_colors&quot;, tmp)) {</span>
					// old saved colors need to be cleared in any case
<span class="nc" id="L1638">					remove(&quot;outfit_colors&quot;, tmp);</span>
				}
			}
		}

		// if the new outfit is not temporary, remove the backup
<span class="fc bfc" id="L1644" title="All 4 branches covered.">		if (!temporary &amp;&amp; has(&quot;outfit_org&quot;)) {</span>
<span class="fc" id="L1645">			remove(&quot;outfit_org&quot;);</span>

			// clear colors
<span class="fc bfc" id="L1648" title="All 2 branches covered.">			for (String part : RECOLORABLE_OUTFIT_PARTS) {</span>
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">				if (has(&quot;outfit_colors&quot;, part)) {</span>
<span class="nc" id="L1650">					remove(&quot;outfit_colors&quot;, part);</span>
				}
			}
		}

		// combine the old outfit with the new one, as the new one might
		// contain null parts.
<span class="fc" id="L1657">		final Outfit newOutfit = outfit.putOver(getOutfit());</span>
<span class="fc" id="L1658">		put(&quot;outfit&quot;, newOutfit.getCode());</span>
<span class="fc" id="L1659">		notifyWorldAboutChanges();</span>
<span class="fc" id="L1660">	}</span>

	public Outfit getOriginalOutfit() {
<span class="fc bfc" id="L1663" title="All 2 branches covered.">		if (has(&quot;outfit_org&quot;)) {</span>
<span class="fc" id="L1664">			return new Outfit(getInt(&quot;outfit_org&quot;));</span>
		}
		
<span class="fc" id="L1667">		return null;</span>
	}

	/**
	 * Tries to give the player his original outfit back after he has put on a
	 * temporary outfit. This will only be successful if the original outfit has
	 * been stored.
	 *
	 * @return true iff returning was successful.
	 */
	public boolean returnToOriginalOutfit() {
<span class="fc" id="L1678">		removeOutfitExpireNotification();</span>

<span class="fc" id="L1680">		final Outfit originalOutfit = getOriginalOutfit();</span>
<span class="fc bfc" id="L1681" title="All 2 branches covered.">		if (originalOutfit != null) {</span>

			// do not restore details layer, unless the detail is still present
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">			if (originalOutfit.getDetail() &gt; 0) {</span>
<span class="nc" id="L1685">				final Outfit currentOutfit = getOutfit();</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">				if (!currentOutfit.getDetail().equals(</span>
						originalOutfit.getDetail())) {
<span class="nc" id="L1688">					originalOutfit.removeDetail();</span>
				}
			}

<span class="fc" id="L1692">			remove(&quot;outfit_org&quot;);</span>
<span class="fc" id="L1693">			setOutfit(originalOutfit, false);</span>

			// restore old colors
<span class="fc bfc" id="L1696" title="All 2 branches covered.">			for (String part : RECOLORABLE_OUTFIT_PARTS) {</span>
<span class="fc" id="L1697">				String tmp = part + &quot;_orig&quot;;</span>
<span class="fc" id="L1698">				String color = get(&quot;outfit_colors&quot;, tmp);</span>
<span class="fc bfc" id="L1699" title="All 2 branches covered.">				if (color != null) {</span>
<span class="fc" id="L1700">					put(&quot;outfit_colors&quot;, part, color);</span>
<span class="fc" id="L1701">					remove(&quot;outfit_colors&quot;, tmp);</span>
<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">				} else if (has(&quot;outfit_colors&quot;, part)) {</span>
					// clear any colors from the temporary outfit if there was
					// no saved color
<span class="nc" id="L1705">					remove(&quot;outfit_colors&quot;, part);</span>
				}
			}
<span class="fc" id="L1708">			return true;</span>
		}
<span class="fc" id="L1710">		return false;</span>
	}

	private void removeOutfitExpireNotification() {
<span class="fc" id="L1714">		ExpireOutfit expireOutfit = new ExpireOutfit(getName());</span>
<span class="fc" id="L1715">		SingletonRepository.getTurnNotifier().dontNotify(expireOutfit);</span>

<span class="fc" id="L1717">		remove(&quot;outfit_expire_age&quot;);</span>
<span class="fc" id="L1718">	}</span>

	//
	// ActiveEntity
	//

	/**
	 * Determine if zone changes are currently allowed via normal means
	 * (non-portal teleportation doesn't count).
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if the entity can change zones.
	 */
	@Override
	public boolean isZoneChangeAllowed() {
		/*
		 * If we are too far from dependents, then disallow zone change
		 */
<span class="fc" id="L1735">		final Sheep sheep = getSheep();</span>

<span class="pc bpc" id="L1737" title="1 of 2 branches missed.">		if (sheep != null) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">			if (squaredDistance(sheep) &gt; 7 * 7) {</span>
<span class="nc" id="L1739">				return false;</span>
			}
		}

<span class="fc" id="L1743">		final Pet pet = getPet();</span>

<span class="pc bpc" id="L1745" title="1 of 2 branches missed.">		if (pet != null) {</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">			if (squaredDistance(pet) &gt; 7 * 7) {</span>
<span class="nc" id="L1747">				return false;</span>
			}
		}

<span class="fc" id="L1751">		return true;</span>
	}

	//
	// Entity
	//

	/**
	 * Perform cycle logic.
	 */
	@Override
	public void logic() {
		/*
		 * TODO: Refactor Most of these things can be handled as RPEvents
		 */
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">		if (has(&quot;risk&quot;)) {</span>
<span class="nc" id="L1767">			remove(&quot;risk&quot;);</span>
<span class="nc" id="L1768">			notifyWorldAboutChanges();</span>
		}

<span class="pc bpc" id="L1771" title="1 of 2 branches missed.">		if (has(&quot;damage&quot;)) {</span>
<span class="nc" id="L1772">			remove(&quot;damage&quot;);</span>
<span class="nc" id="L1773">			notifyWorldAboutChanges();</span>
		}

<span class="pc bpc" id="L1776" title="1 of 2 branches missed.">		if (has(&quot;heal&quot;)) {</span>
<span class="nc" id="L1777">			remove(&quot;heal&quot;);</span>
<span class="nc" id="L1778">			notifyWorldAboutChanges();</span>
		}

<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">		if (has(&quot;dead&quot;)) {</span>
<span class="nc" id="L1782">			remove(&quot;dead&quot;);</span>
<span class="nc" id="L1783">			notifyWorldAboutChanges();</span>
		}

<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">		if (has(&quot;online&quot;)) {</span>
<span class="nc" id="L1787">			remove(&quot;online&quot;);</span>
<span class="nc" id="L1788">			notifyWorldAboutChanges();</span>
		}

<span class="pc bpc" id="L1791" title="1 of 2 branches missed.">		if (has(&quot;offline&quot;)) {</span>
<span class="nc" id="L1792">			remove(&quot;offline&quot;);</span>
<span class="nc" id="L1793">			notifyWorldAboutChanges();</span>
		}

<span class="fc" id="L1796">		applyMovement();</span>

<span class="fc" id="L1798">		final int turn = SingletonRepository.getRuleProcessor().getTurn();</span>

<span class="pc bpc" id="L1800" title="1 of 4 branches missed.">		if (isAttacking() &amp;&amp; turn % getAttackRate() == 0) {</span>
<span class="fc" id="L1801">			RPEntity attackTarget = getAttackTarget();</span>

			// Face target if player is not moving
<span class="pc bpc" id="L1804" title="2 of 6 branches missed.">			if (stopped() &amp;&amp; isInSight(attackTarget)</span>
					&amp;&amp; !isFacingToward(attackTarget)) {
<span class="fc" id="L1806">				faceToward(attackTarget);</span>
<span class="fc" id="L1807">				notifyWorldAboutChanges();</span>
			}

<span class="fc" id="L1810">			StendhalRPAction.playerAttack(this, attackTarget);</span>
		}

<span class="fc" id="L1813">		agePlayer(turn);</span>
<span class="fc" id="L1814">	}</span>

	private void agePlayer(final int turn) {
		/*
		 * 200 means 60 seconds x 300mx per turn.
		 */
<span class="fc bfc" id="L1820" title="All 2 branches covered.">		if (!isGhost()) {</span>
<span class="pc bpc" id="L1821" title="1 of 2 branches missed.">			if (turn % 200 == 0) {</span>
<span class="fc" id="L1822">				setAge(getAge() + 1);</span>
<span class="fc" id="L1823">				notifyWorldAboutChanges();</span>
			}
		}
<span class="fc" id="L1826">	}</span>

	/**
	 * Checks whether an entity is a ghost (non physically interactive).
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if in ghost mode.
	 */
	@Override
	public boolean isGhost() {
<span class="fc" id="L1835">		return has(GHOSTMODE);</span>
	}

	/**
	 * Set whether this player is a ghost (invisible/non-interactive).
	 *
	 * @param ghost
	 *            &lt;code&gt;true&lt;/code&gt; if a ghost.
	 */
	public void setGhost(final boolean ghost) {
<span class="fc bfc" id="L1845" title="All 2 branches covered.">		if (ghost) {</span>
<span class="fc" id="L1846">			put(GHOSTMODE, &quot;&quot;);</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">		} else if (has(GHOSTMODE)) {</span>
<span class="fc" id="L1848">			remove(GHOSTMODE);</span>
		}
<span class="fc" id="L1850">	}</span>

	/**
	 * Checks whether a player has teleclick enabled.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if teleclick is enabled.
	 */
	public boolean isTeleclickEnabled() {
<span class="fc" id="L1858">		return has(TELECLICKMODE);</span>
	}

	/**
	 * Set whether this player has teleclick enabled.
	 *
	 * @param teleclick
	 *            &lt;code&gt;true&lt;/code&gt; if teleclick enabled.
	 */
	public void setTeleclickEnabled(final boolean teleclick) {
<span class="fc bfc" id="L1868" title="All 2 branches covered.">		if (teleclick) {</span>
<span class="fc" id="L1869">			put(TELECLICKMODE, &quot;&quot;);</span>
<span class="fc bfc" id="L1870" title="All 2 branches covered.">		} else if (has(TELECLICKMODE)) {</span>
<span class="fc" id="L1871">			remove(TELECLICKMODE);</span>
		}
<span class="fc" id="L1873">	}</span>

	/**
	 * Called when this object is added to a zone.
	 *
	 * @param zone
	 *            The zone this was added to.
	 */
	@Override
	public void onAdded(final StendhalRPZone zone) {
<span class="fc" id="L1883">		super.onAdded(zone);</span>

<span class="fc" id="L1885">		final String zoneName = zone.getID().getID();</span>

		/*
		 * If player enters afterlife, make them partially transparent
		 */
<span class="fc bfc" id="L1890" title="All 2 branches covered.">		if (zoneName.equals(PlayerDieer.DEFAULT_DEAD_AREA)) {</span>
<span class="fc" id="L1891">			setVisibility(50);</span>
		}

		/*
		 * Remember zones we've been in
		 */
<span class="fc" id="L1897">		setKeyedSlot(&quot;!visited&quot;, zoneName,</span>
				Long.toString(System.currentTimeMillis()));
<span class="fc" id="L1899">		trade.cancelTrade();</span>
<span class="fc" id="L1900">	}</span>

	/**
	 * Called when this object is being removed from a zone.
	 *
	 * @param zone
	 *            The zone this will be removed from.
	 */
	@Override
	public void onRemoved(final StendhalRPZone zone) {
		/*
		 * If player leaves afterlife, make them normal
		 */
<span class="fc bfc" id="L1913" title="All 2 branches covered.">		if (zone.getID().getID().equals(PlayerDieer.DEFAULT_DEAD_AREA)) {</span>
<span class="fc" id="L1914">			setVisibility(100);</span>
		}

<span class="fc" id="L1917">		super.onRemoved(zone);</span>
<span class="fc" id="L1918">	}</span>

	//
	// Object
	//
	@Override
	public int hashCode() {
		// player names are unique, so we can use the name's hash code.
<span class="fc" id="L1926">		return getName().toLowerCase().hashCode();</span>
	}

	@Override
	public boolean equals(final Object obj) {
<span class="fc bfc" id="L1931" title="All 2 branches covered.">		if (this == obj) {</span>
<span class="fc" id="L1932">			return true;</span>
		}
<span class="fc bfc" id="L1934" title="All 2 branches covered.">		if (obj instanceof Player) {</span>
<span class="fc" id="L1935">			final Player other = (Player) obj;</span>
<span class="fc" id="L1936">			return this.getName().toLowerCase(Locale.ENGLISH)</span>
					.equals(other.getName().toLowerCase(Locale.ENGLISH));
		}
<span class="fc" id="L1939">		return false;</span>
	}

	// use a short readable output instead of the completed RPObject with all
	// its attributes and slots. You can use /inspect &lt;player&gt; in game to get
	// that.
	@Override
	public String toString() {
<span class="fc" id="L1947">		return &quot;Player [&quot; + getName() + &quot;, &quot; + hashCode() + &quot;]&quot;;</span>
	}

	/**
	 * sets the player sentence
	 *
	 * @param sentence
	 *            sentence to store
	 */
	public void setSentence(final String sentence) {
<span class="fc" id="L1957">		put(&quot;sentence&quot;, sentence);</span>
<span class="fc" id="L1958">	}</span>

	/**
	 * gets the player sentence displayed on the web site
	 *
	 * @return player sentence
	 */
	public String getSentence() {
<span class="fc" id="L1966">		String result = &quot;&quot;;</span>
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">		if (has(&quot;sentence&quot;)) {</span>
<span class="nc" id="L1968">			result = get(&quot;sentence&quot;);</span>
		}

<span class="fc" id="L1971">		return result;</span>
	}

<span class="fc" id="L1974">	private boolean disconnected = false;</span>
	private UseListener useListener;

	/**
	 * checks whether this client is flagged as disconnected
	 *
	 * @return true, if the client is disconnected; false otherwise.
	 */
	public boolean isDisconnected() {
<span class="fc" id="L1983">		return disconnected;</span>
	}

	/**
	 * sets the client version
	 *
	 * @param version
	 */
	public void setClientVersion(String version) {
<span class="fc" id="L1992">		this.clientVersion = version;</span>
<span class="fc" id="L1993">	}</span>

	/**
	 * checks if the client is newer than the requested version
	 *
	 * @param version
	 *            requested version
	 * @return check the client is newer
	 */
	public boolean isClientNewerThan(String version) {
<span class="pc bpc" id="L2003" title="1 of 2 branches missed.">		if (clientVersion == null) {</span>
<span class="nc" id="L2004">			return false;</span>
		}
<span class="fc bfc" id="L2006" title="All 2 branches covered.">		return Version.compare(clientVersion, version) &gt; 0;</span>
	}

	/**
	 * gets a list of all rings of life that are not broken
	 *
	 * @return list of rings of life
	 */
	public List&lt;RingOfLife&gt; getAllEquippedWorkingRingOfLife() {
<span class="fc" id="L2015">		final List&lt;RingOfLife&gt; result = new LinkedList&lt;RingOfLife&gt;();</span>

<span class="fc bfc" id="L2017" title="All 2 branches covered.">		for (RPSlot slot : this.slots(Slots.CARRYING)) {</span>

<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">			for (final RPObject object : slot) {</span>
<span class="nc" id="L2020">				searchForWorkingRingsOfLife(object, result);</span>
<span class="nc" id="L2021">			}</span>
<span class="fc" id="L2022">		}</span>

<span class="fc" id="L2024">		return result;</span>
	}

	/**
	 * Search recursively for working rings of life inside objects and their
	 * content slots.
	 *
	 * @param obj
	 * @param list
	 */
	private void searchForWorkingRingsOfLife(RPObject obj, List&lt;RingOfLife&gt; list) {
<span class="nc bnc" id="L2035" title="All 2 branches missed.">		if (obj instanceof RingOfLife) {</span>
<span class="nc" id="L2036">			RingOfLife ring = (RingOfLife) obj;</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">			if (!ring.isBroken()) {</span>
<span class="nc" id="L2038">				list.add(ring);</span>
			}
<span class="nc" id="L2040">		} else {</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">			for (RPSlot slot : obj.slots()) {</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">				for (RPObject subobj : slot) {</span>
<span class="nc" id="L2043">					searchForWorkingRingsOfLife(subobj, list);</span>
<span class="nc" id="L2044">				}</span>
<span class="nc" id="L2045">			}</span>
		}
<span class="nc" id="L2047">	}</span>

	/**
	 * Return a list of all animals associated to this player.
	 *
	 * @return List of DomesticalAnmial
	 */
	public List&lt;DomesticAnimal&gt; getAnimals() {
<span class="fc" id="L2055">		final List&lt;DomesticAnimal&gt; animals = new ArrayList&lt;DomesticAnimal&gt;();</span>

<span class="fc bfc" id="L2057" title="All 2 branches covered.">		if (hasPet()) {</span>
<span class="fc" id="L2058">			animals.add(getPet());</span>
		}

<span class="fc bfc" id="L2061" title="All 2 branches covered.">		if (hasSheep()) {</span>
<span class="fc" id="L2062">			animals.add(getSheep());</span>
		}

<span class="fc" id="L2065">		return animals;</span>
	}

	/**
	 * Search for an animal with the given name or type.
	 *
	 * @param name
	 *            the name or type of the pet to search
	 * @param exactly
	 *            &lt;code&gt;true&lt;/code&gt; if looking only for matching name instead of
	 *            both name and type.
	 * @return the found pet
	 */
	public DomesticAnimal searchAnimal(final String name, final boolean exactly) {
<span class="fc" id="L2079">		final List&lt;DomesticAnimal&gt; animals = getAnimals();</span>

<span class="fc bfc" id="L2081" title="All 2 branches covered.">		for (final DomesticAnimal animal : animals) {</span>
<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">			if (animal != null) {</span>
<span class="fc bfc" id="L2083" title="All 2 branches covered.">				if (animal.getTitle().equalsIgnoreCase(name)) {</span>
<span class="fc" id="L2084">					return animal;</span>
				}

<span class="fc bfc" id="L2087" title="All 2 branches covered.">				if (!exactly) {</span>
<span class="fc" id="L2088">					final String type = animal.get(&quot;type&quot;);</span>
<span class="pc bpc" id="L2089" title="1 of 4 branches missed.">					if (type != null</span>
							&amp;&amp; ItemTools.itemNameToDisplayName(type).equals(
									name)) {
<span class="fc" id="L2092">						return animal;</span>
					}

<span class="fc bfc" id="L2095" title="All 2 branches covered.">					if (&quot;pet&quot;.equals(name)) {</span>
<span class="fc" id="L2096">						return animal;</span>
					}
				}
			}
<span class="fc" id="L2100">		}</span>

<span class="fc" id="L2102">		return null;</span>
	}

	@Override
	protected void applyDefXP(final RPEntity entity) {
<span class="fc bfc" id="L2107" title="All 2 branches covered.">		if (getsFightXpFrom(entity)) {</span>
<span class="fc" id="L2108">			incDefXP();</span>
		}
<span class="fc" id="L2110">	}</span>

	@Override
	protected void handleObjectCollision() {
<span class="nc bnc" id="L2114" title="All 2 branches missed.">		if (hasPath()) {</span>
<span class="nc" id="L2115">			reroute();</span>
		}
<span class="nc" id="L2117">	}</span>

	// public boolean isImmune() {
	// return isImmune;
	// }

	void setLastPlayerKill(final long milliseconds) {
<span class="fc" id="L2124">		put(LAST_PLAYER_KILL_TIME, milliseconds);</span>
<span class="fc" id="L2125">	}</span>

	public boolean isBadBoy() {
<span class="fc" id="L2128">		return has(LAST_PLAYER_KILL_TIME);</span>
	}

	/**
	 * Returns the time the player last did a player kill.
	 *
	 * @return time in milliseconds
	 */
	public long getLastPlayerKillTime() {
<span class="nc bnc" id="L2137" title="All 2 branches missed.">		if (has(LAST_PLAYER_KILL_TIME)) {</span>
<span class="nc" id="L2138">			return (long) Float.parseFloat(get(LAST_PLAYER_KILL_TIME));</span>
		}
<span class="nc" id="L2140">		return -1;</span>
	}

	public void rehabilitate() {
<span class="fc" id="L2144">		remove(LAST_PLAYER_KILL_TIME);</span>

<span class="fc" id="L2146">	}</span>

	@Override
	protected void rewardKillers(final int oldXP) {
		// Don't reward for killing players
		// process tutorial event for first player kill

<span class="pc bpc" id="L2153" title="1 of 2 branches missed.">		for (Entry&lt;Entity, Integer&gt; entry : damageReceived.entrySet()) {</span>
<span class="nc bnc" id="L2154" title="All 2 branches missed.">			if (entry.getValue() == 0) {</span>
<span class="nc" id="L2155">				continue;</span>
			}
<span class="nc" id="L2157">			Player killer = entityAsOnlinePlayer(entry.getKey());</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">			if (killer != null) {</span>
<span class="nc" id="L2159">				TutorialNotifier.killedPlayer(killer);</span>
			}
<span class="nc" id="L2161">		}</span>
<span class="fc" id="L2162">	}</span>

	public PetOwner getPetOwner() {
<span class="fc" id="L2165">		return petOwner;</span>
	}

	public boolean isBoundTo(final Item item) {
<span class="fc" id="L2169">		return getName().equals(item.getBoundTo());</span>
	}

	/**
	 * gets the PlayerChatBucket
	 *
	 * @return PlayerChatBucket
	 */
	public PlayerChatBucket getChatBucket() {
<span class="fc" id="L2178">		return chatBucket;</span>
	}

	@Override
	public Nature getDamageType() {
		// Use the damage type of arrows, if the player is shooting with them
<span class="pc bpc" id="L2184" title="1 of 2 branches missed.">		if (getRangeWeapon() != null) {</span>
<span class="nc" id="L2185">			Item missile = getAmmunition();</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">			if (missile != null) {</span>
<span class="nc" id="L2187">				return missile.getDamageType();</span>
			}
		}
<span class="fc" id="L2190">		Item weapon = getWeapon();</span>
<span class="fc bfc" id="L2191" title="All 2 branches covered.">		if (weapon != null) {</span>
<span class="fc" id="L2192">			return weapon.getDamageType();</span>
		}

<span class="fc" id="L2195">		return Nature.CUT;</span>
	}

	@Override
	protected double getSusceptibility(Nature type) {
<span class="fc" id="L2200">		double sus = 1.0;</span>
		/*
		 * check weapon and shield separately, so that holding 2 resistant
		 * shields does not help
		 */
<span class="fc" id="L2205">		Item weapon = getWeapon();</span>
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">		if (weapon != null) {</span>
<span class="nc" id="L2207">			sus *= weapon.getSusceptibility(type);</span>
		}
<span class="fc" id="L2209">		Item shield = getShield();</span>
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">		if (shield != null) {</span>
<span class="nc" id="L2211">			sus *= shield.getSusceptibility(type);</span>
		}

<span class="fc" id="L2214">		String[] armorSlots = { &quot;armor&quot;, &quot;head&quot;, &quot;legs&quot;, &quot;feet&quot;, &quot;cloak&quot; };</span>
<span class="fc bfc" id="L2215" title="All 2 branches covered.">		for (String slot : armorSlots) {</span>
<span class="fc" id="L2216">			RPObject object = getSlot(slot).getFirst();</span>
<span class="fc bfc" id="L2217" title="All 2 branches covered.">			if (object instanceof Item) {</span>
<span class="fc" id="L2218">				sus *= ((Item) object).getSusceptibility(type);</span>
			}
		}

<span class="fc" id="L2222">		return sus;</span>
	}

	/**
	 * adds a buddy to the player's buddy list
	 *
	 * @param name
	 *            the name of the buddy
	 * @param online
	 *            if the player is online
	 * @return true if the buddy has been added
	 */
	public boolean addBuddy(String name, boolean online) {
<span class="nc bnc" id="L2235" title="All 4 branches missed.">		boolean isNew = !hasMap(&quot;buddies&quot;)</span>
				|| !getMap(&quot;buddies&quot;).containsKey(name);

<span class="nc" id="L2238">		put(&quot;buddies&quot;, name, online);</span>

<span class="nc" id="L2240">		return isNew;</span>
	}

	/**
	 * removes a buddy to the player's buddy list
	 *
	 * @param name
	 *            the name of the buddy
	 * @return true if a buddy was removed
	 */
	public boolean removeBuddy(String name) {
<span class="nc bnc" id="L2251" title="All 2 branches missed.">		return remove(&quot;buddies&quot;, name) != null;</span>
	}

	@Override
	public void setLevel(int level) {
<span class="fc" id="L2256">		final int oldLevel = super.getLevel();</span>
<span class="fc" id="L2257">		super.setLevel(level);</span>

		// reward players on level up
<span class="fc bfc" id="L2260" title="All 2 branches covered.">		if (oldLevel &lt; level) {</span>
<span class="fc" id="L2261">			AchievementNotifier.get().onLevelChange(this);</span>
<span class="fc" id="L2262">			this.addEvent(new SoundEvent(&quot;tadaa-1&quot;, SoundLayer.USER_INTERFACE));</span>
<span class="fc" id="L2263">			this.notifyWorldAboutChanges();</span>
		}
<span class="fc" id="L2265">	}</span>

	/**
	 * Adds the identifier of an achievement to the reached achievements
	 *
	 * @param identifier
	 */
	public void addReachedAchievement(String identifier) {
<span class="fc" id="L2273">		getAchievements().add(identifier);</span>
<span class="fc" id="L2274">	}</span>

	private Set&lt;String&gt; getAchievements() {
<span class="fc" id="L2277">		return reachedAchievements;</span>
	}

	public void initReachedAchievements() {
<span class="fc" id="L2281">		reachedAchievements = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L2282">	}</span>

	/**
	 * checks if the achievements of this player object are already loaded
	 *
	 * @return true, if the achievement set is loaded, false otherwise
	 */
	public boolean arePlayerAchievementsLoaded() {
<span class="nc bnc" id="L2290" title="All 2 branches missed.">		return reachedAchievements != null;</span>
	}

	/**
	 * Checks if a player has reached the achievement with the given identifier
	 *
	 * @param identifier
	 * @return true if player had reached the achievement with the given
	 *         identifier
	 */
	public boolean hasReachedAchievement(String identifier) {
<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">		if (getAchievements() != null) {</span>
<span class="fc" id="L2302">			return getAchievements().contains(identifier);</span>
		} else {
			// if there were no reached achievements at all then the achievement
			// can't have been reached
<span class="nc" id="L2306">			return false;</span>
		}
	}

	/**
	 * Checks if the player has visited the given zone
	 * 
	 * @param zone
	 *            the zone to check for
	 * @return true if player visited the zone
	 */
	public boolean hasVisitedZone(StendhalRPZone zone) {
<span class="nc bnc" id="L2318" title="All 2 branches missed.">		return null != getKeyedSlot(&quot;!visited&quot;, zone.getName());</span>
	}

	/**
	 * offers the other player to start a trading session
	 *
	 * @param partner
	 *            to offer the trade to
	 */
	public void offerTrade(Player partner) {
<span class="nc" id="L2328">		trade.offerTrade(partner);</span>
<span class="nc" id="L2329">	}</span>

	/**
	 * gets the state of player to player trades
	 *
	 * @return TradeState
	 */
	public TradeState getTradeState() {
<span class="fc" id="L2337">		return trade.getTradeState();</span>
	}

	/**
	 * gets the partner of a player to player trade
	 *
	 * @return name of partner or &lt;code&gt;null&lt;/code&gt; if no trade is ongoing
	 */
	protected String getTradePartner() {
<span class="nc" id="L2346">		return trade.getPartnerName();</span>
	}

	/**
	 * starts a trade with this partner
	 *
	 * @param partner
	 *            partner to trade with
	 */
	protected void startTrade(Player partner) {
<span class="nc" id="L2356">		trade.startTrade(partner);</span>
<span class="nc" id="L2357">	}</span>

	/**
	 * cancels a trade and moves the items back.
	 *
	 * @param partnerName
	 *            name of partner (to make sure the correct trade offer is
	 *            canceled)
	 */
	public void cancelTradeInternally(String partnerName) {
<span class="fc" id="L2367">		trade.cancelTradeInternally(partnerName);</span>
<span class="fc" id="L2368">	}</span>

	/**
	 * completes a trade internally.
	 */
	void completeTradeInternally() {
<span class="nc" id="L2374">		trade.completeTradeInternally();</span>
<span class="nc" id="L2375">	}</span>

	/**
	 * unlocks a trade item offer for example because of some modifications on
	 * the trade slot.
	 */
	public void unlockTradeItemOffer() {
<span class="nc" id="L2382">		trade.unlockItemOffer();</span>
<span class="nc" id="L2383">	}</span>

	/**
	 * internally unlocks
	 *
	 * @param partnerName
	 *            name of partner (to make sure the correct trade offer is
	 *            canceled)
	 * @return true, if a trade was unlocked, false if it was already unlocked
	 */
	boolean unlockTradeItemOfferInternally(String partnerName) {
<span class="nc" id="L2394">		return trade.unlockItemOfferInternally(partnerName);</span>
	}

	/**
	 * locks the item offer.
	 */
	public void lockTrade() {
<span class="nc" id="L2401">		trade.lockItemOffer();</span>
<span class="nc" id="L2402">	}</span>

	/**
	 * accepts the trade if both offers are locked.
	 */
	public void dealTrade() {
<span class="nc" id="L2408">		trade.deal();</span>
<span class="nc" id="L2409">	}</span>

	/**
	 * cancels a trade or trade offer.
	 */
	public void cancelTrade() {
<span class="nc" id="L2415">		trade.cancelTrade();</span>
<span class="nc" id="L2416">	}</span>

	/**
	 * Gets the how often this player has looted the given item
	 *
	 * @param item
	 *            the item name
	 * @return the number of loots from corpses
	 */
	public int getNumberOfLootsForItem(String item) {
<span class="fc" id="L2426">		return itemCounter.getNumberOfLootsForItem(item);</span>
	}

	/**
	 * Gets the amount a player as produced of an item
	 *
	 * @param item
	 *            the item name
	 * @return the produced amount
	 */
	public int getQuantityOfProducedItems(String item) {
<span class="fc" id="L2437">		return itemCounter.getQuantityOfProducedItems(item);</span>
	}

	/**
	 * Gets the amount a player as mined of an item
	 *
	 * @param item
	 *            the item name
	 * @return the mined amount
	 */
	public int getQuantityOfMinedItems(String item) {
<span class="fc" id="L2448">		return itemCounter.getQuantityOfMinedItems(item);</span>
	}

	/**
	 * Gets the amount a player has harvested of an item
	 *
	 * @param item
	 *            the item name
	 * @return the harvested amount
	 */
	public int getQuantityOfHarvestedItems(String item) {
<span class="fc" id="L2459">		return itemCounter.getQuantityOfHarvestedItems(item);</span>
	}

	/**
	 * @return the whole number of items a player has obtained from the well
	 */
	public int getQuantityOfObtainedItems() {
<span class="nc" id="L2466">		return itemCounter.getQuantityOfObtainedItems();</span>
	}

	/**
	 * Increases the count of loots for the given item
	 * 
	 * @param item
	 *            the item name
	 * @param count
	 */
	public void incLootForItem(String item, int count) {
<span class="fc" id="L2477">		itemCounter.incLootForItem(item, count);</span>
<span class="fc" id="L2478">	}</span>

	/**
	 * Increases the count of producings for the given item
	 * 
	 * @param item
	 *            the item name
	 * @param count
	 */
	public void incProducedCountForItem(String item, int count) {
<span class="fc" id="L2488">		itemCounter.incProducedForItem(item, count);</span>
<span class="fc" id="L2489">	}</span>

	/**
	 * Increases the count of obtains from the well for the given item
	 * 
	 * @param name
	 *            the item name
	 * @param quantity
	 */
	public void incObtainedForItem(String name, int quantity) {
<span class="nc" id="L2499">		itemCounter.incObtainedForItem(name, quantity);</span>
<span class="nc" id="L2500">	}</span>

	/**
	 * Increases the count of sales for the given item
	 * 
	 * @param name
	 *            the item name
	 * @param quantity
	 */
	public void incSoldForItem(String name, int quantity) {
<span class="fc" id="L2510">		itemCounter.incSoldForItem(name, quantity);</span>
<span class="fc" id="L2511">	}</span>

	/**
	 * Increases the amount of successful minings for the given item
	 * 
	 * @param name
	 *            the item name
	 * @param quantity
	 */
	public void incMinedForItem(String name, int quantity) {
<span class="fc" id="L2521">		itemCounter.incMinedForItem(name, quantity);</span>
<span class="fc" id="L2522">	}</span>

	/**
	 * Increases the amount of successful harvestings for the given item
	 * 
	 * @param name
	 *            the item name
	 * @param quantity
	 */
	public void incHarvestedForItem(String name, int quantity) {
<span class="fc" id="L2532">		itemCounter.incHarvestedForItem(name, quantity);</span>
<span class="fc" id="L2533">	}</span>

	/**
	 * Increases the amount of successful buyings for the given item
	 * 
	 * @param name
	 *            the item name
	 * @param quantity
	 */
	public void incBoughtForItem(String name, int quantity) {
<span class="fc" id="L2543">		itemCounter.incBoughtForItem(name, quantity);</span>
<span class="fc" id="L2544">	}</span>

	/**
	 * Gets the recorded item stored in a substate of quest slot
	 *
	 * @param questname
	 *            The quest's name
	 * @param index
	 *            the index of the sub state to get (separated by &quot;;&quot;)
	 * @return the name of the required item (no formatting)
	 */
	public String getRequiredItemName(String questname, int index) {
<span class="fc" id="L2556">		return quests.getRequiredItemName(questname, index);</span>
	}

	/**
	 * Gets the recorded item quantity stored in a substate of quest slot
	 *
	 * @param questname
	 *            The quest's name
	 * @param index
	 *            the index of the sub state to get (separated by &quot;;&quot;)
	 * @return required item quantity
	 */
	public int getRequiredItemQuantity(String questname, int index) {
<span class="fc" id="L2569">		return quests.getRequiredItemQuantity(questname, index);</span>
	}

	/**
	 * Gets the number of repetitions in a substate of quest slot
	 *
	 * @param questname
	 *            The quest's name
	 * @param index
	 *            the index of the sub state to get (separated by &quot;;&quot;)
	 * @return the integer value in the index of the quest slot, used to
	 *         represent a number of repetitions
	 */
	public int getNumberOfRepetitions(final String questname, final int index) {
<span class="fc" id="L2583">		return quests.getNumberOfRepetitions(questname, index);</span>
	}

	/**
	 * gets the timestmap this client sent the last action
	 *
	 * @return action timestmap
	 */
	public long getLastClientActionTimestamp() {
<span class="nc" id="L2592">		return lastClientActionTimestamp;</span>
	}

	/**
	 * sets the timestamp at which this client sent the last action.
	 *
	 * @param lastClientActionTimestamp
	 *            action timestmap
	 */
	public void setLastClientActionTimestamp(long lastClientActionTimestamp) {
<span class="nc" id="L2602">		this.lastClientActionTimestamp = lastClientActionTimestamp;</span>
<span class="nc" id="L2603">	}</span>

	/**
	 * gets the language
	 *
	 * @return language
	 */
	@Override
	public String getLanguage() {
<span class="fc" id="L2612">		return language;</span>
	}

	/**
	 * sets the language
	 *
	 * @param language
	 *            language
	 */
	public void setLanguage(String language) {
<span class="nc" id="L2622">		this.language = language;</span>
<span class="nc" id="L2623">	}</span>

	/**
	 * adds a use listener causing the client to add an use action with the
	 * specified name
	 * 
	 * @param actionDisplayName
	 *            name of useaction visible in the client
	 * @param listener
	 *            use event listener
	 */
	public void setUseListener(String actionDisplayName, UseListener listener) {
<span class="nc" id="L2635">		put(&quot;menu&quot;, actionDisplayName);</span>
<span class="nc" id="L2636">		this.useListener = listener;</span>
<span class="nc" id="L2637">	}</span>

	/**
	 * gets the current UseListener
	 *
	 * @return UseListener
	 */
	public UseListener getUseListener() {
<span class="nc" id="L2645">		return this.useListener;</span>
	}

	/**
	 * removes a use event listener
	 */
	public void removeUseListener() {
<span class="nc" id="L2652">		remove(&quot;menu&quot;);</span>
<span class="nc" id="L2653">		this.useListener = null;</span>
<span class="nc" id="L2654">	}</span>

	/**
	 * has the player a use listener?
	 *
	 * @return true if there is a use listener registered, false otherwise
	 */
	public boolean hasUseListener() {
<span class="nc bnc" id="L2662" title="All 2 branches missed.">		return this.useListener != null;</span>
	}

	/**
	 * Invoked when the object is used.
	 *
	 * @param user
	 *            the RPEntity who uses the object
	 * @return true if successful
	 */
	@Override
	public boolean onUsed(RPEntity user) {
<span class="nc bnc" id="L2674" title="All 4 branches missed.">		if (useListener == null || !(user instanceof Player)) {</span>
<span class="nc" id="L2675">			return false;</span>
		}
<span class="nc" id="L2677">		return useListener.onUsed(user);</span>
	}

	/**
	 * sets the time a outfit wears off
	 *
	 * @param expire
	 *            expire age
	 */
	public void registerOutfitExpireTime(int expire) {
		// ignore outfits that do not expire
<span class="pc bpc" id="L2688" title="1 of 2 branches missed.">		if (expire &lt; 0) {</span>
<span class="fc" id="L2689">			return;</span>
		}

		// currently we keep only track of one expire, so takes the smallest
		// to prevent players from keeping a highly special outfit longer
		// by renting an outfit with a longer expire time later
<span class="nc" id="L2695">		int oldExpire = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L2696" title="All 2 branches missed.">		if (has(&quot;outfit_expire_age&quot;)) {</span>
<span class="nc" id="L2697">			oldExpire = getInt(&quot;outfit_expire_age&quot;);</span>
		}
<span class="nc bnc" id="L2699" title="All 2 branches missed.">		if (oldExpire &lt; age) {</span>
<span class="nc" id="L2700">			logger.error(&quot;oldExpire &quot; + oldExpire + &quot; for age &quot; + age);</span>
<span class="nc" id="L2701">			oldExpire = Integer.MAX_VALUE;</span>
		}
<span class="nc" id="L2703">		int newExpire = Math.min(expire + age, oldExpire);</span>
<span class="nc" id="L2704">		put(&quot;outfit_expire_age&quot;, newExpire);</span>

<span class="nc" id="L2706">		ExpireOutfit expireOutfit = new ExpireOutfit(super.getName());</span>
<span class="nc" id="L2707">		SingletonRepository.getTurnNotifier().dontNotify(expireOutfit);</span>
<span class="nc" id="L2708">		SingletonRepository.getTurnNotifier().notifyInSeconds(</span>
				(newExpire - age) * 60, expireOutfit);
<span class="nc" id="L2710">	}</span>

	/**
	 * gets the client version
	 *
	 * @return client version
	 */
	public String getClientVersion() {
<span class="nc" id="L2718">		return clientVersion;</span>
	}

	/**
	 * Get the maximum allowed ATK for a level.
	 *
	 * @param level
	 *            checked level
	 * @return maximum ATK
	 */
	private int getMaxAtkForLevel(int level) {
<span class="fc" id="L2729">		return (int) (5 * Math.sqrt(level + 10));</span>
	}

	/**
	 * Get the maximum allowed DEF for a level.
	 *
	 * @param level
	 *            checked level
	 * @return maximum DEF
	 */
	private int getMaxDefForLevel(int level) {
<span class="pc bpc" id="L2740" title="1 of 2 branches missed.">		if (level &gt;= 150) {</span>
			// After the stat boost quest
<span class="fc" id="L2742">			return (int) (10 * Math.cbrt(level) + 60);</span>
		}
<span class="nc" id="L2744">		return getMaxAtkForLevel(level);</span>
	}

	/**
	 * gets the capped atk level, which prevent players from training their atk
	 * way beyond what is reasonable for their level
	 *
	 * @return capped atk
	 */
	@Override
	public int getCappedAtk() {
		// Blue line in http://sourceforge.net/p/arianne/feature-requests/1330/
		// reduced using median instead of average as reference
<span class="fc" id="L2757">		return Math.min(this.atk, getMaxAtkForLevel(level));</span>
	}

	/**
	 * gets the capped def level, which prevent players from training their def
	 * way beyond what is reasonable for their level
	 *
	 * @return capped atk
	 */
	@Override
	public int getCappedDef() {
		// Red line in http://sourceforge.net/p/arianne/feature-requests/1330/
<span class="fc" id="L2769">		return Math.min(this.def, getMaxDefForLevel(level));</span>
	}

	/**
	 * Gets the capped ratk level, which prevent players from training their
	 * ratk way beyond what is reasonable for their level.
	 * 
	 * XXX: Should use getMaxRatkForLevel() method instead?
	 *
	 * @return capped ratk
	 */
	@Override
	public int getCappedRatk() {
<span class="nc" id="L2782">		return Math.min(this.ratk, getMaxAtkForLevel(level));</span>
	}

	/**
	 * Collision handling instructions for players.
	 * 
	 * @param nx
	 *        New horizontal position
	 * @param ny
	 *        New vertical position
	 */
	@Override
	protected void handleSimpleCollision(final int nx, final int ny) {
<span class="nc bnc" id="L2795" title="All 2 branches missed.">		if (isZoneChangeAllowed()) {</span>
<span class="nc bnc" id="L2796" title="All 2 branches missed.">			if (getZone().leavesZone(this, nx, ny)) {</span>
<span class="nc" id="L2797">				handleLeaveZone(nx, ny);</span>
<span class="nc" id="L2798">				return;</span>
			}
		}
<span class="nc bnc" id="L2801" title="All 2 branches missed.">		if (isGhost()) {</span>
<span class="nc" id="L2802">			this.move(getX(), getY(), nx, ny);</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">		} else if (Testing.MOVEMENT) { // TODO: Remove condition after auto-walk testing is finished.</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">			if (this.has(AUTOWALK)) {</span>
<span class="nc" id="L2805">				this.remove(AUTOWALK);</span>
			}

<span class="nc" id="L2808">			this.stop();</span>
		}
<span class="nc" id="L2810">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>