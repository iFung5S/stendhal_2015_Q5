<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AttackPainter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.client.gui.j2d.entity.helpers</a> &gt; <span class="el_source">AttackPainter.java</span></div><h1>AttackPainter.java</h1><pre class="source lang-java linenums">/***************************************************************************
 *                 (C) Copyright 2003-2015 - Faiumoni e.V                  *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.client.gui.j2d.entity.helpers;

import games.stendhal.client.IGameScreen;
import games.stendhal.client.MemoryCache;
import games.stendhal.client.entity.RPEntity;
import games.stendhal.client.gui.TransparencyMode;
import games.stendhal.client.sprite.ImageSprite;
import games.stendhal.client.sprite.Sprite;
import games.stendhal.client.sprite.SpriteStore;
import games.stendhal.common.Direction;
import games.stendhal.common.constants.Nature;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.image.BufferedImage;
import java.util.EnumMap;
import java.util.Locale;
import java.util.Map;

/**
 * An utility for drawing the attack sprites.
 */
public final class AttackPainter {
	/** Number of frames in attack sprites. */
	private static final int NUM_ATTACK_FRAMES = 3;
	/** Tile size for convenience. */
	private static final int TILE_SIZE = IGameScreen.SIZE_UNIT_PIXELS;

	/** Half tile size for convenience. */
	private static final int HALF_TILE = TILE_SIZE / 2;
	/**
	 * Information for positioning. Corresponds to a constant of the same name
	 * in RPEntity2DView.
	 */
	private static final int ICON_OFFSET = 8;

	/** Cache for previously constructed sprite sets. */
<span class="nc" id="L54">	private static final MemoryCache&lt;NatureRef, Map&lt;Direction, Sprite[]&gt;&gt; SWEEP_CACHE = new MemoryCache&lt;NatureRef, Map&lt;Direction, Sprite[]&gt;&gt;();</span>
	/** Cache for the weapon sprites. */
<span class="nc" id="L56">	private static final MemoryCache&lt;WeaponRef, Map&lt;Direction, Sprite[]&gt;&gt; WEAPON_CACHE = new MemoryCache&lt;WeaponRef, Map&lt;Direction, Sprite[]&gt;&gt;();</span>
	/** Colors used for drawing distance attacks. */
	private static final Map&lt;Nature, Color&gt; ARROW_COLOR;

	/** Stroke used for drawing distance attacks. */
<span class="nc" id="L61">	private static final Stroke ARROW_STROKE = new BasicStroke(2);</span>
	static {
<span class="nc" id="L63">		ARROW_COLOR = new EnumMap&lt;Nature, Color&gt;(Nature.class);</span>
<span class="nc" id="L64">		ARROW_COLOR.put(Nature.CUT, Color.LIGHT_GRAY);</span>
<span class="nc" id="L65">		ARROW_COLOR.put(Nature.DARK, Color.DARK_GRAY);</span>
<span class="nc" id="L66">		ARROW_COLOR.put(Nature.LIGHT, new Color(255, 240, 140)); // light yellow</span>
<span class="nc" id="L67">		ARROW_COLOR.put(Nature.FIRE, new Color(255, 100, 0)); // reddish orange</span>
<span class="nc" id="L68">		ARROW_COLOR.put(Nature.ICE, new Color(140, 140, 255)); // light blue</span>
<span class="nc" id="L69">	}</span>
	
	/** Sprite sets for the painter. */
	private final Map&lt;Direction, Sprite[]&gt; map;

	/**
	 * Sprite sets for the weapon, or &lt;code&gt;null&lt;/code&gt; if no weapon sprite is
	 * used.
	 */
	private final Map&lt;Direction, Sprite[]&gt; weaponMap;
	/**
	 * Ranged sprite sets for the weapon, or &lt;code&gt;null&lt;/code&gt; if no weapon
	 * sprite is used for ranged attacks.
	 */
	private final Map&lt;Direction, Sprite[]&gt; rangedWeaponMap;

	/** Sprites used for the current attack. */
	private Sprite[] sprites;

	/**
	 * Weapon sprites used for the current attack, or &lt;code&gt;null&lt;/code&gt; if no
	 * weapon should be drawn.
	 */
	private Sprite[] weaponSprites;
	/** Weapon sprites used for the current ranged attack. */
	private Sprite[] rangedSprites;

	/** Frame counter for the attack. */
	private int frame;

	/** Nature of the attack. */
	private final Nature nature;

	/** Weapon used in the attack, or &lt;code&gt;null&lt;/code&gt;. */
	private final String weapon;
	
	/**
	 * Create a painter using a specified sprite map.
	 * 
	 * @param nature attack nature
	 * @param weapon weapon or &lt;code&gt;null&lt;/code&gt; if no weapon should be drawn
	 * @param sprites sprite map
	 * @param weaponSprites weapon sprite map, or &lt;code&gt;null&lt;/code&gt; if no weapon
	 *        should be drawn.
	 * @param rangedSprites Weapon sprites used for ranged attacks.
	 */
	private AttackPainter(Nature nature, String weapon,
			Map&lt;Direction, Sprite[]&gt; sprites,
			Map&lt;Direction, Sprite[]&gt; weaponSprites,
<span class="nc" id="L118">			Map&lt;Direction, Sprite[]&gt; rangedSprites) {</span>
<span class="nc" id="L119">		this.nature = nature;</span>
<span class="nc" id="L120">		this.map = sprites;</span>
<span class="nc" id="L121">		this.weaponMap = weaponSprites;</span>
<span class="nc" id="L122">		this.rangedWeaponMap = rangedSprites;</span>
<span class="nc" id="L123">		this.weapon = weapon;</span>
<span class="nc" id="L124">	}</span>
	
	/**
	 * Get a painter for attack of a given nature, and size of a creature.
	 * 
	 * @param nature attack nature
	 * @param weapon weapon, or &lt;code&gt;null&lt;/code&gt; if not specified
	 * @param size creature size
	 * 
	 * @return painter
	 */
	public static AttackPainter get(Nature nature, final String weapon, int size) {
<span class="nc" id="L136">		Map&lt;Direction, Sprite[]&gt; sprites = getSpriteMap(nature, size);</span>
<span class="nc" id="L137">		Map&lt;Direction, Sprite[]&gt; weaponSprites = null;</span>
<span class="nc" id="L138">		Map&lt;Direction, Sprite[]&gt; rangedSprites = null;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">		if (weapon != null) {</span>
<span class="nc" id="L140">			WeaponRef ref = new WeaponRef(weapon, size);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">			if (!&quot;ranged&quot;.equals(weapon)) {</span>
<span class="nc" id="L142">				weaponSprites = getSpriteMap(ref, size, WEAPON_CACHE, new SpriteMaker() {</span>
					@Override
					public Sprite getSprite() {
<span class="nc" id="L145">						return createWeaponImage(weapon);</span>
					}
				});
			} else {
<span class="nc" id="L149">				rangedSprites = getSpriteMap(ref, size, WEAPON_CACHE, new SpriteMaker() {</span>
					@Override
					public Sprite getSprite() {
<span class="nc" id="L152">						SpriteStore st = SpriteStore.get();</span>
<span class="nc" id="L153">						Sprite sprite = st.getCombatSprite(weapon + &quot;.png&quot;);</span>
						// Never use the fail safe sprite for attacks
<span class="nc bnc" id="L155" title="All 2 branches missed.">						if (sprite == st.getFailsafe()) {</span>
<span class="nc" id="L156">							return null;</span>
						}
<span class="nc" id="L158">						return sprite;</span>
					}
				});
			}
		}

<span class="nc" id="L164">		return new AttackPainter(nature, weapon, sprites, weaponSprites, rangedSprites);</span>
	}

	/**
	 * Create a weapon sprite mapping of size 1.
	 * 
	 * @param weapon weapon name
	 * @return weapon sprite, or &lt;code&gt;null&lt;/code&gt; if there's no image for
	 *         the weapon
	 */
	private static Sprite createWeaponImage(String weapon) {
<span class="nc" id="L175">		SpriteStore st = SpriteStore.get();</span>
<span class="nc" id="L176">		Sprite template = st.getCombatSprite(weapon + &quot;.png&quot;);</span>
		// Never use the fail safe sprite for attacks
<span class="nc bnc" id="L178" title="All 2 branches missed.">		if (template == st.getFailsafe()) {</span>
<span class="nc" id="L179">			return null;</span>
		}
<span class="nc" id="L181">		final GraphicsConfiguration gc = GraphicsEnvironment</span>
				.getLocalGraphicsEnvironment().getDefaultScreenDevice()
				.getDefaultConfiguration();

<span class="nc" id="L185">		BufferedImage image = gc.createCompatibleImage(288, 512,</span>
				TransparencyMode.TRANSPARENCY);
<span class="nc" id="L187">		Graphics2D g = image.createGraphics();</span>
		
<span class="nc" id="L189">		int partWidth = 96;</span>
<span class="nc" id="L190">		int partHeight = 128;</span>

		// The clippings are to prevent hard to notice translucent weapon trails
		// being drawn outside the intended area. These may be unnoticeable on
		// a test image, but sometimes visible in the game.
		
		// Top middle
<span class="nc" id="L197">		g.clipRect(partWidth, 0, partWidth, partHeight);</span>
<span class="nc" id="L198">		template.draw(g, 84, 40);</span>
		// top left
<span class="nc" id="L200">		g.setClip(0, 0, partWidth, partHeight);</span>
<span class="nc" id="L201">		g.rotate(-Math.PI / 4);</span>
<span class="nc" id="L202">		template.draw(g, -87, 46);</span>
<span class="nc" id="L203">		g.dispose();</span>
		// top right
<span class="nc" id="L205">		g = image.createGraphics();</span>
<span class="nc" id="L206">		g.clipRect(2 * partWidth, 0, partWidth, partHeight);</span>
<span class="nc" id="L207">		g.rotate(Math.PI / 4);</span>
<span class="nc" id="L208">		template.draw(g, 179, -160);</span>

		// 2. row, left
<span class="nc" id="L211">		g.setClip(null);</span>
<span class="nc" id="L212">		template.draw(g, 105, 52);</span>
<span class="nc" id="L213">		g.dispose();</span>
		// 2. row, middle
<span class="nc" id="L215">		g = image.createGraphics();</span>
<span class="nc" id="L216">		g.clipRect(partWidth, partHeight, partWidth, partHeight);</span>
<span class="nc" id="L217">		g.rotate(Math.PI / 2);</span>
<span class="nc" id="L218">		template.draw(g, 147, -192);</span>
<span class="nc" id="L219">		g.dispose();</span>
		// 2. row, right
<span class="nc" id="L221">		g = image.createGraphics();</span>
<span class="nc" id="L222">		g.clipRect(2 * partWidth, partHeight, partWidth, partHeight);</span>
<span class="nc" id="L223">		g.rotate(Math.PI / 4 * 3);</span>
<span class="nc" id="L224">		template.draw(g, -70, -373);</span>

		// 3. row, left
<span class="nc" id="L227">		g.setClip(null);</span>
<span class="nc" id="L228">		template.draw(g, 144, -308);</span>
<span class="nc" id="L229">		g.dispose();</span>
		// 3. row, middle
<span class="nc" id="L231">		g = image.createGraphics();</span>
<span class="nc" id="L232">		g.clipRect(partWidth, 2 * partHeight, partWidth, partHeight);</span>
<span class="nc" id="L233">		g.rotate(Math.PI);</span>
<span class="nc" id="L234">		template.draw(g, -187, -383);</span>
<span class="nc" id="L235">		g.dispose();</span>
		// 3. row, right
<span class="nc" id="L237">		g = image.createGraphics();</span>
<span class="nc" id="L238">		g.clipRect(2 * partWidth, 2 * partHeight, partWidth, partHeight);</span>
<span class="nc" id="L239">		g.rotate(-Math.PI / 4 * 3);</span>
<span class="nc" id="L240">		template.draw(g, -457, -120);</span>

		// 4.row, left
<span class="nc" id="L243">		g.setClip(null);</span>
<span class="nc" id="L244">		template.draw(g, -427, -343);</span>
<span class="nc" id="L245">		g.dispose();</span>
		// 4. row, middle
<span class="nc" id="L247">		g = image.createGraphics();</span>
<span class="nc" id="L248">		g.clipRect(partWidth, 3 * partHeight, partWidth, partHeight);</span>
<span class="nc" id="L249">		g.rotate(-Math.PI / 2);</span>
<span class="nc" id="L250">		template.draw(g, -507, 96);</span>
<span class="nc" id="L251">		g.dispose();</span>
		// 4. row, right
<span class="nc" id="L253">		g = image.createGraphics();</span>
<span class="nc" id="L254">		g.clipRect(2 * partWidth, 3 * partHeight, partWidth, partHeight);</span>
<span class="nc" id="L255">		g.rotate(-Math.PI / 4);</span>
<span class="nc" id="L256">		template.draw(g, -204, 439);</span>
<span class="nc" id="L257">		g.dispose();</span>

<span class="nc" id="L259">		return new ImageSprite(image);</span>
	}

	/**
	 * Get a mapping for nature sweep images.
	 * 
	 * @param nature attack nature
	 * @param size sweep size
	 * @return image mapping
	 */
	private static Map&lt;Direction, Sprite[]&gt; getSpriteMap(final Nature nature, int size) {
<span class="nc" id="L270">		NatureRef ref = new NatureRef(nature, size);</span>
<span class="nc" id="L271">		return getSpriteMap(ref, size, SWEEP_CACHE, new SpriteMaker() {</span>
			@Override
			public Sprite getSprite() {
<span class="nc" id="L274">				SpriteStore st = SpriteStore.get();</span>
<span class="nc" id="L275">				return st.getCombatSprite(&quot;blade_strike_&quot;</span>
						+ nature.toString().toLowerCase(Locale.US) + &quot;.png&quot;);
			}
		});
	}
	
	/**
	 * Find or create an attack sprite map.
	 * 
	 * @param &lt;T&gt; Type of the sprite map reference
	 * @param ref reference for the sprite map
	 * @param size size of the attack image
	 * @param cache cache used for storing created image maps
	 * @param maker sprite retriever for size 1 sprites.
	 * @return sprite map, or &lt;code&gt;null&lt;/code&gt; if the needed base sprites were
	 * not found
	 */
	private static &lt;T&gt; Map&lt;Direction, Sprite[]&gt; getSpriteMap(T ref, int size,
			MemoryCache&lt;T, Map&lt;Direction, Sprite[]&gt;&gt; cache, SpriteMaker maker) {
<span class="nc" id="L294">		Map&lt;Direction, Sprite[]&gt; map = cache.get(ref);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		if (map == null) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			if (size == 1) {</span>
<span class="nc" id="L297">				SpriteStore st = SpriteStore.get();</span>
<span class="nc" id="L298">				Sprite template = maker.getSprite();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">				if (template == null) {</span>
<span class="nc" id="L300">					return null;</span>
				}
<span class="nc" id="L302">				map = splitTiles(st, template);</span>
<span class="nc" id="L303">				cache.put(ref, map);</span>
<span class="nc" id="L304">			} else {</span>
<span class="nc" id="L305">				Map&lt;Direction, Sprite[]&gt; normalSized = getSpriteMap(ref, 1, cache, maker);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">				if (normalSized != null) {</span>
<span class="nc" id="L307">					map = scale(normalSized, size);</span>
<span class="nc" id="L308">					cache.put(ref, map);</span>
				}
			}
		}
<span class="nc" id="L312">		return map;</span>
	}

	/**
	 * Scale all sprites in a attack sprite map, and create a new mapping with
	 * the scaled sprites.
	 * 
	 * @param origMap original sprite mapping. This should be size 1.
	 * @param size the size of the new map
	 * @return map of scaled sprites
	 */
	private static Map&lt;Direction, Sprite[]&gt; scale(
			Map&lt;Direction, Sprite[]&gt; origMap, int size) {
<span class="nc" id="L325">		Map&lt;Direction, Sprite[]&gt; map = new EnumMap&lt;Direction, Sprite[]&gt;(</span>
				Direction.class);
<span class="nc bnc" id="L327" title="All 2 branches missed.">		for (Direction d : Direction.values()) {</span>
<span class="nc" id="L328">			Sprite[] sprites = origMap.get(d);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">			if (sprites != null) {</span>
				// The sprite arrays are the same as in the original. Avoid
				// overwriting those.
<span class="nc" id="L332">				Sprite[] scaled = new Sprite[sprites.length];</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">				for (int i = 0; i &lt; NUM_ATTACK_FRAMES; i++) {</span>
<span class="nc" id="L334">					Sprite orig = sprites[i];</span>

<span class="nc" id="L336">					final GraphicsConfiguration gc = GraphicsEnvironment</span>
							.getLocalGraphicsEnvironment()
							.getDefaultScreenDevice().getDefaultConfiguration();
<span class="nc" id="L339">					int newWidth = orig.getWidth() + (size - 1) * TILE_SIZE;</span>
<span class="nc" id="L340">					double scaling = newWidth / (double) orig.getWidth();</span>

<span class="nc" id="L342">					BufferedImage image = gc.createCompatibleImage(newWidth,</span>
							(int) (orig.getHeight() * scaling),
							TransparencyMode.TRANSPARENCY);
<span class="nc" id="L345">					Graphics2D g = image.createGraphics();</span>
<span class="nc" id="L346">					g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,</span>
							RenderingHints.VALUE_INTERPOLATION_BILINEAR);
<span class="nc" id="L348">					g.scale(scaling, scaling);</span>
<span class="nc" id="L349">					orig.draw(g, 0, 0);</span>

<span class="nc" id="L351">					g.dispose();</span>
<span class="nc" id="L352">					scaled[i] = new ImageSprite(image);</span>
				}
<span class="nc" id="L354">				map.put(d, scaled);</span>
			}
		}
<span class="nc" id="L357">		return map;</span>
	}

	/**
	 * Split a sprite to a set of attack images.
	 * 
	 * @param st sprite store
	 * @param orig sprite to be split
	 * 
	 * @return a map of attack sprites
	 */
	private static Map&lt;Direction, Sprite[]&gt; splitTiles(SpriteStore st,
			Sprite orig) {
<span class="nc" id="L370">		int twidth = NUM_ATTACK_FRAMES * TILE_SIZE;</span>
<span class="nc" id="L371">		int theight = 4 * TILE_SIZE;</span>
<span class="nc" id="L372">		Map&lt;Direction, Sprite[]&gt; map = new EnumMap&lt;Direction, Sprite[]&gt;(</span>
				Direction.class);
<span class="nc" id="L374">		int y = 0;</span>
<span class="nc" id="L375">		map.put(Direction.UP,</span>
				st.getTiles(orig, 0, y, NUM_ATTACK_FRAMES, twidth, theight));
<span class="nc" id="L377">		y += theight;</span>
<span class="nc" id="L378">		map.put(Direction.RIGHT,</span>
				st.getTiles(orig, 0, y, NUM_ATTACK_FRAMES, twidth, theight));
<span class="nc" id="L380">		y += theight;</span>
<span class="nc" id="L381">		map.put(Direction.DOWN,</span>
				st.getTiles(orig, 0, y, NUM_ATTACK_FRAMES, twidth, theight));
<span class="nc" id="L383">		y += theight;</span>
<span class="nc" id="L384">		map.put(Direction.LEFT,</span>
				st.getTiles(orig, 0, y, NUM_ATTACK_FRAMES, twidth, theight));
<span class="nc" id="L386">		return map;</span>
	}

	/**
	 * Draw a melee attack.
	 * 
	 * @param g2d graphics
	 * @param direction attack direction
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param width entity width
	 * @param height entity height
	 */
	public void draw(Graphics2D g2d, Direction direction, int x, int y,
			int width, int height) {


<span class="nc" id="L403">		drawAttackSprite(g2d, sprites, direction, x, y, width, height);</span>
<span class="nc" id="L404">		drawAttackSprite(g2d, weaponSprites, direction, x, y, width, height);</span>

<span class="nc" id="L406">		frame++;</span>
<span class="nc" id="L407">	}</span>
	
	/**
	 * Draw an attack sprite centered on the entity.
	 * 
	 * @param g graphics
	 * @param spriteSet attack sprite set
	 * @param direction attack direction
	 * @param x x coordinate of the entity
	 * @param y y coordinate of the entity
	 * @param width entity width
	 * @param height entity height
	 */
	private void drawAttackSprite(Graphics2D g, Sprite[] spriteSet, Direction direction,
			int x, int y, int width, int height) {
		// Weapon sprite sets can be null
<span class="nc bnc" id="L423" title="All 2 branches missed.">		if (spriteSet == null) {</span>
<span class="nc" id="L424">			return;</span>
		}
<span class="nc" id="L426">		Sprite sprite = spriteSet[frame];</span>
<span class="nc" id="L427">		int spriteWidth = sprite.getWidth();</span>
<span class="nc" id="L428">		int spriteHeight = sprite.getHeight();</span>
		int sx;
		int sy;
		/*
		 * Align swipe image to be 16 px past the facing edge, centering in
		 * other axis.
		 * 
		 * Swipe image is 3x4 tiles, but really only uses partial areas. Adjust
		 * positions to match (or fix images to be uniform/centered).
		 */
<span class="nc bnc" id="L438" title="All 5 branches missed.">		switch (direction) {</span>
		case UP:
<span class="nc" id="L440">			sx = x + ((width - spriteWidth) / 2) + HALF_TILE;</span>
<span class="nc" id="L441">			sy = y - HALF_TILE - TILE_SIZE;</span>
<span class="nc" id="L442">			break;</span>

		case DOWN:
<span class="nc" id="L445">			sx = x + ((width - spriteWidth) / 2);</span>
<span class="nc" id="L446">			sy = y + height - spriteHeight + HALF_TILE;</span>
<span class="nc" id="L447">			break;</span>

		case LEFT:
<span class="nc" id="L450">			sx = x - HALF_TILE;</span>
<span class="nc" id="L451">			sy = y + ((height - spriteHeight) / 2) - HALF_TILE;</span>
<span class="nc" id="L452">			break;</span>

		case RIGHT:
<span class="nc" id="L455">			sx = x + width - spriteWidth + HALF_TILE;</span>
<span class="nc" id="L456">			sy = y + ((height - spriteHeight) / 2) - ICON_OFFSET;</span>
<span class="nc" id="L457">			break;</span>

		default:
<span class="nc" id="L460">			sx = x + ((width - spriteWidth) / 2);</span>
<span class="nc" id="L461">			sy = y + ((height - spriteHeight) / 2);</span>
		}

<span class="nc" id="L464">		sprite.draw(g, sx, sy);</span>
<span class="nc" id="L465">	}</span>

	/**
	 * Draw a distance attack line.
	 * 
	 * @param g2d graphics
	 * @param entity attacking entity
	 * @param target attack target
	 * @param x attacker x coordinate
	 * @param y attacker y coordinate
	 * @param width attacker width
	 * @param height attacker height
	 */
	public void drawDistanceAttack(final Graphics2D g2d, final RPEntity entity,
			final RPEntity target, final int x, final int y, final int width,
			final int height) {
<span class="nc" id="L481">		Nature nature = entity.getShownDamageType();</span>

<span class="nc" id="L483">		int startX = x + width / 2;</span>
<span class="nc" id="L484">		int startY = y + height / 2;</span>
<span class="nc" id="L485">		int endX = (int) (TILE_SIZE * (target.getX() + target.getWidth() / 2));</span>
		// Target at the upper edge of the occupied area.
		// Getting the EntityView from an entity is tedious, and
		// still does not work reliable for everything (rats)
<span class="nc" id="L489">		int endY = (int) (TILE_SIZE * target.getY());</span>

<span class="nc" id="L491">		int yLength = (endY - startY) / NUM_ATTACK_FRAMES;</span>
<span class="nc" id="L492">		int xLength = (endX - startX) / NUM_ATTACK_FRAMES;</span>

<span class="nc" id="L494">		startY += frame * yLength;</span>
<span class="nc" id="L495">		endY = startY + yLength;</span>

<span class="nc" id="L497">		startX += frame * xLength;</span>
<span class="nc" id="L498">		endX = startX + xLength;</span>

<span class="nc" id="L500">		g2d.setColor(ARROW_COLOR.get(nature));</span>
<span class="nc" id="L501">		Stroke oldStroke = g2d.getStroke();</span>
<span class="nc" id="L502">		g2d.setStroke(ARROW_STROKE);</span>
<span class="nc" id="L503">		g2d.drawLine(startX, startY, endX, endY);</span>
<span class="nc" id="L504">		g2d.setStroke(oldStroke);</span>
		
<span class="nc" id="L506">		drawAttackSprite(g2d, rangedSprites, entity.getDirection(), x, y, width, height);</span>

<span class="nc" id="L508">		frame++;</span>
<span class="nc" id="L509">	}</span>

	/**
	 * Check if this painter has the given nature an weapon.
	 * 
	 * @param nature nature to compare to
	 * @param weapon weapon to compare to
	 * @return &lt;code&gt;true&lt;/code&gt; if the painter has the given nature, otherwise
	 *         &lt;code&gt;false&lt;/code&gt;
	 */
	public boolean hasNatureAndWeapon(Nature nature, String weapon) {
<span class="nc bnc" id="L520" title="All 10 branches missed.">		return this.nature == nature</span>
				&amp;&amp; ((weapon == null &amp;&amp; this.weapon == null) || (weapon != null &amp;&amp; weapon
						.equals(this.weapon)));
	}

	/**
	 * Check if the current attack has been completely drawn.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if drawing the attack has been completed,
	 *         otherwise &lt;code&gt;false&lt;/code&gt;
	 */
	public boolean isDoneAttacking() {
<span class="nc bnc" id="L532" title="All 2 branches missed.">		if (frame &lt; NUM_ATTACK_FRAMES) {</span>
<span class="nc" id="L533">			return false;</span>
		}
<span class="nc" id="L535">		frame = 0;</span>
<span class="nc" id="L536">		return true;</span>
	}

	/**
	 * Prepare for an attack to a given direction.
	 * 
	 * @param direction attack direction
	 */
	public void prepare(Direction direction) {
<span class="nc" id="L545">		sprites = map.get(direction);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">		if (weaponMap != null) {</span>
<span class="nc" id="L547">			weaponSprites = weaponMap.get(direction);</span>
		} else {
<span class="nc" id="L549">			weaponSprites = null;</span>
		}
<span class="nc bnc" id="L551" title="All 2 branches missed.">		if (rangedWeaponMap != null) {</span>
<span class="nc" id="L552">			rangedSprites = rangedWeaponMap.get(direction);</span>
		} else {
<span class="nc" id="L554">			rangedSprites = null;</span>
		}

<span class="nc" id="L557">		frame = 0;</span>
<span class="nc" id="L558">	}</span>
	
	/**
	 * Interface for attack image retrievers.
	 */
	private interface SpriteMaker {
		/**
		 * Get an attack sprite of size 1.
		 *  
		 * @return attack sprite, or &lt;code&gt;null&lt;/code&gt; if the sprite could not
		 * be found
		 */
		Sprite getSprite();
	}
	
	/**
	 * A reference object for caching sweep sprite mappings.
	 */
	private static final class NatureRef {
		/** Nature of the sprite mapping. */
		private final Nature nature;
		/** Size of the sprite mapping. */
		private final int size;

		/**
		 * Create a new painter reference.
		 * 
		 * @param nature attack nature
		 * @param size creature size
		 */
<span class="nc" id="L588">		private NatureRef(Nature nature, int size) {</span>
<span class="nc" id="L589">			this.nature = nature;</span>
<span class="nc" id="L590">			this.size = size;</span>
<span class="nc" id="L591">		}</span>

		@Override
		public boolean equals(Object o) {
<span class="nc bnc" id="L595" title="All 2 branches missed.">			if (o instanceof NatureRef) {</span>
<span class="nc" id="L596">				NatureRef obj = (NatureRef) o;</span>
<span class="nc bnc" id="L597" title="All 4 branches missed.">				return (size == obj.size) &amp;&amp; (nature == obj.nature);</span>
			}
<span class="nc" id="L599">			return false;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L604">			return nature.hashCode() * 37 + size;</span>
		}
	}

	/**
	 * Reference object for weapon sprite mappings.
	 */
	private static final class WeaponRef {
		/** Weapon name. */
		private final String weapon;
		/** Size of the sprite mapping. */
		private final int size;

		/**
		 * Create a new WeaponRef.
		 * 
		 * @param weapon weapon name
		 * @param size size of the sprite mapping
		 */
<span class="nc" id="L623">		WeaponRef(String weapon, int size) {</span>
<span class="nc" id="L624">			this.weapon = weapon;</span>
<span class="nc" id="L625">			this.size = size;</span>
<span class="nc" id="L626">		}</span>

		@Override
		public boolean equals(Object o) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">			if (o instanceof WeaponRef) {</span>
<span class="nc" id="L631">				WeaponRef obj = (WeaponRef) o;</span>
<span class="nc bnc" id="L632" title="All 10 branches missed.">				return (size == obj.size)</span>
						&amp;&amp; ((weapon == null &amp;&amp; obj.weapon == null) || (weapon != null &amp;&amp; weapon
								.equals(obj.weapon)));
			}
<span class="nc" id="L636">			return false;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L641">			return weapon.hashCode() * 37 + size;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>