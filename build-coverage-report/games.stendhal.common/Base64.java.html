<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Base64.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.common</a> &gt; <span class="el_source">Base64.java</span></div><h1>Base64.java</h1><pre class="source lang-java linenums">//////////////////////license &amp; copyright header/////////////////////////
//                                                                     //
//    Base64 - encode/decode data using the Base64 encoding scheme     //
//                                                                     //
//                Copyright (c) 1998 by Kevin Kelley                   //
//                                                                     //
// This library is free software; you can redistribute it and/or       //
// modify it under the terms of the GNU Lesser General Public          //
// License as published by the Free Software Foundation; either        //
// version 2.1 of the License, or (at your option) any later version.  //
//                                                                     //
// This library is distributed in the hope that it will be useful,     //
// but WITHOUT ANY WARRANTY; without even the implied warranty of      //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       //
// GNU Lesser General Public License for more details.                 //
//                                                                     //
// You should have received a copy of the GNU Lesser General Public    //
// License along with this library; if not, write to the Free Software //
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA           //
// 02111-1307, USA, or contact the author:                             //
//                                                                     //
// Kevin Kelley &lt;kelley@ruralnet.net&gt; - 30718 Rd. 28, La Junta, CO,    //
// 81050  USA.                                                         //
//                                                                     //
////////////////////end license &amp; copyright header///////////////////////

//Added 10May04 by Adam Turk for distribution as part
package games.stendhal.common; 

//of the Tiled codebase

/**
 * Provides encoding of raw bytes to base64-encoded characters, and decoding of
 * base64 characters to raw bytes.
 * 
 * @author Kevin Kelley (kelley@ruralnet.net)
 * @version 1.3
 */
<span class="nc" id="L39">public class Base64 {</span>

	/**
	 * returns an array of base64-encoded characters to represent the passed
	 * data array.
	 * 
	 * @param data
	 *            the array of bytes to encode
	 * @return base64-coded character array.
	 */
	public static char[] encode(final byte[] data) {
<span class="fc" id="L50">		final char[] out = new char[((data.length + 2) / 3) * 4];</span>

		//
		// 3 bytes encode to 4 chars. Output is always an even
		// multiple of 4 characters.
		//
<span class="fc bfc" id="L56" title="All 4 branches covered.">		for (int i = 0, index = 0; i &lt; data.length; i += 3, index += 4) {</span>
<span class="fc" id="L57">			boolean quad = false;</span>
<span class="fc" id="L58">			boolean trip = false;</span>

<span class="fc" id="L60">			int val = (0xFF &amp; data[i]);</span>
<span class="fc" id="L61">			val &lt;&lt;= 8;</span>
<span class="fc bfc" id="L62" title="All 4 branches covered.">			if ((i + 1) &lt; data.length) {</span>
<span class="fc" id="L63">				val |= (0xFF &amp; data[i + 1]);</span>
<span class="fc" id="L64">				trip = true;</span>
			}
<span class="fc" id="L66">			val &lt;&lt;= 8;</span>
<span class="fc bfc" id="L67" title="All 4 branches covered.">			if ((i + 2) &lt; data.length) {</span>
<span class="fc" id="L68">				val |= (0xFF &amp; data[i + 2]);</span>
<span class="fc" id="L69">				quad = true;</span>
			}
<span class="fc bfc" id="L71" title="All 4 branches covered.">			out[index + 3] = alphabet[quad ? (val &amp; 0x3F) : 64];</span>
<span class="fc" id="L72">			val &gt;&gt;= 6;</span>
<span class="fc bfc" id="L73" title="All 4 branches covered.">			out[index + 2] = alphabet[(trip ? (val &amp; 0x3F) : 64)];</span>
<span class="fc" id="L74">			val &gt;&gt;= 6;</span>
<span class="fc" id="L75">			out[index + 1] = alphabet[val &amp; 0x3F];</span>
<span class="fc" id="L76">			val &gt;&gt;= 6;</span>
<span class="fc" id="L77">			out[index] = alphabet[val &amp; 0x3F];</span>
		}
<span class="fc" id="L79">		return out;</span>
	}

	/**
	 * Decodes a BASE-64 encoded stream to recover the original data. White
	 * space before and after will be trimmed away, but no other manipulation of
	 * the input will be performed.
	 * 
	 * As of version 1.2 this method will properly handle input containing junk
	 * characters (newlines and the like) rather than throwing an error. It does
	 * this by pre-parsing the input and generating from that a count of VALID
	 * input characters.
	 * @param data data to decode
	 * @return the decoded data
	 */
	public static byte[] decode(final char[] data) {
		// as our input could contain non-BASE64 data (newlines,
		// whitespace of any sort, whatever) we must first adjust
		// our count of USABLE data so that...
		// (a) we don't misallocate the output array, and
		// (b) think that we miscalculated our data length
		// just because of extraneous throw-away junk

<span class="fc" id="L102">		int tempLen = data.length;</span>
<span class="fc bfc" id="L103" title="All 4 branches covered.">		for (int ix = 0; ix &lt; data.length; ix++) {</span>
<span class="pc bpc" id="L104" title="2 of 8 branches missed.">			if ((data[ix] &gt; 255) || (codes[data[ix]] &lt; 0)) {</span>
				// ignore non-valid chars and padding
<span class="fc" id="L106">				--tempLen; </span>
			}
		}
		// calculate required length:
		// -- 3 bytes for every 4 valid base64 chars
		// -- plus 2 bytes if there are 3 extra base64 chars,
		// or plus 1 byte if there are 2 extra.

<span class="fc" id="L114">		int len = (tempLen / 4) * 3;</span>
<span class="fc bfc" id="L115" title="All 4 branches covered.">		if ((tempLen % 4) == 3) {</span>
<span class="fc" id="L116">			len += 2;</span>
		}
<span class="fc bfc" id="L118" title="All 4 branches covered.">		if ((tempLen % 4) == 2) {</span>
<span class="fc" id="L119">			len += 1;</span>
		}

<span class="fc" id="L122">		final byte[] out = new byte[len];</span>

		// # of excess bits stored in accum
<span class="fc" id="L125">		int shift = 0; </span>
		
		// excess bits
<span class="fc" id="L128">		int accum = 0; </span>
<span class="fc" id="L129">		int index = 0;</span>

		// we now go through the entire array (NOT using the 'tempLen' value)
<span class="fc bfc" id="L132" title="All 4 branches covered.">		for (int ix = 0; ix &lt; data.length; ix++) {</span>
<span class="pc bpc" id="L133" title="2 of 4 branches missed.">			final int value = (data[ix] &gt; 255) ? -1 : codes[data[ix]];</span>

<span class="fc bfc" id="L135" title="All 4 branches covered.">			if (value &gt;= 0) { </span>
				// skip over non-code
				
				// bits shift up by 6 each time thru
<span class="fc" id="L139">				accum &lt;&lt;= 6;</span>
				
				// loop, with new bits being put in
<span class="fc" id="L142">				shift += 6; </span>
				
				// at the bottom.
<span class="fc" id="L145">				accum |= value; </span>
<span class="fc bfc" id="L146" title="All 4 branches covered.">				if (shift &gt;= 8) { </span>
					// whenever there are 8 or more shifted in,
					// write them out (from the top, leaving any
					// excess at the bottom for next iteration.
<span class="fc" id="L150">					shift -= 8; </span>
					
<span class="fc" id="L152">					out[index++] = 	(byte) ((accum &gt;&gt; shift) &amp; 0xff);</span>
				}
			}
			// we will also have skipped processing a padding null byte ('=')
			// here;
			// these are used ONLY for padding to an even length and do not
			// legally
			// occur as encoded data. for this reason we can ignore the fact
			// that
			// no index++ operation occurs in that special case: the out[] array
			// is
			// initialized to all-zero bytes to start with and that works to our
			// advantage in this combination.
		}

		// if there is STILL something wrong we just have to throw up now!
<span class="pc bpc" id="L168" title="2 of 4 branches missed.">		if (index != out.length) {</span>
<span class="nc" id="L169">			throw new Error(&quot;Miscalculated data length (wrote &quot; + index</span>
					+ &quot; instead of &quot; + out.length + &quot;)&quot;);
		}

<span class="fc" id="L173">		return out;</span>
	}

	//
	// code characters for values 0..63
	//
<span class="fc" id="L179">	private static final char[] alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;.toCharArray();</span>

	//
	// lookup table for converting base64 characters to value in range 0..63
	//
<span class="fc" id="L184">	private static byte[] codes = new byte[256];</span>
	static {
<span class="fc bfc" id="L186" title="All 4 branches covered.">		for (int i = 0; i &lt; 256; i++) {</span>
<span class="fc" id="L187">			codes[i] = -1;</span>
		}
<span class="fc bfc" id="L189" title="All 4 branches covered.">		for (int i = 'A'; i &lt;= 'Z'; i++) {</span>
<span class="fc" id="L190">			codes[i] = (byte) (i - 'A');</span>
		}
<span class="fc bfc" id="L192" title="All 4 branches covered.">		for (int i = 'a'; i &lt;= 'z'; i++) {</span>
<span class="fc" id="L193">			codes[i] = (byte) (26 + i - 'a');</span>
		}
<span class="fc bfc" id="L195" title="All 4 branches covered.">		for (int i = '0'; i &lt;= '9'; i++) {</span>
<span class="fc" id="L196">			codes[i] = (byte) (52 + i - '0');</span>
		}
<span class="fc" id="L198">		codes['+'] = 62;</span>
<span class="fc" id="L199">		codes['/'] = 63;</span>
<span class="fc" id="L200">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>