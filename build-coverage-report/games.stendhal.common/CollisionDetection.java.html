<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CollisionDetection.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stendhal</a> &gt; <a href="index.source.html" class="el_package">games.stendhal.common</a> &gt; <span class="el_source">CollisionDetection.java</span></div><h1>CollisionDetection.java</h1><pre class="source lang-java linenums">/* $Id$ */
/***************************************************************************
 *                      (C) Copyright 2003 - Marauroa                      *
 ***************************************************************************
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
package games.stendhal.common;


import games.stendhal.common.tiled.LayerDefinition;

import java.awt.geom.Rectangle2D;

/**
 * This class loads the map and allow you to determine if a player collides or
 * not with any of the non trespasable areas of the world.
 */
<span class="fc" id="L24">public class CollisionDetection {</span>
	private CollisionMap map;

	private int width;

	private int height;

	/**
	 * Clear the collision map.
	 */
	public void clear() {
<span class="fc bfc" id="L35" title="All 4 branches covered.">		if (map == null) {</span>
<span class="fc" id="L36">			map = new CollisionMap(width, height);</span>
		}
<span class="fc" id="L38">	}</span>

	/**
	 * Initialize the collision map to desired size.
	 * 
	 * @param width width of the map
	 * @param height height of the map
	 */
	public void init(final int width, final int height) {
<span class="pc bpc" id="L47" title="2 of 8 branches missed.">		if (this.width != width || this.height != height) {</span>
<span class="fc" id="L48">			map = null;</span>
<span class="pc bpc" id="L49" title="2 of 4 branches missed.">		} else if (map != null) {</span>
<span class="fc" id="L50">			map.clear();</span>
		}
		
<span class="fc" id="L53">		this.width = width;</span>
<span class="fc" id="L54">		this.height = height;</span>
		
<span class="fc" id="L56">		clear();</span>
<span class="fc" id="L57">	}</span>

	/**
	 * Set a position in the collision map to static collision.
	 * 
	 * @param x x coordinate
	 * @param y y coordinate
	 */
	public void setCollide(final int x, final int y) {
<span class="pc bpc" id="L66" title="4 of 16 branches missed.">		if ((x &lt; 0) || (x &gt;= width) || (y &lt; 0) || (y &gt;= height)) {</span>
<span class="fc" id="L67">			return;</span>
		}
<span class="fc" id="L69">		map.set(x, y);</span>
<span class="fc" id="L70">	}</span>
	
	/**
	 * Fill the collision map from layer data.
	 * 
	 * @param collisionLayer static collision information
	 */
	public void setCollisionData(final LayerDefinition collisionLayer) {
		// First we build the int array.
<span class="fc" id="L79">		collisionLayer.build();</span>
<span class="fc" id="L80">		init(collisionLayer.getWidth(), collisionLayer.getHeight());</span>
		
<span class="fc bfc" id="L82" title="All 4 branches covered.">		for (int y = 0; y &lt; height; y++) {</span>
<span class="fc bfc" id="L83" title="All 4 branches covered.">			for (int x = 0; x &lt; width; x++) {</span>
				/*
				 * NOTE: Right now our collision detection system is binary, so
				 * something or is blocked or is not.
				 */
<span class="fc bfc" id="L88" title="All 4 branches covered.">				boolean b = collisionLayer.getTileAt(x, y) != 0;</span>
<span class="fc bfc" id="L89" title="All 4 branches covered.">				if (b) {</span>
<span class="fc" id="L90">					map.set(x, y);</span>
				}		
			}
		}
<span class="fc" id="L94">	}</span>

	/**
	 * Print the area around the (x,y) useful for debugging.
	 *  
	 * @param x x-coordinate
	 * @param y y-coordinate
	 * @param size size of surroundings
	 */
	public void printaround(final int x, final int y, final int size) {
<span class="nc bnc" id="L104" title="All 4 branches missed.">		for (int j = y - size; j &lt; y + size; j++) {</span>
<span class="nc bnc" id="L105" title="All 4 branches missed.">			for (int i = x - size; i &lt; x + size; i++) {</span>
<span class="nc bnc" id="L106" title="All 16 branches missed.">				if ((j &gt;= 0) &amp;&amp; (j &lt; height) &amp;&amp; (i &gt;= 0) &amp;&amp; (i &lt; width)) {</span>
<span class="nc bnc" id="L107" title="All 8 branches missed.">					if ((j == y) &amp;&amp; (i == x)) {</span>
<span class="nc" id="L108">						System.out.print(&quot;O&quot;);</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">					} else if (map.get(i, j)) {</span>
<span class="nc" id="L110">						System.out.print(&quot;X&quot;);</span>
					} else {
<span class="nc" id="L112">						System.out.print(&quot;.&quot;);</span>
					}
				}
			}
<span class="nc" id="L116">			System.out.println();</span>
		}
<span class="nc" id="L118">	}</span>

	/**
	 * Check if a rectangle is at least partially outside the map.
	 * 
	 * @param shape area to be checked
	 * @return &lt;code&gt;true&lt;/code&gt; if shape is at least partially outside the map,
	 * 	&lt;code&gt;false&lt;/code&gt; otherwise
	 */
	public boolean leavesZone(final Rectangle2D shape) {
<span class="fc" id="L128">		final double x = shape.getX();</span>
<span class="fc" id="L129">		final double y = shape.getY();</span>
<span class="fc" id="L130">		final double w = shape.getWidth();</span>
<span class="fc" id="L131">		final double h = shape.getHeight();</span>

<span class="fc bfc" id="L133" title="All 8 branches covered.">		if ((x &lt; 0) || (x + w &gt; width)) {</span>
<span class="fc" id="L134">			return true;</span>
		}

<span class="fc bfc" id="L137" title="All 8 branches covered.">		if ((y &lt; 0) || (y + h &gt; height)) {</span>
<span class="fc" id="L138">			return true;</span>
		}

<span class="fc" id="L141">		return false;</span>
	}

	/**
	 * Check if a rectangle overlaps colliding areas.
	 * 
	 * @param shape checked area
	 * @return &lt;code&gt;true&lt;/code&gt; if the shape enters in any of the non
	 *	trespassable areas of the map, &lt;code&gt;false&lt;/code&gt; otherwise
	 */
	public boolean collides(final Rectangle2D shape) {
<span class="fc" id="L152">		final double x = shape.getX();</span>
<span class="fc" id="L153">		final double y = shape.getY();</span>
<span class="fc" id="L154">		final double w = shape.getWidth();</span>
<span class="fc" id="L155">		final double h = shape.getHeight();</span>
<span class="fc" id="L156">		return collides(x, y, w, h);</span>
	}


	/**
	 * Check if a rectangle overlaps colliding areas.
	 * 
	 * @param x x-position
	 * @param y y-position
	 * @param w width
	 * @param h height
	 * @return &lt;code&gt;true&lt;/code&gt; if the shape enters in any of the non
	 *	trespassable areas of the map, &lt;code&gt;false&lt;/code&gt; otherwise
	 */
	public boolean collides(final double x, final double y, final double w, final double h) {
		/*
		 * CollisionMap does the same tests, but least tests use zones without
		 * collisions, so it's simplest to do them here too.
		 */
<span class="fc bfc" id="L175" title="All 8 branches covered.">		if ((x &lt; 0) || (x + w &gt; width)) {</span>
<span class="fc" id="L176">			return true;</span>
		}
<span class="fc bfc" id="L178" title="All 8 branches covered.">		if ((y &lt; 0) || (y + h &gt; height)) {</span>
<span class="fc" id="L179">			return true;</span>
		}

<span class="fc" id="L182">		int iHeight = (int) Math.ceil(Math.ceil(y + h) - y);</span>
<span class="fc" id="L183">		int iWidth = (int) Math.ceil(Math.ceil(x + w) - x);</span>
<span class="fc" id="L184">		return map.collides((int) x, (int) y, iWidth, iHeight);</span>
	}

	/**
	 * Check if a location is marked with collision.
	 * 
	 * @param x x coordinate
	 * @param y y coordinate
	 * @return &lt;code&gt;true&lt;/code&gt; if the map position is a collision tile,
	 * 	otherwise &lt;code&gt;false&lt;/code&gt; 
	 */
	public boolean collides(final int x, final int y) {
<span class="fc bfc" id="L196" title="All 8 branches covered.">		if ((x &lt; 0) || (x &gt;= width)) {</span>
<span class="fc" id="L197">			return true;</span>
		}

<span class="fc bfc" id="L200" title="All 8 branches covered.">		if ((y &lt; 0) || (y &gt;= height)) {</span>
<span class="fc" id="L201">			return true;</span>
		}
<span class="fc" id="L203">		return map.get(x, y);</span>
	}

	/**
	 * Get the width of the collision map.
	 * 
	 * @return width
	 */
	public int getWidth() {
<span class="fc" id="L212">		return width;</span>
	}

	/**
	 * Get the height of the collision map.
	 * 
	 * @return height
	 */
	public int getHeight() {
<span class="fc" id="L221">		return height;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>